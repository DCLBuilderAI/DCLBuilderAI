Text,Code
,
/* create avocado */,"/* At the end of your sceneâ€™s index.ts file, add the following lines: */`
let avocado = engine.addEntity()

GltfContainer.create(avocado, {src: (""models/avocado.gltf""})

Transform.create(avocado, {
          position:  Vector3.create(3, 1, 3),
          scale: Vector3.create(10, 10, 10)
})"
/* create a sphere */,"// creates sphere entity
const sphere = new Entity()
sphere.addComponentOrReplace(new Transform({
  position: new Vector3(5, 1, 5)
}))
sphere.addComponentOrReplace(new SphereShape())

engine.addEntity(sphere)"
/* spawn a cube */,"/// --- Spawner function ---

function spawnCube(x: number, y: number, z: number) {
  // create the entity
  const cube = new Entity()

  // add a transform to the entity
  cube.addComponent(new Transform({ position: new Vector3(x, y, z) }))

  // add a shape to the entity
  cube.addComponent(new BoxShape())

  // add the entity to the engine
  engine.addEntity(cube)

  return cube
}

/// --- Spawn a cube ---

const cube = spawnCube(8, 1, 8)

cube.addComponent(
  new OnPointerDown(() => {
    cube.getComponent(Transform).scale.z *= 1.1
    cube.getComponent(Transform).scale.x *= 0.9

    spawnCube(Math.random() * 8 + 1, Math.random() * 8, Math.random() * 8 + 1)
  })
)"
/* create a cylinder */,"// create variable to hold cylinder
const cylinder = new Entity()

// we transform the component to set the position
// of the sphere in the scene
cylinder.addComponentOrReplace(new Transform({
  position: new Vector3(2, 1, 2)
}))
cylinder.addComponentOrReplace(new CylinderShape())


// add the sphere to the scene
engine.addEntity(cylinder)"
/* create text */,"//creates entity
const myEntity = new Entity()

// creates text shape
const myText = new TextShape(""Hello World!"")

// adds text shape to entity 
myEntity.addComponent(myText)"
/* create box */ ,"// create the entity 
const box = new Entity()

// transform the entity to give it a position
box.addComponentOrReplace(new Transform({
  position: new Vector3(2, 1, 2)
}))

// add shape to the entity 
box.addComponentOrReplace(new BoxShape())

// render entity in scene
engine.addEntity(box)"
/* create plane */,"// create the entity 
const plane = new Entity()

// transform the entity to give it a position
plane.addComponentOrReplace(new Transform({
  position: new Vector3(2, 1, 2)
}))

// add shape to the entity 
plane.addComponentOrReplace(new PlaneShape())

// render entity in scene
engine.addEntity(plane)"
/* create cone */,"// create the entity 
const cone = new Entity()

// transform the entity to give it a position
cone.addComponentOrReplace(new Transform({
  position: new Vector3(2, 1, 2)
}))

// add shape to the entity 
cone.addComponentOrReplace(new ConeShape())

// render entity in scene
engine.addEntity(cone)"
/* create cylinder */,"// create the entity 
const c = new Entity()

// transform the entity to give it a position
c.addComponentOrReplace(new Transform({
  position: new Vector3(2, 1, 2)
}))

// add shape to the entity 
c.addComponentOrReplace(new CylinderShape())

// render entity in scene
engine.addEntity(c)"
/* add a door */,"const closedPos: Quaternion = Quaternion.Euler(0, 0, 0)

// Add actual door to scene. This entity doesn't rotate, its parent drags it with it.
const door = new Entity()
door.addComponent(
  new Transform({
    position: new Vector3(0.5, 0, 0),
    scale: new Vector3(1, 2, 0.05)
  })
)
door.addComponent(new BoxShape())
engine.addEntity(door)

// Define a material to color the door red
const doorMaterial = new Material()
doorMaterial.albedoColor = Color3.Red()
doorMaterial.metallic = 0.9
doorMaterial.roughness = 0.1

// Assign the material to the door
door.addComponent(doorMaterial)

// Define wrapper entity to rotate door. This is the entity that actually rotates.
const doorPivot = new Entity()
doorPivot.addComponent(
  new Transform({
    position: new Vector3(4, 1, 3),
    rotation: closedPos
  })
)
//doorPivot.addComponent(new DoorState())
engine.addEntity(doorPivot)

// Set the door as a child of doorPivot
door.setParent(doorPivot)"
/* create table */,"// create and entity
const table = new Entity()

// transform the position of the table
table.addComponentOrReplace(new Transform({
  position: new Vector3(5, 0, 5),
  scale: new Vector3(3, 1, 3)
}))
table.addComponentOrReplace(new BoxShape())

// add table to the scene
engine.addEntity(table)"
/* create a sign */,"
const sign = new Entity()
sign.addComponentOrReplace(new Transform({
  position: new Vector3(5, 1, 5)
}))
sign.addComponent(new TextShape(""Welcome to Decentraland!""))

// Define a material to color the sign red
const signMaterial = new Material()
signMaterial.albedoColor = Color3.Red()

// Assign the material to the door
sign.addComponent(signMaterial)

engine.addEntity(sign)"
/* create phone */,"// create new entity
const phone = new Entity()

// add its position
phone.addComponentOrReplace(new Transform({
  position: new Vector3(5, 1, 5),
  scale: new Vector3(0.5, 0.1, 0.2)
}))
phone.addComponentOrReplace(new BoxShape())

// add the enitities details
const material = new Material()
material.metallic = 0.9
material.roughness = 0.1

// add the details to the entity
phone.addComponent(material)

// add entity to the scene
engine.addEntity(phone)"
/* remove box */,"// Create an entity
const box = new Entity()

// Give the entity a shape
box.addComponent(new BoxShape())

// Add the entity to the engine
engine.addEntity(box)
// Remove an entity from the engine
engine.removeEntity(box)"
/* nft frame */,"// NFT picture frame
const entity = new Entity()
const shapeComponent = new NFTShape(
  'ethereum://0x06012c8cf97bead5deae237070f9587f8e7a266d/229795',
  { color: Color3.Blue(), style: PictureFrameStyle.Gold_Carved }
)
entity.addComponent(shapeComponent)
entity.addComponent(
  new Transform({
    position: new Vector3(4, 1.5, 4),
  })
)
engine.addEntity(entity)"
/* fixed wall */,"// fixed wall
const wall1 = new Entity()
wall1.addComponent(
  new Transform({
    position: new Vector3(4.5, 1, 4.1),
    scale: new Vector3(4, 3, 0.05),
  })
)
wall1.addComponent(new BoxShape())
engine.addEntity(wall1)"
/* create ground */,"// ground
const floor = new Entity()
floor.addComponent(new GLTFShape('models/FloorBaseGrass.glb'))
floor.addComponent(
  new Transform({
    position: new Vector3(8, 0, 8),
    scale: new Vector3(1.6, 0.1, 1.6),
  })
)
engine.addEntity(floor)"
/* door material */,"// Define a material to color the door sides red
const doorMaterial = new Material()
doorMaterial.albedoColor = Color3.Red()
doorMaterial.metallic = 0.9
doorMaterial.roughness = 0.1"
/* defining door positions */,"// Define open and closed positions for both door sides
const doorLClosed = new Vector3(0.5, 0, 0)
const doorLOpen = new Vector3(1.25, 0, 0)
const doorRClosed = new Vector3(-0.5, 0, 0)
const doorROpen = new Vector3(-1.25, 0, 0)"
/* creating door parent */,"// This parent entity holds the state for both door sides
const doorParent = new Entity()
doorParent.addComponent(
  new Transform({
    position: new Vector3(4, 1, 3)
  })
)"
/* add physics component to object */,"function createObject() {
  const object = new Entity('object')
  engine.addEntity(object)
  return object
}

const object = createObject();

//Add a BoxCollider component to the object Entity
const colliderComponent = new BoxCollider()
object.addComponent(colliderComponent)

//Add a RigidBody component to the object Entity
const rigidBodyComponent = new RigidBody()
object.addComponent(rigidBodyComponent)"
/* song list */ ,"
// Define song list
const songs: { src: string; name: string }[] = [
  { src: '', name: 'Telemann' },
  { src: '', name: 'Bach' },
  { src: '', name: 'Brahms' },
  { src: '', name: 'Chopin' },
]"
/* jukebox from gltf */ ,"// Jukebox
const jukebox = new Entity()
jukebox.addComponent(new GLTFShape('models/Jukebox.gltf'))
jukebox.addComponent(
  new Transform({
    position: new Vector3(5, 0, 9.5),
    rotation: Quaternion.Euler(0, 180, 0),
    scale: new Vector3(0.6, 0.6, 0.6),
  })
)
engine.addEntity(jukebox)"
/* create a custom wheels component */,"// Custom component to handle wheel spinning
@Component('wheelSpin')
export class WheelSpin {
  active: boolean = false
  speed: number = 0
  direction: Vector3 = Vector3.Up()
}"
/* scene from theater glb */,"// Environment
const stage = new Entity()
stage.addComponent(new GLTFShape('models/Theatre.glb'))
stage.addComponent(
  new Transform({
    position: new Vector3(8, 0, 8),
    rotation: Quaternion.Euler(0, 270, 0),
    scale: new Vector3(0.9, 1, 0.9),
  })
)
engine.addEntity(stage)"
/* create a wheel */,"// Create wheel entities
const wheel = new Entity()
wheel.addComponent(new CylinderShape())
wheel.addComponent(
  new Transform({
    position: new Vector3(6, 2, 11.1),
    rotation: Quaternion.Euler(90, 0, 0),
    scale: new Vector3(1, 0.05, 1),
  })
)
engine.addEntity(wheel)"
/* create a texture */ ,"// Create texture
const spiralTexture = new Texture('')

// Create material
const spiralMaterial = new Material()
spiralMaterial.albedoTexture = spiralTexture"
/* scene model from underwater.gltf */,"// Add 3D model for scenery
const seaBed = new Entity()
seaBed.addComponent(new GLTFShape('models/Underwater.gltf'))
seaBed.addComponent(
  new Transform({
    position: new Vector3(8, 0, 8),
    scale: new Vector3(0.8, 0.8, 0.8),
  })
)
engine.addEntity(seaBed)"
/* generate plane */,"const plane = new Entity()
plane.addComponentOrReplace(new Transform({
  position: new Vector3(4, 4, 4),
  scale: new Vector3(10, 1, 10)
}))
plane.addComponentOrReplace(new PlaneShape())
engine.addEntity(plane)"
/* shark */,"// Add Shark
const shark = new Entity()
shark.addComponent(new GLTFShape('models/shark.glb'))
shark.addComponent(
  new Transform({
    position: new Vector3(8, 3, 8),
  })
)
engine.addEntity(shark)"
/* create fire */ ,"// add fireplace
const fire = new Entity()
fire.addComponent(new GLTFShape('models/Fireplace.glb'))
fire.addComponent(
  new Transform({
    position: new Vector3(8, 0, 8)
  })
)"
/* add smoke */ ,"// Add a smoke source that creates a smoke puff every 0.2 seconds
fire.addComponent(new SmokeSource(0.2))
engine.addEntity(fire)"
"/* Script that creates a door that opens and closes when clicked, needs models/door.glb */","// import utils
import * as utils from '@dcl/ecs-scene-utils'

// create a door entity that opens and closes when clicked
const door = new Entity()
door.addComponent(new GLTFShape('models/door.glb'))
door.addComponent(new Transform({
   position: new Vector3(10, 0, 10)
}))
door.addComponent(new OnClick(e => {
   if (door.getComponent(Transform).rotation.eulerAngles.y === 0) {
      // door is closed, open it
      door.addComponent(new utils.RotateTransformComponent(new Vector3(0, 90, 0), 1)) // rotate 90 degrees in 1 second
   } else {
      // door is open, close it
      door.addComponent(new utils.RotateTransformComponent(new Vector3(0, -90, 0), 1)) // rotate -90 degrees in 1 second
   }
}))

// add the door to the scene
engine.addEntity(door)
"
/* create a class */,"class MyBox extends Entity {
  constructor(position: Vector3) {
    super()
    this.addComponentOrReplace(
      new Transform({
        position,
        rotation: Quaternion.Euler(0, 0, 0),
        scale: new Vector3(1, 1, 1)
      })
    )

    this.addComponentOrReplace(new BoxShape())
  }
}

const myBox = new MyBox(new Vector3(5, 0, 5))

engine.addEntity(myBox)"
/* add pathfinding component to object */,"function createObject() {
  const object = new Entity('object')
  engine.addEntity(object)
  return object
}

const object = createObject();

//Add a Pathfinding component to the object Entity
const pathfindingComponent = new Pathfinding()
object.addComponent(pathfindingComponent)"
/* add text label to scene */,"function createTextLabel() {
  const textLabel = new Entity('textLabel')
  engine.addEntity(textLabel)
  return textLabel
}

const textLabel = createTextLabel();

//Add a TextShape component to the textLabel Entity
const textShape = new TextShape(""Hello, world!"")
textLabel.addComponent(textShape)"
/* add user interface element */,"function createUIElement() {
  const uiElement = new Entity('uiElement')
  engine.addEntity(uiElement)
  return uiElement
}

const uiElement = createUIElement();

//Add a UICanvas component to the uiElement Entity
const canvasComponent = new UICanvas()
uiElement.addComponent(canvasComponent)

//Add a UIImage component to the uiElement Entity
const imageComponent = new UIImage(canvasComponent)
uiElement.addComponent(imageComponent)
"
/* function example */,"function greet(name: string): void {
  log(""Hello, "" + name + ""!"")
}

greet(""John"") // Output: ""Hello, John!"""
/* sum function example */,"function sum(a: number, b: number): number {
  return a + b;
}

console.log(sum(2, 3)); // Output: 5
"
/* capitalize function example */,"function capitalize(word: string): string {
  return word.charAt(0).toUpperCase() + word.slice(1);
}

console.log(capitalize(""hello"")); // Output: ""Hello"""
/* function for fibonnachi */,"function getFibonacciSequence(length: number): number[] {
  const sequence = [0, 1];
  for (let i = 2; i < length; i++) {
    sequence.push(sequence[i - 2] + sequence[i - 1]);
  }
  return sequence;
}

console.log(getFibonacciSequence(10)); // Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]"
/* function for longest word */,"function getLongestWord(words: string[]): string {
  return words.reduce((longest, current) => current.length > longest.length ? current : longest);
}

console.log(getLongestWord([""hello"", ""world"", ""goodbye""])); // Output: ""goodbye"""
/* function to get even numbers */,"function getEvenNumbers(nums: number[]): number[] {
  return nums.filter(num => num % 2 === 0);
}

console.log(getEvenNumbers([1, 2, 3, 4, 5])); // Output: [2, 4]
"
/* function to get first N primes */,"function getFirstNPrimes(n: number): number[] {
  const primes = [];
  let num = 2;
  while (primes.length < n) {
    if (isPrime(num)) {
      primes.push(num);
    }
    num++;
  }
  return primes;
}

function isPrime(num: number): boolean {
  if (num < 2) {
    return false;
  }
  for (let i = 2; i <= Math.sqrt(num); i++) {
    if (num % i === 0) {
      return false;
    }
  }
  return true;
}

console.log(getFirstNPrimes(5)); // Output: [2, 3, 5, 7, 11]"
/* function for averages */,"function getAverage(nums: number[]): number {
  const sum = nums.reduce((a, b) => a + b);
  return sum / nums.length;
}

console.log(getAverage([1, 2, 3, 4, 5])); // Output: 3"
/* function to check evenness */,"function isEven(num: number): boolean {
  return num % 2 === 0;
}

console.log(isEven(4)); // Output: true"
/* factorial function */,"function getFactorial(num: number): number {
  if (num <= 1) {
    return 1;
  } else {
    return num * getFactorial(num - 1);
  }
}

console.log(getFactorial(5)); // Output: 120
"
/* reverse string function */,"function reverseString(str: string): string {
  return str.split("""").reverse().join("""");
}

console.log(reverseString(""hello"")); // Output: ""olleh"""
/* add sprite to scene */,"function createSprite() {
  const sprite = new Entity('sprite')
  engine.addEntity(sprite)
  return sprite
}

const sprite = createSprite();

//Add a Sprite component to the sprite Entity
const spriteComponent = new Sprite()
sprite.addComponent(spriteComponent)"
/* function to create a 'door' entity */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}"
/* add a shape to the door */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

//Add a shape component to the door Entity
const doorShape = new BoxShape()
door.addComponent(doorShape)"
/* add material to the door */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

// Add a material component to the door Entity
const doorMaterial = new Material()
doorMaterial.albedoColor = Color3.FromHexString(""#8B5E3C"")
door.addComponent(doorMaterial)"
/* transform the door */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

//  Create a Transform component to position the door
const doorTransform = new Transform({
  position: new Vector3(8, 0, 8),
  scale: new Vector3(1, 2, 0.5)
})
door.addComponent(doorTransform)"
/* function to open and close the door */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

// Create a function to open and close the door
function toggleDoor() {
  if (doorTransform.rotation.y === 0) {
    doorTransform.rotation.y = 1.57
  } else {
    doorTransform.rotation.y = 0
  }
}"
/* function for interacting with the door */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

// Create a function to open and close the door
function toggleDoor() {
  if (doorTransform.rotation.y === 0) {
    doorTransform.rotation.y = 1.57
  } else {
    doorTransform.rotation.y = 0
  }
}

// Create a clicking event to trigger the toggleDoor function
door.addComponent(
  new OnClick(() => {
    toggleDoor()
  })
)"
/* on door hover */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

// Create a hover event to change the door material when hovered over
door.addComponent(
  new OnPointerHoverEnter(() => {
    doorMaterial.albedoColor = Color3.FromHexString(""#A0522D"")
  })
)
door.addComponent(
  new OnPointerHoverExit(() => {
    doorMaterial.albedoColor = Color3.FromHexString(""#8B5E3C"")
  })
)"
/* function the add sound to the door */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

// Add a sound component to play a sound when the door opens or closes
const doorSound = new AudioClip('sounds/door-open-close.mp3')
const doorAudioSource = new AudioSource(doorSound)
door.addComponent(doorAudioSource)"
/* function for sound when door opens and closes */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

// Add a sound component to play a sound when the door opens or closes
const doorSound = new AudioClip('sounds/door-open-close.mp3')
const doorAudioSource = new AudioSource(doorSound)
door.addComponent(doorAudioSource)

// Modify the toggleDoor function to play a sound when the door opens or closes
function toggleDoorWithSound() {
  if (doorTransform.rotation.y === 0) {
    doorTransform.rotation.y = 1.57
    doorAudioSource.playOnce()
  } else {
    doorTransform.rotation.y = 0
    doorAudioSource.playOnce()
  }
}"
/* play sound when the door opens */,"const door = createDoor();

// Add a sound component to play a sound when the door opens or closes
const doorSound = new AudioClip('sounds/door-open-close.mp3')
const doorAudioSource = new AudioSource(doorSound)
door.addComponent(doorAudioSource)

// Modify the toggleDoor function to play a sound when the door opens or closes
function toggleDoorWithSound() {
  if (doorTransform.rotation.y === 0) {
    doorTransform.rotation.y = 1.57
    doorAudioSource.playOnce()
  } else {
    doorTransform.rotation.y = 0
    doorAudioSource.playOnce()
  }
}

// Update the OnClick event to trigger the toggleDoorWithSound function
door.addComponent(
  new OnClick(() => {
    toggleDoorWithSound()
  })
)"
/* create player */,"// Create the player entity
const player = new Entity(""player"");
engine.addEntity(player);

// Add a transform component to the player
const playerTransform = new Transform({
  position: new Vector3(0, 0, 0),
  rotation: Quaternion.Euler(0, 0, 0),
  scale: new Vector3(1, 1, 1)
});
player.addComponentOrReplace(playerTransform);

// Add a GLTF shape component to the player
const playerGltf = new GLTFShape(""models/player.glb"");
player.addComponentOrReplace(playerGltf);"
/* shooting range score entity */,"export class Score extends Entity {
  constructor(model: GLTFShape, position: Vector3, rotation: Quaternion, scale: Vector3) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Transform({ position, rotation, scale }))
    this.addComponent(new TextShape('Score: 0')) // Display the score
  }
}
"
/* add movement to the player */,"// Create the player entity
const player = new Entity(""player"");
engine.addEntity(player);

// Add a movement component to the player
const playerMovement = new MoveTransformComponent(new Vector3(0, 0, 10), new Vector3(0, 0, 10),
5);
player.addComponentOrReplace(playerMovement);"
/* clickable plane */,"const plane = new Entity()
plane.addComponent(new Transform({
  position: new Vector3(5, 0, 5)
}))
plane.addComponent(new PlaneShape())
plane.addComponent(new OnClick(e => {
  log('Plane was clicked!')
}))

engine.addEntity(plane)"
/* changing color sphere onClick */,"const sphere = new Entity()
sphere.addComponent(new Transform({
  position: new Vector3(5, 0, 5)
}))
sphere.addComponent(new SphereShape())
sphere.addComponent(new Material())

const originalColor = new Color3(1, 0, 0)
sphere.getComponent(Material).albedoColor = originalColor

sphere.addComponent(new OnClick(e => {
  const material = sphere.getComponent(Material)
  material.albedoColor = (material.albedoColor === (originalColor)) ? new Color3(0, 1, 0) : originalColor
}))

engine.addEntity(sphere)"
/* creating a animator */,"const box = new Entity()
box.addComponent(new Transform({
  position: new Vector3(5, 0, 5)
}))
box.addComponent(new BoxShape())

const animator = new Animator()
box.addComponent(animator)"
/* create water */,"import * as THREE from 'three';

// Create a new mesh and material for the water surface
const waterMesh = new THREE.Mesh(
  new THREE.PlaneGeometry(1000, 1000),
  new THREE.MeshBasicMaterial({ color: 0x0077be, transparent: true, opacity: 0.6 })
);

// Rotate the mesh to make it flat
waterMesh.rotation.x = -Math.PI / 2;"
/* adding screen space UI */,"// Create screenspace component
const canvas = new UICanvas()

// Create a textShape component, setting the canvas as parent
const text = new UIText(canvas)
text.value = ""Hello world!"""
/* positioning for screen space UI */,"const canvas = new UICanvas()

const message = new UIText(canvas)
message.value = ""Close UI""
message.fontSize = 15
message.width = 120
message.height = 30
message.vAlign = ""bottom""
message.positionX = -80"
/* create lamp from gltf */,"const lamp = new Entity()
lamp.addComponent(new GLTFShape('models/Lamp.gltf'))
lamp.addComponent(
  new Transform({
    position: new Vector3(12, 0, 10),
    rotation: Quaternion.Euler(0, 180, 0),
    scale: new Vector3(0.4, 0.4, 0.4),
  })
)
engine.addEntity(lamp)
"
/* create capsule */,"const capsule = new Entity()
capsule.addComponentOrReplace(new Transform({
  position: new Vector3(1, 2, 3)
}))
capsule.addComponentOrReplace(new CapsuleShape())
engine.addEntity(capsule)"
/* parent elements for organization */,"const canvas = new UICanvas()

const inventoryContainer = new UIContainerStack(canvas)
inventoryContainer.adaptWidth = true
inventoryContainer.width = ""40%""
inventoryContainer.positionY = 100
inventoryContainer.positionX = 10
inventoryContainer.color = Color4.White()
inventoryContainer.hAlign = ""left""
inventoryContainer.vAlign = ""top""
inventoryContainer.stackOrientation = UIStackOrientation.VERTICAL"
/* adding transparency to screen space UI */,"const canvas = new UICanvas()

const rect = new UIContainerRect(canvas)
rect.width = ""100%""
rect.height = ""100%""
rect.color = Color4.Blue()
rect.opacity = 0.5"
/* color to text in screen space */,"const canvas = new UICanvas()

const myText = new UIText(canvas)
myText.value = ""Hello""
myText.font = new Font(Fonts.SansSerif)
myText.fontSize = 20
myText.positionX = ""15px""
myText.color = Color4.Blue()"
/* shooting range game manager */,"import * as utils from '@dcl/ecs-scene-utils'

export class ShootingRangeGameManager {
  private score = 0
  private timeLeft = 60
  private timerEntity: Timer
  private scoreEntity: Score
  private leaderboardEntity: Leaderboard
  private player: Camera

  constructor(player: Camera) {
    this.player = player
    const timerModel = new GLTFShape('models/timer.glb')
    const scoreModel = new GLTFShape('models/score.glb')
    const leaderboardModel = new GLTFShape('models/leaderboard.glb')
    this.timerEntity = new Timer(timerModel, new Vector3(0, 2, -10), Quaternion.Identity, new Vector3(0.5, 0.5, 0.5))
    this.scoreEntity = new Score(scoreModel, new Vector3(-10, 2, 0), Quaternion.Identity, new Vector3(0.5, 0.5, 0.5))
    this.leaderboardEntity = new Leaderboard(leaderboardModel, new Vector3(10,"
/* font style to text in screen space */,"const canvas = new UICanvas()

const myText = new UIText(canvas)
myText.value = ""Hello""
myText.font = new Font(Fonts.SansSerif)
myText.fontSize = 20
myText.positionX = ""15px""
myText.color = Color4.Blue()
const sfFont = new Font(Fonts.SansSerif)

myText.font = sfFont

const myText2 = new UIText(canvas)
myText2.value = ""World""
myText2.font = sfFont"
/* multiline text in screen space */,"const canvas = new UICanvas()

const myText = new UIText(canvas)
myText.value =
  ""Hello World, this message is quite long and won't fit in a single line. I hope that's not a problem.""
myText.fontSize = 20
myText.adaptWidth = false
myText.textWrapping = true
myText.width = 100"
/* multiline text with line break */,"// create new canvas to have the text
const canvas = new UICanvas()

// create a new text element
const myText = new UIText(canvas)

// assign value to the text with line breaks
myText.value =
  ""Hello World,\nthis message is quite long and won't fit in a single line.\nI hope that's not a problem.""
myText.fontSize = 20"
/*Pulling in images from an atlas image */,"// set texture image
let imageAtlas = ""images/UI-atlas.png""
let imageTexture = new Texture(imageAtlas)

// create a new canvas
const canvas = new UICanvas()

/*
The UIImage component has the following fields to crop a sub-section of the original image:

sourceTop: the y coordinate, in pixels, of the top of the selection
sourceLeft: the x coordinate, in pixels, of the left side of the selection.
sourceWidth: the width, in pixels, of the selected area
sourceHeight: the height, in pixels, of the selected area
*/


const playButton = new UIImage(canvas, imageTexture)
playButton.sourceLeft = 26
playButton.sourceTop = 128
playButton.sourceWidth = 128
playButton.sourceHeight = 128

const startButton = new UIImage(canvas, imageTexture)
startButton.sourceLeft = 183
startButton.sourceTop = 128
startButton.sourceWidth = 128
startButton.sourceHeight = 128

const exitButton = new UIImage(canvas, imageTexture)
exitButton.sourceLeft = 346
exitButton.sourceTop = 128
exitButton.sourceWidth = 128
exitButton.sourceHeight = 128

const expandButton = new UIImage(canvas, imageTexture)
expandButton.sourceLeft = 496
expandButton.sourceTop = 128
expandButton.sourceWidth = 128
expandButton.sourceHeight = 128"
/* clickable UI elements */,"const canvas = new UICanvas()

const clickableImage = new UIImage(canvas, new Texture(""icon.png""))
clickableImage.name = ""clickable-image""
clickableImage.width = ""92px""
clickableImage.height = ""91px""
clickableImage.sourceWidth = 92
clickableImage.sourceHeight = 91
clickableImage.isPointerBlocker = true
clickableImage.onClick = new OnPointerDown(() => {
  // DO SOMETHING
})"
/* input boxes */,"// create canvas
const canvas = new UICanvas()

/*
Input boxes can be added to the UI to provide a place to type 
in text. You add a text box with an UIInputText component. 
Players must first click on this box before they can write into it.
*/
const textInput = new UIInputText(canvas)
textInput.width = ""80%""
textInput.height = ""25px""
textInput.vAlign = ""bottom""
textInput.hAlign = ""center""
textInput.fontSize = 10
textInput.placeholder = ""Write message here""
textInput.positionY = ""200px""
textInput.isPointerBlocker = true

textInput.onTextSubmit = new OnTextSubmit((x) => {
  const text = new UIText(textInput)
  text.value = ""<USER-ID> "" + x.text
  text.width = ""100%""
  text.height = ""20px""
  text.vAlign = ""top""
  text.hAlign = ""left""
})"
/* open the UI */,"const canvas = new UICanvas()

const uiTrigger = new Entity()

const transform = new Transform({
  position: new Vector3(5, 1, 5),
  scale: new Vector3(0.3, 0.3, 0.3),
})
uiTrigger.addComponent(transform)

/*
Set the visible property of the main UICanvas component that wraps 
the UI to true or false.

If the UI is clickable, or has clickable parts, you should also set 
the isPointerBlocker property to true or false, so that the player can 
freely click in the world space when the UI is not on the way.
*/
uiTrigger.addComponent(
  new OnPointerDown(() => {
    canvas.visible = true
    canvas.isPointerBlocker = true
  })
)

uiTrigger.addComponent(new BoxShape())
engine.addEntity(uiTrigger)"
/* clost the UI */,"const canvas = new UICanvas()

/*  to close the UI automatically when a specific event occurs, 
for example when a new match of a game starts.

set the visible property of the main UIScreenSpace component that wraps the UI to false.
*/
const close = new UIImage(canvas, new Texture(""icon.png""))
close.name = ""clickable-image""
close.width = ""120px""
close.height = ""30px""
close.sourceWidth = 92
close.sourceHeight = 91
close.vAlign = ""bottom""
close.isPointerBlocker = true
close.onClick = new OnPointerDown(() => {
  log(""clicked on the close image"")
  canvas.visible = false
  canvas.isPointerBlocker = false
})"
/* add a timer to the scene */,"function createTimer() {
  const timer = new Entity('timer')
  engine.addEntity(timer)
  return timer
}

const timer = createTimer();

//Add a Timer component to the timer Entity
const timerComponent = new Timer(10, () => {
  log(""Timer expired!"")
})
timer.addComponent(timerComponent)"
/* create emote */,"const canvas = new UICanvas()

const uiTrigger = new Entity()

const transform = new Transform({
  position: new Vector3(5, 1, 5),
  scale: new Vector3(0.3, 0.3, 0.3),
})
uiTrigger.addComponent(transform)

/*
Set the visible property of the main UICanvas component that wraps 
the UI to true or false.

If the UI is clickable, or has clickable parts, you should also set 
the isPointerBlocker property to true or false, so that the player can 
freely click in the world space when the UI is not on the way.
*/
uiTrigger.addComponent(
  new OnPointerDown(() => {
    canvas.visible = true
    canvas.isPointerBlocker = true
  })
)

uiTrigger.addComponent(new BoxShape())
engine.addEntity(uiTrigger)"
/* setting parent entity */,"// Create entities
const parentEntity = new Entity()
engine.addEntity(parentEntity)

const childEntity = new Entity()

// Set parent
childEntity.setParent(parentEntity)"
/* configure component and add it to an entity */,"// Create entity
const box = new Entity()
engine.addEntity(box)

// Create component
const myMaterial = new Material()

// Configure component
myMaterial.albedoColor = Color3.Red()

// Add component
box.addComponent(myMaterial)"
/* configure component inside an entity */,"// Create entity
const box = new Entity()
engine.addEntity(box)

// Create and add component
box.addComponent(new Material())

// Configure component
box.getComponent(Material).albedoColor = Color3.Red()"
/* access a component from an entity */,"// Create entity and component
const box = new Entity()

// Create and add component
box.addComponent(new Transform())

// Using get
let transform = box.getComponent(Transform)

// Edit values in the component
transform.position = new Vector3(5, 0, 5)"
/* modifies transform component */,"// Create entity and component
const box = new Entity()

// Create and add component
box.addComponent(new Transform())

// Using get
let transform = box.getComponent(Transform)

// Edit values in the component
transform.position = new Vector3(5, 0, 5)

box.getComponent(Transform).scale.x = Math.random() * 10"
/* create a bookshelf entity */,"const bookshelf = new Entity()
bookshelf.addComponent(new GLTFShape('models/Bookshelf.gltf'))
bookshelf.addComponent(
  new Transform({
    position: new Vector3(8, 0, 7),
    rotation: Quaternion.Euler(0, 270, 0),
    scale: new Vector3(0.8, 0.8, 0.8),
  })
)
engine.addEntity(bookshelf)
"
/* checking if the component does have an enitity */,"// Create entity and component
const box = new Entity()

// Create and add component
box.addComponent(new Transform())

// Using get
let transform = box.getComponent(Transform)

// Edit values in the component
transform.position = new Vector3(5, 0, 5)

box.getComponent(Transform).scale.x = Math.random() * 10

//  getComponentOrNull
let scale = box.getComponentOrNull(Transform)

// getComponentOrCreate
let scale = box.getComponentOrCreate(Transform)"
/* create spawner */,"// Define spawner singleton object
const spawner = {
  MAX_POOL_SIZE: 20,
  pool: [] as Entity[],

  spawnEntity() {
    // Get an entity from the pool
    const ent = spawner.getEntityFromPool()

    if (!ent) return

    // Add a transform component to the entity
    let t = ent.getComponentOrCreate(Transform)
    t.scale.setAll(0.5)
    t.position.set(5, 0, 5)

    //add entity to engine
    engine.addEntity(ent)
  },

  getEntityFromPool(): Entity | null {
    // Check if an existing entity can be used
    for (let i = 0; i < spawner.pool.length; i++) {
      if (!spawner.pool[i].alive) {
        return spawner.pool[i]
      }
    }
    // If none of the existing are available, create a new one, unless the maximum pool size is reached
    if (spawner.pool.length < spawner.MAX_POOL_SIZE) {
      const instance = new Entity()
      spawner.pool.push(instance)
      return instance
    }
    return null
  },
}

spawner.spawnEntity()"
/* define custom component */,"@Component(""wheelSpin"")
export class WheelSpin {
  spinning: boolean
  speed: number
  constructor(spinning: boolean, speed: number) {
    this.spinning = spinning
    this.speed = speed
  }
}"
/* create the custom component */,"@Component(""wheelSpin"")
export class WheelSpin {
  spinning: boolean
  speed: number
  constructor(spinning: boolean, speed: number) {
    this.spinning = spinning
    this.speed = speed
  }
}

// Create entity
const wheel = new Entity()

// Create instance of component and set its values
wheel.addComponent(new WheelSpin(true, 10))"
/* tetrahedron */,"const tetrahedron = new Entity()
tetrahedron.addComponentOrReplace(new Transform({
  position: new Vector3(2, 3, 4)
}))
tetrahedron.addComponentOrReplace(new TetrahedronShape())
engine.addEntity(tetrahedron)"
/* add skybox to a scene */,"function createSkybox() {
  const skybox = new Entity('skybox')
  engine.addEntity(skybox)
  return skybox
}

const skybox = createSkybox();

//Add a SkyBox component to the skybox Entity
const skyboxComponent = new SkyBox()
skybox.addComponent(skyboxComponent)"
/* setting default values to custom components */,"@Component(""wheelSpin"")
export class WheelSpin {
  spinning: boolean
  speed: number
  constructor(spinning : boolean = false, speed: number = 3) {
    this.spinning = spinning
    this.speed = speed
  }
}"
/* interchangable components */,"@Component(""animal"")
export class Dog {
}

@Component(""animal"")
export class Cat {
}"
/* basic system declaration */,"
const myEntityGroup = engine.getComponentGroup(Transform)
// Define the system
export class MoveSystem implements ISystem {
  // This function is executed on every frame
  update() {
    // Iterate over the entities in an component group
    for (let entity of myEntityGroup.entities) {
      let transform = entity.getComponent(Transform)
      transform.translate(() => Vector3.Forward)
    }
  }
}

// Add system to engine
engine.addSystem(new MoveSystem())"
/* loop over a component group */,"// Create component group
const movableEntities = engine.getComponentGroup(Transform)

// Create system
export class PhysicsSystem implements ISystem {
  update(dt: number) {
    // Iterate over component group
    for (let entity of movableEntities.entities) {
      // Calculate effect of physics
    }
  }
}"
/* access entities in a component group */,"const myGroup = engine.getComponentGroup(Transform)

for (let entity of myGroup.entities) {
  log(entity.uuid)
}"
/* using billboard entities */,"const myGroup = engine.getComponentGroup(Billboard)

for (let entity of myGroup.entities) {
  addLabel(entity as Entity)
}

function addLabel(entity: Entity) {
  let label = new Entity()
  label.setParent(entity)
  label.addComponent(
    new Transform({
      position: new Vector3(0, 1, 0),
      scale: new Vector3(0.5, 0.5, 0.5),
    })
  )
  label.addComponent(new TextShape(entity.uuid))
}"
/* removing entities */,"
const myGroup = engine.getComponentGroup(Billboard)
while (myGroup.entities.length) {
  engine.removeEntity(myGroup.entities[0])
}"
/* setting enitity position */,"// Create a new entity
const ball = new Entity()

// Add a transform component to the entity
ball.addComponent(new Transform())
ball.getComponent(Transform).position.set(5, 1, 5)
ball.getComponent(Transform).scale.set(2, 2, 2)"
/* initial values for transform enitity */,"
// Create a new entity
const myEntity = new Entity()

myEntity.addComponent(
  new Transform({
    position: new Vector3(5, 1, 5),
    rotation: new Quaternion(0, 0, 0, 0),
    scale: new Vector3(2, 2, 2),
  })
)"
/* using position in transforming enitity */,"// Create transform with a predefined position
let myTransform = new Transform({ position: new Vector3(1, 0, 1) })

// Set each axis individually
myTransform.position.x = 3
myTransform.position.y = 1
myTransform.position.z = 3

// Set the position with three numbers (x, y, z)
myTransform.position.set(3, 1, 3)

// Set the position with an object
myTransform.position = new Vector3(5, 1, 5)"
/* octahedron */,"const octahedron = new Entity()
octahedron.addComponentOrReplace(new Transform({
  position: new Vector3(3, 4, 5)
}))
octahedron.addComponentOrReplace(new OctahedronShape())
engine.addEntity(octahedron)"
/* rotating enitity */,"// Create transform with a predefined rotation in Quaternions
let myTransform = new Transform({ rotation: new Quaternion(0, 0, 0, 1) })

// Set rotation with four numbers (x, y, z, w)
myTransform.rotation.set(0, 0, 1, 0)

// Set rotation with a quaternion
myTransform.rotation = new Quaternion(1, 0, 0, 0)"
/* rotating using Eulers */,"// Create transform with a predefined rotation in Euler angles
let myTransform = new Transform({ rotation: Quaternion.Euler(0, 90, 0) })

// Use the .setEuler() function
myTransform.rotation.setEuler(0, 90, 180)

// Set the `eulerAngles` field
myTransform.rotation.eulerAngles = new Vector3(0, 90, 0)"
/* have enitity face the player */,"let box = new Entity()
box.addComponent(new BoxShape())
box.addComponent(
  new Transform({
    position: new Vector3(5, 1, 5),
  })
)
box.addComponent(new Billboard())
engine.addEntity(box)"
/* enitity face coordinates */,"// Create a transform
let myTransform = new Transform()

// Rotate to face the coordinates (4, 1, 2)
myTransform.lookAt(new Vector3(4, 1, 2))"
/* scale an entity */,"// Create a transform with a predefined scale
let myTransform = new Transform({ scale: new Vector3(2, 2, 2) })

// Set each dimension individually
myTransform.scale.x = 1
myTransform.scale.y = 5
myTransform.scale.z = 1

// Set the whole scale with one expression  (x, y, z)
myTransform.scale.set(1, 5, 1)

// Set the scale with a single number to maintain proportions
myTransform.scale.setAll(2)

// Set the scale with an object
myTransform.scale = new Vector3(1, 1, 1.5)"
/* inheritransformation from parents */ ,"// Create entities
const parentEntity = new Entity()
const childEntity = new Entity()

// Set one as the parent of the other
childEntity.setParent(parentEntity)

// Create a transform for the parent
let parentTransform = new Transform({
  position: new Vector3(3, 1, 1),
  scale: new Vector3(0.5, 0.5, 0.5),
})

parentEntity.addComponent(parentTransform)

// Create a transform for the child
let childTransform = new Transform({
  position: new Vector3(0, 1, 0),
})

childEntity.addComponent(childTransform)

// Add entities to the engine
engine.addEntity(parentEntity)"
/* attach entity to an avatar */,"
const childEntity = new Entity()

childEntity.addComponentOrReplace(
  new AttachToAvatar({
    avatarId: '0xAAAAAAAAAAAAAAAAA',
    anchorPointId: AttachToAvatarAnchorPointId.NameTag,
  })
)"
/* create new eth account */,"import { createAccount } from ""eth-connect""
import * as EthereumController from ""@decentraland/EthereumController""

let eth = EthereumController

function createNewAccount() {
  executeTask(async () => {
    const account = await createAccount(eth)
    log(`New account created: ${account.address}`)
  })
}

createNewAccount()
"
/* get gas price for current eth network */,"import { getGasPrice } from ""eth-connect""
import * as EthereumController from ""@decentraland/EthereumController""

let eth = EthereumController

function getGasPrice() {
  executeTask(async () => {
    const gasPrice = await getGasPrice(eth)
    log(`Current gas price: ${gasPrice.toString()}`)
  })
}

getGasPrice()
"
/* define position to avatar */,"let parent = new Entity()

parent.addComponentOrReplace(
  new AttachToAvatar({
    avatarId: '0xAAAAAAAAAAAAAAAAA',
    anchorPointId: AttachToAvatarAnchorPointId.NameTag,
  })
)
engine.addEntity(parent)

let child = new Entity()
child.addComponent(new ConeShape())
child.addComponent(
  new Transform({
    rotation: Quaternion.Euler(0, 0, 180),
    scale: new Vector3(0.2, 0.2, 0.2),
    position: new Vector3(0, 0.4, 0),
  })
)
child.setParent(parent)"
/* getting the avatar id */,"import { getUserData } from ""@decentraland/Identity""

executeTask(async () => {
  let data = await getUserData()
  log(data!.userId)
})"
/* fetching nearby players id */,"import { getConnectedPlayers } from ""@decentraland/Players""

executeTask(async () => {
  let players = await getConnectedPlayers()
  players.forEach((player) => {
    log(""player is nearby: "", player.userId)
  })
})"
/* attaching entity to players */,"const followTheCamera = new Entity()
followTheCamera.addComponent(new BoxShape())
followTheCamera.addComponent(
  new Transform({
    position: new Vector3(0, 0.5, 3),
  })
)
engine.addEntity(followTheCamera)
followTheCamera.setParent(Attachable.FIRST_PERSON_CAMERA)"
/* following the avatar */,"const followAvatar = new Entity()
followAvatar.addComponent(new BoxShape())
followAvatar.addComponent(
  new Transform({
    position: new Vector3(0, 0.5, 3),
  })
)
engine.addEntity(followAvatar)
followAvatar.setParent(Attachable.AVATAR)"
/* defining collision */,"const myEntity = new Entity()
let box = new BoxShape()
box.withCollisions = true
myEntity.addComponent(box)"
/* blocking player interactions */,"const myEntity = new Entity()
let box = new BoxShape()
box.isPointerBlocker = false
myEntity.addComponent(box)"
/* making enitity invisible */,"const myEntity = new Entity()
myEntity.addComponent(new BoxShape())
myEntity.getComponent(BoxShape).visible = false"
/* make an entity bounce up and down */,"let myEntity = new Entity()
myEntity.addComponent(new BoxShape())

let startY = 0
let amplitude = 1
let frequency = 1

engine.addSystem(new UpdateSystem(() => {
  let time = Time.time
  let yOffset = startY + amplitude * Math.sin(time * frequency)
  myEntity.getComponent(Transform).position.set(0, yOffset, 0)
}))"
/* rotate an entity around its own axis */,"let myEntity = new Entity()
myEntity.addComponent(new BoxShape())

let rotationSpeed = 0.1

engine.addSystem(new UpdateSystem(() => {
  myEntity.getComponent(Transform).rotate(Vector3.Up(), Time.deltaTime * rotationSpeed)
}))
"
/* move an entity in a circular path */,"let myEntity = new Entity()
myEntity.addComponent(new BoxShape())

let centerPosition = new Vector3(0, 0, 0)
let radius = 5
let angle = 0
let speed = 0.1

engine.addSystem(new UpdateSystem(() => {
  angle += speed
  let x = centerPosition.x + radius * Math.sin(angle)
  let z = centerPosition.z + radius * Math.cos(angle)
  myEntity.getComponent(Transform).position.set(x, 0, z)
}))
"
/* set the position of an entity to be the same as another entity's position */,"let entity1 = new Entity()
let entity2 = new Entity()
entity1.addComponent(new Transform({ position: new Vector3(1, 0, 1) }))
entity2.addComponent(new Transform())
entity2.getComponent(Transform).position = entity1.getComponent(Transform).position"
/* reuse shapes */,"// Create shape component
const house = new GLTFShape(""models/House.gltf"")

// Create entities
const myEntity = new Entity()
const mySecondEntity = new Entity()
const myThirdEntity = new Entity()

// Assign shape component to entities
myEntity.addComponent(house)
mySecondEntity.addComponent(house)
myThirdEntity.addComponent(house)"
/* create an apply material */,"//Create entity and assign shape
const myEntity = new Entity()
myEntity.addComponent(new BoxShape())

//Create material and configure its fields
const myMaterial = new Material()
myMaterial.albedoColor = Color3.Blue()
myMaterial.metallic = 0.9
myMaterial.roughness = 0.1

//Assign the material to the entity
myEntity.addComponent(myMaterial)"
/* predetermined colors */,"let red = Color3.Red()

let green = Color3.Green()

let blue = Color3.Blue()

let black = Color3.Black()

let white = Color3.White()

let purple = Color3.Purple()

let magenta = Color3.Magenta()

let yellow = Color3.Yellow()

let gray = Color3.Gray()

let teal = Color3.Teal()"
/* using texture */,"//Create entity and assign shape
const myEntity = new Entity()
myEntity.addComponent(new BoxShape())

//Create texture
const myTexture = new Texture(""materials/wood.png"")

//Create a material
const myMaterial = new Material()
myMaterial.albedoTexture = myTexture

//Assign the material to the entity
myEntity.addComponent(myMaterial)"
"/* This code uses fetch and promises to send a GET request to callUrl and logs the response in JSON format. If the request fails, it logs ""failed to reach URL"". Wrapped in the asynchronous eTask func. */","executeTask(async () => {
  try {
    let response = await fetch(callUrl)
    let json = await response.json()
    log(json)
  } catch {
    log(""failed to reach URL"")
  }
})"
"/* makes a POST request to the URL stored in the callUrl variable with a JSON body stored in myBody. If the request is successful, it logs the response as JSON, otherwise it logs ""failed to reach URL"".  */","executeTask(async () => {
  try {
    let response = await fetch(callUrl, {
      headers: { ""Content-Type"": ""application/json"" },
      method: ""POST"",
      body: JSON.stringify(myBody),
    })
    let json = await response.json()
    log(json)
  } catch {
    log(""failed to reach URL"")
  }
})"
"/* HTTP POST request to a URL, with header and JSON string as the body. Request sent with ""signedFetch"" function, adds a signature to the request for authenticity. If response is successful, log JSON. */","executeTask(async () => {
  try {
    let response = await signedFetch(callUrl, {
      headers: { ""Content-Type"": ""application/json"" },
      method: ""POST"",
      body: JSON.stringify(myBody),
    })

    if (!response.text) {
      throw new Error(""Invalid response"")
    }

    let json = await JSON.parse(response.text)

    log(""Response received: "", json)
  } catch {
    log(""failed to reach URL"")
  }
})"
"/* use WebSockets to send and receive data from a secure server using the protocol ""wss"". */","var socket = new WebSocket(""url"")

socket.onmessage = function (event) {
  log(""WebSocket message received:"", event)
}"
/* Develop a message bus object to manage the functions required for transmitting and receiving messages between players. */,const sceneMessageBus = new MessageBus()
/* Use the .emit function of the message bus to broadcast a message to all other players in the scene. */,"const sceneMessageBus = new MessageBus()

box1.AddComponent(
  new OnPointerDown((e) => {
    sceneMessageBus.emit(""box1Clicked"", {})
  })
)"
"/* Each message can have a payload, which is of the Object type, and can consist of any desired information to be transmitted. */","const sceneMessageBus = new MessageBus()

let spawnPos = new Vector3(5, 0, 5)

sceneMessageBus.emit(""spawn"", { position: spawnPos })"
"/* To process messages from other players in the scene, use the .on function. You specify a string for the message type and define a function to run each time a matching message is received. */","const sceneMessageBus = new MessageBus()

sceneMessageBus.on(""spawn"", (info: NewBoxPosition) => {
  let newCube = new Entity()
  let transform = new Transform()
  transform.position.set(info.position.x, info.position.y, info.position.z)
  newCube.addComponent(transform)
  engine.addEntity(newCube)
})"
"/* When main cube is clicked, a new message is sent through the message bus which generates a cube in random location. Message contains position of new cube, ensuring all players see the same placement. */","/// --- Spawner function ---

function spawnCube(x: number, y: number, z: number) {
  // create the entity
  const cube = new Entity()

  // add a transform to the entity
  cube.addComponent(new Transform({ position: new Vector3(x, y, z) }))

  // add a shape to the entity
  cube.addComponent(new BoxShape())

  // add the entity to the engine
  engine.addEntity(cube)

  return cube
}

/// --- Create message bus ---
const sceneMessageBus = new MessageBus()

/// --- Define a custom type to pass in messages ---
type NewBoxPosition = {
  position: ReadOnlyVector3
}

/// --- Call spawner function ---
const cube = spawnCube(8, 1, 8)

/// --- Emit messages ---
cube.addComponent(
  new OnPointerDown(() => {
    const action: NewBoxPosition = {
      position: {
        x: Math.random() * 8 + 1,
        y: Math.random() * 8,
        z: Math.random() * 8 + 1,
      },
    }

    sceneMessageBus.emit(""spawn"", action)
  })
)

/// --- Receive messages ---
sceneMessageBus.on(""spawn"", (info: NewBoxPosition) => {
  cube.getComponent(Transform).scale.z *= 1.1
  cube.getComponent(Transform).scale.x *= 0.9

  spawnCube(info.position.x, info.position.y, info.position.z)
})"
/* import Ethereum controller library */,"import * as EthereumController from ""@decentraland/EthereumController"""
/* Find a player's Ethereum public key using the getUserAccount() function from EthereumController. */,"
import { getUserAccount } from ""@decentraland/EthereumController""

executeTask(async () => {
  try {
    const address = await getUserAccount()
    log(address)
  } catch (error: any) {
    log(error.toString())
  }
})"
/* Wrap the function in an async() function to track provided addresses with ease. Discover more about async functions. */,"import { getUserAccount } from ""@decentraland/EthereumController""

let registeredAddresses: String[] = []

executeTask(async () => {
  try {
    const address = await getUserAccount()
    let lowerCaseAddress = address.toLowerCase()
    for (let i = 0; i < registeredAddresses.length; i++) {
      if (lowerCaseAddress == registeredAddresses[i]) {
        log(""already registered"")
      } else {
        registeredAddresses.push(lowerCaseAddress)
      }
    }
  } catch (error: any) {
    log(error.toString())
  }
})"
"/* A player can securely sign a message with their Ethereum private key which can be verified using their public key. No gas fees are required, but a pop-up asking for consent will appear. */","// DCL Signed message
Attacker: 10
Defender: 123
Timestamp: 1512345678"
/* Convert message string to object using convertMessageToObject() then sign with signMessage() to allow player signing. */,"import * as EthereumController from ""@decentraland/EthereumController""

const messageToSign = `# DCL Signed message
Attacker: 10
Defender: 123
Timestamp: 1512345678`

let eth = EthereumController

executeTask(async () => {
  const convertedMessage = await eth.convertMessageToObject(messageToSign)
  const { message, signature } = await eth.signMessage(convertedMessage)
  log({ message, signature })
})"
/* Verify signed messages using toHex() from eth-connect. Convert message to easily compare with toHex(). Import eth-connect library for instructions. */,"import { toHex } from ""eth-connect""
import * as EthereumController from ""@decentraland/EthereumController""

const messageToSign = `# DCL Signed message
Attacker: 10
Defender: 123
Timestamp: 1512345678`

let eth = EthereumController

function signMessage(msg: string) {
  executeTask(async () => {
    const convertedMessage = await eth.convertMessageToObject(msg)
    const { message, signature } = await eth.signMessage(convertedMessage)
    log({ message, signature })

    const originalMessageHex = await toHex(msg)
    const sentMessageHex = await toHex(message)
    const isEqual = sentMessageHex === originalMessageHex
    log(""Is the message correct?"", isEqual)
  })
}

signMessage(messageToSign)"
"/* The requirePayment() function asks players to agree to pay a set amount to a designated Ethereum wallet. Payments must be accepted manually, never automatically from player's scene actions. */","import * as EthereumController from ""@decentraland/EthereumController""

let eth = EthereumController
eth.requirePayment(receivingAddress, amount, currency)"
"/* The requirePayment() function only requests a transaction, it doesn't guarantee it will be confirmed. Factors such as low gas price can prevent the transaction from being completed. */","import * as EthereumController from ""@decentraland/EthereumController""

let eth = EthereumController

const myWallet = â€˜0x0f2D284012Ee6Fc4e792CFf...â€™
const enterPrice = 0.05

function payment(){
  executeTask(async () => {
    try {
      await eth.requirePayment(myWallet, enterPrice, 'ETH')
      openDoor()
    } catch {
      log(""failed process payment"")
    }
  })
}

const button = new Entity()
button.addComponent(new BoxShape())
button.addComponent(new OnClick( e => {
    payment()
  }))
engine.addEntity(button)"
/* Use sendAsync() to send messages over the RPC protocol. */,"import * as EthereumController from ""@decentraland/EthereumController""

// send a message
await eth!.sendAsync(myMessage)"
"/* Make functions run on separate thread with ""async"" marking. */","// declare function
async function myAsyncTask() {
  // run async steps
}

// call function
myAsyncTask()

// rest of the code keeps being executed"
/* new player entity */,"let myPlayer = new Entity()
myPlayer.addComponent(new BoxShape())
myPlayer.addComponent(new Transform({ position: new Vector3(0, 0, 0) }))
myPlayer.addComponent(new Health(100))
myPlayer.addComponent(new PlayerController())"
/* make an entity move towards a target over time */,"let myEntity = new Entity()
myEntity.addComponent(new BoxShape())

let startPosition = new Vector3(0, 0, 0)
let targetPosition = new Vector3(5, 0, 5)
let speed = 1

let direction = targetPosition.subtract(startPosition).normalize()
let distance = targetPosition.subtract(startPosition).length()

engine.addSystem(new UpdateSystem(() => {
  let currentPosition = myEntity.getComponent(Transform).position
  let step = Time.deltaTime * speed
  if (step < distance) {
    let newPosition = currentPosition.add(direction.scale(step))
    myEntity.getComponent(Transform).position = newPosition
  } else {
    myEntity.getComponent(Transform).position = targetPosition
  }
}))
"
/* Estimate gas required for the transaction */,"import { estimateGas } from ""eth-connect""
import * as EthereumController from ""@decentraland/EthereumController""

let eth = EthereumController

function estimateGas(toAddress: string, amount: number) {
  executeTask(async () => {
    const gas = await estimateGas(eth, {
      to: toAddress,
      value: amount,
    })
    log(`Gas estimate for transaction: ${gas.toString()}`)
  })
}

estimateGas(""0xabcdef1234567890abcdef1234567890abcdef12"", 1)"
"/* The function executeTask runs a lambda function asynchronously, in a different thread from the main thread of the scene. */","// declare function
async function myAsyncTask() {
  // run async steps
}

executeTask(async () => {
  let data = await myAsyncTask()
  log(data)
})

// rest of the code keeps being executed"
"/* Script to specify the starting position of your ray. Provides values for the x, y, and z components of the position, separated by spaces. */","const originPos = new Vector3(2, 1, 4);
const direction = new Vector3(0, 1, 1);

const ray: Ray = {
  origin: originPos,
  direction: direction,
  distance: 10,
};"
"/* Script to specify the target position of the Raycast. Please provide values for the x, y, and z components of the position, separated by spaces */","let physicsCast = PhysicsCast.instance

let originPos = new Vector3(1, 2, 1)
let targetPos = new Vector3(1, 2, 3)

let rayFromPoints = physicsCast.getRayFromPositions(originPos, targetPos)"
,"const ray = physicsCast.getRayFromPositions(origin, target);
physicsCast.hitAll(
  ray,
  (e) => {
    for (let entityHit of e.entities) {
    log(entityHit.entity.entityId)
    }
  },
  0
)"
/* create bed entity from gltf */,"const bed = new Entity()
bed.addComponent(new GLTFShape('models/Bed.gltf'))
bed.addComponent(
  new Transform({
    position: new Vector3(6, 0, 12),
    rotation: Quaternion.Euler(0, 180, 0),
    scale: new Vector3(0.8, 0.8, 0.8),
  })
)
engine.addEntity(bed)
"
/* Script to run a raycast in Decentraland and apply a material to the first entity hit. */,"let physicsCast = PhysicsCast.instance

let originPos = new Vector3(2, 1, 4)
let direction = new Vector3(0, 1, 1)

let ray: Ray = {
  origin: originPos,
  direction: direction,
  distance: 10,
}

physicsCast.hitFirst(
  ray,
  (e) => {
    if (e.didHit) {
      engine.entities[e.entity.entityId].addComponentOrReplace(Material)
    }
  },
  0
)"
"/* Script to help me with a physics raycast in Decentraland, hitting all entities in my scene and add a specific material to them. */","let physicsCast = PhysicsCast.instance;

let originPos = new Vector3(2, 1, 4);
let direction = new Vector3(0, 1, 1);

let ray = {
  origin: originPos,
  direction: direction,
  distance: 10,
};

physicsCast.hitAll(ray, (results: any) => {
  if (results.length) {
    for (const result of results) {
      engine.entities[result.entity.entityId].addComponentOrReplace(Material);
    }
  }
});"
/* Script for a Decentraland raycasting system that casts two rays and performs an action on the first entity hit for each ray. */,"const Ray1 = { origin: Vector3.Zero(), direction: Vector3.Left(), distance: 10 }
const Ray2 = { origin: Vector3.Zero(), direction: Vector3.Right(), distance: 10 }
let id1: number = 0
let id2: number = 1

class RaycastSystem implements ISystem {
  update(dt: number) {
    PhysicsCast.instance.hitFirst(
      Ray1,
      (e) => {
        // Do stuff
      },
      id1
    )

    PhysicsCast.instance.hitFirst(
      Ray2,
      (e) => {
        // Do stuff
      },
      id2
    )
  }
}

engine.addSystem(new RaycastSystem())"
/* Script for whether a player connects or disconnects from the server */,"onPlayerConnectedObservable.add((player) => {
  log(`A player has entered the game with id: ${player.userId}`)
  })
  
  onPlayerDisconnectedObservable.add((player) => {
  log(`A player has left the game with id: ${player.userId}`)
  })"
/* Script for whether a player enters or exits the scene */,"onEnterSceneObservable.add((player) => {
  log(`player entered the scene: ${player.userId}`)
})

onLeaveSceneObservable.add((player) => {
  log(`A player left the scene: ${player.userId}`)
}) "
"/*Script for limiting the response to events only involving the player's avatar, instead of reacting to other avatars in the vicinity.*/","import { getUserData } from ""@decentraland/Identity"";

async function trackSceneChanges() {
  const myPlayer = await getUserData();
  onEnterSceneObservable.add((player) => {
    log(`player entered scene: ${player.userId}`);
    if (myPlayer?.userId === player.userId) {
      log(""I entered the scene!"");
    }
  });
  onLeaveSceneObservable.add((player) => {
    log(`player left scene: ${player.userId}`);
    if (myPlayer?.userId === player.userId) {
      log(""I left the scene!"");
    }
  });
}

executeTask(trackSceneChanges);"
/* Script for retrieving information about all the players currently present and visible in your scene */,"import { getPlayersInScene } from ""@decentraland/Players""

executeTask(async () => {
  let existingPlayers = await getPlayersInScene()
  existingPlayers.forEach((player) => {
    log(`A player was already present in the scene: ${player.userId}`)
  })
})"
/* Script for creating a listener for a created event when a player changes from 1st to the 3rd person view */,"onCameraModeChangedObservable.add(({ cameraMode }) => {
  log(`The camera mode has been switched to: ${cameraMode}`)
})"
/* Script for creating a listener for a create event for when a player emotes */,"onPlayerExpressionObservable.add(({ expressionId }) => {
  log(`Expression:  ${expressionId}`)
})"
"/* Script that connects to a WebSocket server, listens for incoming messages, and activates a cube entity in response to the messages received. */","import { getCurrentRealm } from '@decentraland/EnvironmentAPI'

let socket: WebSocket

// Function to join the WebSocket server
async function joinSocketsServer() {
  // Fetch the current realm data to separate players in different realms
  let realm = await getCurrentRealm()

  // checks to see if realm is not null
  if (!realm) {
    log(""Error: Failed to retrieve current realm"");
    return;
  }

  log(`You are in the realm: `, realm.displayName)
  
  // Connect to the WebSocket server
  socket = new WebSocket(
    'wss://64-225-45-232.nip.io/broadcast/' + realm.displayName
  )
  
  // Listen for incoming WebSocket messages
  socket.onmessage = function (event) {
    try {
      // Parse the incoming message
      const parsed = JSON.parse(event.data)
      log(parsed)
      
      // Play a sound effect and rotate the cube when a message is received
      playSound(parsed.cube)
      rotateCube(cubes[parsed.cube])
    } catch (error) {
      log(error)
    }
  }
}

// Function to play a sound effect
function playSound(index: number) {
  let source = new Entity()
  source.addComponent(new AudioSource(new AudioClip(`sounds/sound${index}.mp3`)))
  source.getComponent(AudioSource).playOnce()
  engine.addEntity(source)
}

// Function to rotate a cube
function rotateCube(cube: Entity) {
  let transform = cube.getComponent(Transform)
  let rotation = Quaternion.Euler(0, 90, 0)
  transform.rotation.multiply(rotation)
}

// List of all cubes in the scene
let cubes: Entity[] = []

// Create 8 cubes
for (let i = 0; i < 8; i++) {
  let cube = new Entity()
  
  // Add a Transform component to set the position of the cube
  cube.addComponent(
    new Transform({
      position: new Vector3(i * 2 + 1, 1, 4),
    })
  )
  
  // Add a BoxShape component to give the cube a shape
  cube.addComponent(new BoxShape())
  
  // Add an OnPointerDown component to trigger an action when the cube is clicked
  cube.addComponent(
    new OnPointerDown(
      (e: any) => {
        // Send a WebSocket message when the cube is clicked
        socket.send(
          JSON.stringify({
            cube: i,
          })
        )
      },
      { button: ActionButton.POINTER, hoverText: 'Activate' }
    )
  )
  
  engine.addEntity(cube)
  cubes.push(cube)
}

// Create the floor
let floor = new Entity()

// Add a Transform component to set the position of the floor
floor.addComponent(
new Transform({
position: new Vector3(5, 0, 5),
scale: new Vector3(10, 0.1, 10),
})
)

// Add a GLTFShape component to give the floor a shape
floor.addComponent(
new GLTFShape('models/Floor.glb')
)

engine.addEntity(floor)

// Join the WebSocket server when the scene is loaded
joinSocketsServer()"
/* Script that implements a blockchain transaction and display the details of the transaction on the screen. */,"import Web3 from 'web3'

// Connect to Ethereum blockchain
const web3 = new Web3(new Web3.providers.HttpProvider(""https://mainnet.infura.io/v3/YOUR-PROJECT-ID""))

// Contract ABI and address
const contractABI = [{...}]
const contractAddress = '0x...'

// Create instance of contract
const contract = new web3.eth.Contract(contractABI, contractAddress)

// Entity that represents the blockchain interaction
class BlockchainEntity extends Entity {
  // Initialize the entity
  constructor() {
    super()
    this.addComponent(new BlockchainSystem())
  }
}

// System that performs the blockchain interaction
class BlockchainSystem extends System {
  // This function will be called every frame
  update() {
    // Call a contract function to retrieve data
    contract.methods.getData().call((error: any, result: any) => {
      if (!error) {
        log(`Data from blockchain: ${result}`)
      } else {
        error(error)
      }
    })
  }
}

// Create instance of blockchain entity and add it to the engine
const blockchainEntity = new BlockchainEntity()
engine.addEntity(blockchainEntity)"
/* Script for implementing a  land auction smart contract with Ethers. */,"import { Contract, getDefaultProvider } from 'ethers';

// ABI (Application Binary Interface) for the smart contract
const abi = [
  {
    ""inputs"": [],
    ""stateMutability"": ""nonpayable"",
    ""type"": ""constructor""
  },
  {
    ""anonymous"": false,
    ""inputs"": [
      {
        ""indexed"": false,
        ""internalType"": ""address"",
        ""name"": ""bidder"",
        ""type"": ""address""
      },
      {
        ""indexed"": false,
        ""internalType"": ""uint256"",
        ""name"": ""amount"",
        ""type"": ""uint256""
      }
    ],
    ""name"": ""NewBid"",
    ""type"": ""event""
  },
  {
    ""inputs"": [],
    ""name"": ""bid"",
    ""outputs"": [],
    ""stateMutability"": ""payable"",
    ""type"": ""function""
  },
  {
    ""inputs"": [],
    ""name"": ""cancelAuction"",
    ""outputs"": [],
    ""stateMutability"": ""nonpayable"",
    ""type"": ""function""
  },
  {
    ""inputs"": [],
    ""name"": ""closeAuction"",
    ""outputs"": [],
    ""stateMutability"": ""nonpayable"",
    ""type"": ""function""
  },
  {
    ""inputs"": [],
    ""name"": ""getHighestBid"",
    ""outputs"": [
      {
        ""internalType"": ""address"",
        ""name"": """",
        ""type"": ""address""
      },
      {
        ""internalType"": ""uint256"",
        ""name"": """",
        ""type"": ""uint256""
      }
    ],
    ""stateMutability"": ""view"",
    ""type"": ""function""
  },
  {
    ""inputs"": [],
    ""name"": ""getTimeLeft"",
    ""outputs"": [
      {
        ""internalType"": ""uint256"",
        ""name"": """",
        ""type"": ""uint256""
      }
    ],
    ""stateMutability"": ""view"",
    ""type"": ""function""
  },
  {
    ""inputs"": [],
    ""name"": ""withdraw"",
    ""outputs"": [],
    ""stateMutability"": ""nonpayable"",
    ""type"": ""function""
  }
];

// Address of the deployed smart contract on the Ethereum network
const contractAddress = '0x5abfec25f74cd88437631a7731906932776356f9';

// Connect to the Ethereum network using a provider
const provider = getDefaultProvider('rinkeby');

// Create an instance of the smart contract
const contract = new Contract(contractAddress, abi, provider);

async function bid() {
  // Call the 'bid' function of the smart contract
  const tx = await contract.bid();

  // Wait for the transaction to be mined
  await tx.wait();

}"
/* Script to creat a scene with 4x4 color-changing tiles and a dancing character*/,"// Add a new instance of the system to the engine
engine.addSystem(new RotatorSystem())

const colors = [  '#1dccc7',  '#ffce00',  '#9076ff',  '#fe3e3e',  '#3efe94',  '#3d30ec',  '#6699cc'];

@Component('tileFlag')
export class TileFlag {};

@Component('beat')
export class Beat {
  interval = 0.5;
  timer = 0.5;
  
  constructor(interval = 0.5) {
    this.interval = interval;
    this.timer = interval;
  }
}

const tiles = engine.getComponentGroup(TileFlag);

export class ChangeColorSystem implements ISystem {
  update(dt: number) {
    const beat = beatKeeper.getComponent(Beat);
    beat.timer -= dt;
    if (beat.timer < 0) {
      beat.timer = beat.interval;
      for (const tile of tiles.entities) {
        const colorNum = Math.floor(Math.random() * colors.length);
        tile.addComponentOrReplace(tileMaterials[colorNum]);
      }
    }
  }
}

engine.addSystem(new ChangeColorSystem());

const tileMaterials: Material[] = [];
for (let i = 0; i < colors.length; i++) {
  const material = new Material();
  material.albedoColor = Color3.FromHexString(colors[i]);
  tileMaterials.push(material);
}

for (const x of [0, 1, 2, 3]) {
  for (const z of [0, 1, 2, 3]) {
    const tile = new Entity();
    tile.addComponent(new PlaneShape());
    tile.addComponent(
      new Transform({
        position: new Vector3(x * 4 + 2, 0, z * 4 + 2),
        rotation: Quaternion.Euler(90, 0, 0),
        scale: new Vector3(4, 4, 4)
      })
    );
    tile.addComponent(new TileFlag());
    const colorNum = Math.floor(Math.random() * colors.length);
    tile.addComponent(tileMaterials[colorNum]);
    engine.addEntity(tile);
  }
}

const player = new Entity();
player.addComponent(new GLTFShape('models/Trevor.glb'));

const clipDance = new AnimationState('Armature_Idle');
const animator = new Animator();
animator.addClip(clipDance);
player.addComponent(animator);
clipDance.play();

player.addComponent(
  new Transform({
    position: new Vector3(5, 0.1, 5),
    rotation: Quaternion.Euler(0, -90, 0),
    scale: new Vector3(1.5, 1.5, 1.5)
  })
);

const audioClip = new AudioClip('sounds/Vexento.mp3');
audioClip.loop = true;
const audioSource = new AudioSource(audioClip)
player.addComponent(audioSource)

engine.addEntity(player)

// Singleton to keep track of the beat
const beatKeeper = new Entity()
beatKeeper.addComponent(new Beat(0.5))

audioSource.playing = true"
"/* Script that sets up a base grass model, adds a secondary avatar, creates an area to hide all other avatars, and checks if the player is moving, this script requires another avatar file to pull from.*/","import * as utils from '@dcl/ecs-scene-utils';
import { SecondPlayer } from './secondplayer';

// Base
const base = new Entity();
base.addComponent(new GLTFShape('models/baseGrass.glb'));
engine.addEntity(base);

// Arissa
const playerInstance = new SecondPlayer(
new GLTFShape('models/arissa.glb'),
new Transform({
position: new Vector3(0, 0.05, -0.1),
scale: new Vector3(0, 0, 0)
})
);
playerInstance.setParent(Attachable.AVATAR);

// Hide Avatars Entity
const hideAvatarArea = new Entity();
hideAvatarArea.addComponent(
new AvatarModifierArea({
area: { box: new Vector3(16, 4, 11) },
modifiers: [AvatarModifiers.HIDE_AVATARS]
})
);
hideAvatarArea.addComponent(
new Transform({ position: new Vector3(8, 2, 10.5) })
);
engine.addEntity(hideAvatarArea);

// Trigger to Show Arissa
hideAvatarArea.addComponent(
new utils.TriggerComponent(
new utils.TriggerBoxShape(new Vector3(16, 4, 11), Vector3.Zero()),
{
onCameraEnter: () => {
playerInstance.getComponent(Transform).scale.setAll(1);
},
onCameraExit: () => {
playerInstance.getComponent(Transform).scale.setAll(0);
}
}
)
);

// System to Check if Player is Moving
const currentPos = new Vector3();
class PlayerMovementCheckSystem implements ISystem {
update() {
if (currentPos.equals(Camera.instance.position)) {
playerInstance.playIdle();
} else {
currentPos.copyFrom(Camera.instance.position);
playerInstance.playRunning();
}
}
}
engine.addSystem(new PlayerMovementCheckSystem());"
/* Script that create a player class that can be used to switch avatars */,"export class SecondaryPlayer extends Entity {
  constructor(model: GLTFShape, transform: Transform) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(transform)

    this.addComponent(new Animator())
    this.getComponent(Animator).addClip(
      new AnimationState('Running', { looping: true })
    )
    this.getComponent(Animator).addClip(
      new AnimationState('Idle', { looping: true })
    )
  }
  // Play running animation
  playRunning() {
    this.getComponent(Animator).getClip('Running').play()
  }

  // Play idle animation
  playIdle() {
    this.getComponent(Animator).getClip('Idle').play()
  }
}"
"/* Script that enables a player to grab an object, pick it up and move it anywhere in the scene. This script pulls from a crate file that creates a crate entity. */","import { Crate } from './crate'

// Base Entity
const base = new Entity()
base.addComponent(new GLTFShape('models/baseLight.glb'))
engine.addEntity(base)

// Constants
const HEIGHT_OFFSET = 1.5
const GROUND_LEVEL = 0.55

// Crate Entity
const crate = new Crate(
  new GLTFShape('models/crate.glb'),
  new Transform({
    position: new Vector3(8, GROUND_LEVEL, 8)
  })
)

// Sounds
const pickupSound = new Entity()
pickupSound.addComponent(new AudioSource(new AudioClip('sounds/pickUp.mp3')))
pickupSound.addComponent(new Transform())
engine.addEntity(pickupSound)
pickupSound.setParent(Attachable.AVATAR)

const dropSound = new Entity()
dropSound.addComponent(new AudioSource(new AudioClip('sounds/putDown.mp3')))
dropSound.addComponent(new Transform())
engine.addEntity(dropSound)
dropSound.setParent(Attachable.AVATAR)

// Controls
Input.instance.subscribe('BUTTON_DOWN', ActionButton.PRIMARY, false, (event) => {
  const crateTransform = crate.getComponent(Transform)
  if (!crate.isGrabbed) {
    crate.isGrabbed = true
    pickupSound.getComponent(AudioSource).playOnce()
    crateTransform.position = Vector3.Zero()
    crateTransform.rotation = Quaternion.Zero()
    crateTransform.position.z += HEIGHT_OFFSET
    crate.setParent(Attachable.AVATAR)
  } else {
    crate.isGrabbed = false
    dropSound.getComponent(AudioSource).playOnce()
    crate.setParent(null)
    const forwardVector = Vector3.Forward()
      .scale(HEIGHT_OFFSET)
      .rotate(Camera.instance.rotation)
    crateTransform.position = Camera.instance.position.clone().add(forwardVector)
    crateTransform.lookAt(Camera.instance.position)
    crateTransform.rotation.x = 0
    crateTransform.rotation.z = 0
    crateTransform.position.y = GROUND_LEVEL
  }
})"
/* Script creates a crate enitty that can be used in scenes */,"export class Crate extends Entity {
   isGrabbed: boolean = false
 
   constructor(model: GLTFShape, transform: Transform) {
     super()
     engine.addEntity(this)
     this.addComponent(model)
     this.addComponent(transform)
 
     this.addComponent(
       new OnPointerDown(
         () => {
           // Do nothing
         },
         {
           button: ActionButton.PRIMARY,
           hoverText: 'Pick Up / Put Down',
           distance: 5
         }
       )
     )
   }
 }"
"/* Script to produce npc dialogue, needs dialogue data and resourses imported */","import { NPC, NPCDelay } from '@dcl/npc-scene-utils';
import resources from './resources';
import { AliceDialog, BobDialog, CharlieDialog } from './modules/dialogData';

// Base Entity
const base = new Entity();
base.addComponent(resources.models.standard.baseScene);
base.addComponent(new Transform());
engine.addEntity(base);

// NPCs, can use this for the character config
const npcConfig = {
  faceUser: true,
  portrait: {
    path: '',
    height: 256,
    width: 256,
    section: {
      sourceHeight: 512,
      sourceWidth: 512
    }
  },
  onWalkAway: (npc: any) => {
    npc.playAnimation('Goodbye', true, 2);
  }
};

// Alice
export const alice = new NPC({
  position: new Vector3(8, 1.6, 5),
  rotation: Quaternion.Euler(0, 180, 0)
},
  resources.models.robots.alice,
  () => {
    // animations
    alice.playAnimation('Hello', true, 2);

    const delay = new Entity();
    delay.addComponent(
      new NPCDelay(2, () => {
        alice.playAnimation('Talk');
      })
    );
    engine.addEntity(delay);

    // sound
    alice.addComponentOrReplace(new AudioSource(resources.sounds.alice));
    alice.getComponent(AudioSource).playOnce();

    // dialog UI
    alice.talk(AliceDialog);
  },
  {
    faceUser: true,
    portrait: {
      path: 'images/portraits/alice.png',
      height: 256,
      width: 256,
      section: {
        sourceHeight: 512,
        sourceWidth: 512
      }
    },
    onWalkAway: () => {
      alice.playAnimation('Goodbye', true, 2)
    }
  }
);

// Bob
export const bob = new NPC({
  position: new Vector3(5, 1.6, 11),
  rotation: Quaternion.Euler(0, 180, 0)
},
  resources.models.robots.bob,
  () => {
    // animations
    bob.playAnimation('Hello', true, 2);

    const delay = new Entity();
    delay.addComponent(
      new NPCDelay(2, () => {
        bob.playAnimation('Talk');
      })
    );
    engine.addEntity(delay);

    // sound
    bob.addComponentOrReplace(new AudioSource(resources.sounds.bob));
    bob.getComponent(AudioSource).playOnce();

    // dialog UI
    bob.talk(BobDialog);
  },
  {
    faceUser: true,
    portrait: {
      path: 'images/portraits/bob.png',
      height: 256,
      width: 256,
      section: {
        sourceHeight: 512,
        sourceWidth: 512
      }
    },
    onWalkAway: () => {
      bob.playAnimation('Goodbye', true, 2)
    }
  }
)

// // Charlie
export const charlie = new NPC(
  {
    position: new Vector3(11, 1.6, 11),
    rotation: Quaternion.Euler(0, 180, 0)
  },
  resources.models.robots.charlie,
  () => {
    // animations
    charlie.playAnimation('Hello', true, 2)

    const dummyent = new Entity()
    dummyent.addComponent(
      new NPCDelay(2, () => {
        charlie.playAnimation('Talk')
      })
    )
    engine.addEntity(dummyent)

    // sound
    charlie.addComponentOrReplace(new AudioSource(resources.sounds.charlie))
    charlie.getComponent(AudioSource).playOnce()

    // dialog UI
    charlie.talk(CharlieDialog)
  },
  {
    faceUser: true,
    portrait: {
      path: 'images/portraits/charlie.png',
      height: 256,
      width: 256,
      section: {
        sourceHeight: 512,
        sourceWidth: 512
      }
    },
    onWalkAway: () => {
      charlie.playAnimation('Goodbye', true, 2)
    }
  }
)

// fixed animated rings under NPCs

const ringShape = resources.models.robots.rings

const aliceRings = new Entity()
aliceRings.addComponent(ringShape)
aliceRings.addComponent(
  new Transform({
    position: new Vector3(0, -0.65, 0)
  })
)
aliceRings.setParent(alice)

const bobRings = new Entity()
bobRings.addComponent(ringShape)
bobRings.addComponent(
  new Transform({
    position: new Vector3(0, -0.65, -0.075)
  })
)
bobRings.setParent(bob)

const charlieRings = new Entity()
charlieRings.addComponent(ringShape)
charlieRings.addComponent(
  new Transform({
    position: new Vector3(0, -0.55, -0.2)
  })
)
charlieRings.setParent(charlie)"
/* Script for dialogue data */,"import { Dialog } from '@dcl/npc-scene-utils'
import { alice, bob, charlie } from '../game'

export const AliceDialog: Dialog[] = [
  {
    text: ""Hi, I'm Alice - welcome to Genesis Plaza!""
  },
  {
    text: 'Would you like to learn more about this place?',
    isQuestion: true,
    buttons: [
      { label: 'Yes', goToDialog: 3 },
      { label: 'No', goToDialog: 2 }
    ]
  },
  {
    text: ""Okay, I'll be around if you get curious!"",
    isEndOfDialog: true,
    triggeredByNext: () => {
      alice.playAnimation('Goodbye', true, 2)
    }
  },
  {
    text: 'Weâ€™re currently in the center of the Genesis City map, the roads fan out in all directions from here.'
  },
  {
    text: 'Genesis Plaza is built and maintained by the Decentraland Foundation but is still in many ways a community project.'
  },
  {
    text: 'If you venture out into the world, youâ€™ll see that the content is created by our growing community.'
  },
  {
    text: 'Do you want to explore the rest of Genesis Plaza or explore the rest of the world?',
    isQuestion: true,
    buttons: [
      { label: 'PLAZA', goToDialog: 7 },
      { label: 'WORLD', goToDialog: 18 }
    ]
  },
  {
    text: 'Great! Thereâ€™s a lot to see right here.'
  },
  {
    text: 'If you walk around you might run into my buddies and each is an expert on a different topic.'
  },
  {
    text: 'You can learn a lot from them about how Decentraland works and what makes it special.'
  },
  {
    text: 'I recommend you start at that boat-shaped building to the North!'
  },
  {
    text: ""Do you also want to learn about what's beyond Genesis Plaza?"",
    isQuestion: true,
    buttons: [
      { label: 'YES', goToDialog: 12 },
      { label: 'NO', goToDialog: 28 }
    ]
  },
  {
    text: 'Thereâ€™s a big world to explore out there!',
    offsetY: 18
  },
  {
    text: ""Around Genesis Plaza you'll find several teleports that can take you directly to special scenes marked as points of interest.""
  },
  {
    text: ""There's also the 'crowd' teleport, which takes you to the biggest gathering of people in Decentraland so you can meet up and hang out.""
  },
  {
    text: ""If you press the 'M' key, youâ€™ll open the map. You'll see markers for points of interest that are worth visiting.""
  },
  {
    text: ""Or simply explore the virtual world by foot and plot your own adventure. Just keep in mind that there's a LOT of ground to cover.""
  },
  {
    text: 'So what are you waiting for? Go and explore the world!',
    isEndOfDialog: true,
    triggeredByNext: () => {
      alice.playAnimation('Goodbye', true, 2)
    }
  },
  {
    text: 'Thereâ€™s a big world to explore out there!'
  },
  {
    text: ""Around Genesis Plaza you'll find several teleports that can take you directly to special scenes marked as points of interest.""
  },
  {
    text: ""There's also the 'crowd' teleport, which takes you to the biggest gathering of people in Decentraland so you can meet up and hang out.""
  },
  {
    text: ""If you press the 'M' key, youâ€™ll open the map. You'll see markers for points of interest that are worth visiting.""
  },
  {
    text: ""Or simply explore the virtual world by foot and plot your own adventure. Just keep in mind that there's a LOT of ground to cover.""
  },
  {
    text: ""Do you also want to find out what's here in Genesis Plaza?"",
    isQuestion: true,
    buttons: [
      { label: 'YES', goToDialog: 24 },
      { label: 'NO', goToDialog: 28 }
    ]
  },
  {
    text: 'Great! Thereâ€™s a lot to see right here.'
  },
  {
    text: 'If you walk around you might run into my buddies and each is an expert on a different topic.'
  },
  {
    text: 'You can learn a lot from them about how Decentraland works and what makes it special.'
  },
  {
    text: 'I recommend you start at that boat-shaped building to the North!'
  },
  {
    text: ""Well that's it from me. So what are you waiting for? Go and explore the world!"",
    triggeredByNext: () => {
      alice.playAnimation('Goodbye', true, 2)
    },
    isEndOfDialog: true
  }
]

export const BobDialog: Dialog[] = [
  {
    text: ""G'day human! My name is Bob and I'm a robot. Would you like to learn more about the history of Decentraland and how it all started?"",
    isQuestion: true,
    offsetY: 20,
    buttons: [
      { label: 'YES', goToDialog: 2 },
      { label: 'NO', goToDialog: 'no' }
    ]
  },
  {
    text: ""Okay, I'll be around if you get curious."",
    name: 'no',
    triggeredByNext: () => {
      bob.playAnimation('Goodbye', true, 2)
    },
    isEndOfDialog: true
  },
  {
    text: ""Decentraland's unique proposal is to create a virtual world governed by its users.""
  },
  {
    text: ""This little museum takes you through some of the milestones in Decentraland's history.""
  },
  {
    text: 'Some key events in the history of the project were: the Terraform Event, which had the first LAND sale.'
  },
  {
    text: 'The second auction in late 2018; the creation of Avatars and Wearables in 2019; the release of the open source client and the DAO in 2020.'
  },
  {
    text: ""So much has happened already, and we're just getting started...""
  },
  {
    text: ""Take a look around. If you're interested in any of the items, click on them and I'll tell you the background story."",
    triggeredByNext: () => {
      bob.playAnimation('Goodbye', true, 2)
    },
    isEndOfDialog: true
  }
]

export const CharlieDialog: Dialog[] = [
  {
    text: ""Hey, I'm Charlie - a master trader. Would you like to learn more about the Decentraland Marketplace?"",
    isQuestion: true,
    offsetY: 20,
    buttons: [
      { label: 'YES', goToDialog: 2 },
      { label: 'NO', goToDialog: 1 }
    ]
  },
  {
    text: ""Okay, I'll be around if you get curious."",
    isEndOfDialog: true,
    triggeredByNext: () => {
      charlie.playAnimation('Goodbye', true, 2)
    }
  },
  {
    text: 'This is the Metaverse Trade Center. Here you can see live stats from the Decentraland Marketplace.'
  },
  {
    text: 'Thereâ€™s a thriving economy behind Decentraland and every day people buy and sell unique items.'
  },
  {
    text: 'Items like LAND parcels, wearable items and reserved names.'
  },
  {
    text: 'As more trading happens on the platform, it grows and moves faster.'
  },
  {
    text: 'You can explore this building to find real-time stats about what goes on in the Marketplace.'
  },
  {
    text: 'Do you want to know more about how the Marketplace uses the blockchain?',
    isQuestion: true,
    buttons: [
      { label: 'YES', goToDialog: 8 },
      { label: 'NO', goToDialog: 12 }
    ]
  },
  {
    text: 'All sales, bids and other operations are transactions on the blockchain.'
  },
  {
    text: 'Like all transactions, they require a small gas fee that is paid to the network of miners.'
  },
  {
    text: ""The Marketplace charges a small fee over all transactions. This fee doesn't go into anyone's pocket. Instead it gets burned.""
  },
  {
    text: ""'Burning' reduces the amount of MANA in circulation; the remaining MANA becomes more valuable, which benefits the wider community of MANA holders."",
    offsetY: -4
  },
  {
    text: 'Remember to visit market.decentraland.org - over there you can buy or sell LAND, wearables or unique names. Happy shopping!',
    isEndOfDialog: true,
    triggeredByNext: () => {
      charlie.playAnimation('Goodbye', true, 2)
    }
  }
]"
/* Script for resources for npc dialogue */,"export default {
  sounds: {
    alice: new AudioClip('sounds/alice.mp3'),
    bob: new AudioClip('sounds/bob.mp3'),
    charlie: new AudioClip('sounds/charlie.mp3')
  },
  models: {
    standard: {
      baseScene: new GLTFShape('models/standard/baseScene.glb')
    },
    robots: {
      alice: 'models/robots/alice.glb',
      bob: 'models/robots/bob.glb',
      charlie: 'models/robots/charlie.glb',
      rings: new GLTFShape('models/robots/rings.glb')
    }
  },
  textures: {
    blank: new Texture('images/ui/blank.png'),
    buttonE: new Texture('images/ui/buttonE.png'),
    buttonF: new Texture('images/ui/buttonF.png'),
    leftClickIcon: new Texture('images/ui/leftClickIcon.png'),
    textPanel: new Texture('images/ui/textPanel.png')
  }
}"
"/* Script to create a nft market place, needs ./dcl-utils import and nft import */","import { Entity, Scene, Vector3Component } from '@dcl/ecs-scene-utils'
import { NFT } from './nft'
import { createToken, getBalance, transferToken } from './dcl-utils'

const scene = new Scene()
const store = new Entity()

// put in the NFT information
store.addComponent(new NFT(...))
store.addComponent(
  new Vector3Component(
    { x: 5, y: 0, z: 5 },
    { x: 0, y: 0, z: 0 },
    { x: 1, y: 1, z: 1 }
  )
)

scene.addEntity(store)

async function purchaseNFT(tokenId: string) {
  const balance = await getBalance()
  if (balance < NFT.price) {
    log(`You need at least ${NFT.price} MANA to purchase this NFT`)
    return
  }

  const result = await transferToken(tokenId, NFT.price, ...)
  if (result) {
    log('NFT purchased successfully!')
  } else {
    log('Transaction failed')
  }
}

async function createAndSellNFT(price: number) {
  const tokenId = await createToken(...)
  if (tokenId) {
    log(`NFT created successfully with token ID: ${tokenId}`)
  } else {
    log('Failed to create NFT')
  }
}
"
/* NFT import for marketplace */,"import { ethers } from 'ethers';

export class NFT {
  private _tokenId: string;
  private _price: number;
  private _provider: ethers.JsonRpcProvider;
  private _contract: ethers.Contract;

  constructor(tokenId: string, provider: ethers.JsonRpcProvider, contract: ethers.Contract, price: number) {
    this._tokenId = tokenId;
    this._provider = provider;
    this._contract = contract;
    this._price = price;
  }

  get tokenId() {
    return this._tokenId;
  }

  get provider() {
    return this._provider;
  }

  get contract() {
    return this._contract;
  }

  get price() {
    return this._price
  }
}"
"/* Script for dcl-utils for nft marketplace, needs ./apis file imported */","import ethers from ""ethers"";
//import { providers } from 'ethers';

import { NFT_ABI, ERC721_ABI } from './abis'
import { randomBytes } from 'crypto';

const privateKey = randomBytes(32).toString('hex');

let ethersProvider = new ethers.InfuraProvider(""ropsten"")
let wallet = new ethers.Wallet(privateKey)
let walletSigner = wallet.connect(ethersProvider)


export async function createToken(
  contractAddress: string,
  contract: ethers.Contract,
  tokenId: number,
  tokenUri: string
): Promise<ethers.TransactionResponse> {
  const args = [tokenId, tokenUri];
  const tx = await contract.createToken(...args);
  return walletSigner.sendTransaction(tx);
}

export async function getBalance(
  contractAddress: string,
  walletAddress: string
): Promise<number> {
  const contract = new ethers.Contract(contractAddress, ERC721_ABI, ethersProvider);
  return await contract.balanceOf(walletAddress);
}

export async function transferToken(
  contractAddress: string,
  contract: ethers.Contract,
  toAddress: string,
  tokenId: number
): Promise<ethers.TransactionResponse> {
  const args = [toAddress, tokenId];
  const tx = await contract.transfer(...args);
  return walletSigner.sendTransaction(tx);
}"
/* Script for abis to import to dcl-utils for nft market place. Outlines the ERC721_ABI json for NFT information and the NFT_ABI */,"export const ERC721_ABI = [
   {
      ""constant"": true,
      ""inputs"": [
         {
            ""name"": ""_interfaceId"",
            ""type"": ""bytes4""
         }
      ],
      ""name"": ""supportsInterface"",
      ""outputs"": [
         {
            ""name"": """",
            ""type"": ""bool""
         }
      ],
      ""payable"": false,
      ""stateMutability"": ""view"",
      ""type"": ""function""
   },
   {
      ""constant"": true,
      ""inputs"": [
         {
            ""name"": ""_tokenId"",
            ""type"": ""uint256""
         }
      ],
      ""name"": ""getApproved"",
      ""outputs"": [
         {
            ""name"": """",
            ""type"": ""address""
         }
      ],
      ""payable"": false,
      ""stateMutability"": ""view"",
      ""type"": ""function""
   },
   {
      ""constant"": false,
      ""inputs"": [
         {
            ""name"": ""_to"",
            ""type"": ""address""
         },
         {
            ""name"": ""_tokenId"",
            ""type"": ""uint256""
         }
      ],
      ""name"": ""approve"",
      ""outputs"": [],
      ""payable"": false,
      ""stateMutability"": ""nonpayable"",
      ""type"": ""function""
   },
   {
      ""constant"": true,
      ""inputs"": [],
      ""name"": ""totalSupply"",
      ""outputs"": [
         {
            ""name"": """",
            ""type"": ""uint256""
         }
      ],
      ""payable"": false,
      ""stateMutability"": ""view"",
      ""type"": ""function""
   },
   {
      ""constant"": false,
      ""inputs"": [
         {
            ""name"": ""_from"",
            ""type"": ""address""
         },
         {
            ""name"": ""_to"",
            ""type"": ""address""
         },
         {
            ""name"": ""_tokenId"",
            ""type"": ""uint256""
         }
      ],
      ""name"": ""transferFrom"",
      ""outputs"": [],
      ""payable"": false,
      ""stateMutability"": ""nonpayable"",
      ""type"": ""function""
   },
   {
      ""constant"": true,
      ""inputs"": [
         {
            ""name"": ""_tokenId"",
            ""type"": ""uint256""
         }
      ],
      ""name"": ""exists"",
      ""outputs"": [
         {
            ""name"": """",
            ""type"": ""bool""
         }
      ],
      ""payable"": false,
      ""stateMutability"": ""view"",
      ""type"": ""function""
   },
   {
      ""constant"": true,
      ""inputs"": [
         {
            ""name"": ""_owner"",
            ""type"": ""address""
         }
      ],
   }]

   export const NFT_ABI = [
      {
        constant: true,
        inputs: [{ name: '_interfaceId', type: 'bytes4' }],
        name: 'supportsInterface',
        outputs: [{ name: '', type: 'bool' }],
        payable: false,
        type: 'function'
      },
      {
        constant: true,
        inputs: [],
        name: 'name',
        outputs: [{ name: '', type: 'string' }],
        payable: false,
        type: 'function'
      },
      {
        constant: true,
        inputs: [{ name: '_tokenId', type: 'uint256' }],
        name: 'getApproved',
        outputs: [{ name: '', type: 'address' }],
        payable: false,
        type: 'function'
      },
      {
        constant: false,
        inputs: [
          { name: '_to', type: 'address' },
          { name: '_tokenId', type: 'uint256' }
        ],
        name: 'approve',
        outputs: [],
        payable: false,
        type: 'function'
      },
      {
        constant: true,
        inputs: [],
        name: 'totalSupply',
        outputs: [{ name: '', type: 'uint256' }],
        payable: false,
        type: 'function'
      },
      {
        constant: false,
        inputs: [
          { name: '_from', type: 'address' },
          { name: '_to', type: 'address' },
          { name: '_tokenId', type: 'uint256' }
        ],
        name: 'transferFrom',
        outputs: [],
        payable: false,
        type: 'function'
      },
      {
        constant: true,
        inputs: [{ name: '_owner', type: 'address' }],
        name: 'balanceOf',
        outputs: [{ name: '', type: 'uint256' }],
        payable: false,
        type: 'function'
      },
      {
        constant: false,
        inputs: [
          { name: '_to', type: 'address' },
          { name: '_tokenId', type: 'uint256' }
        ],
        name: 'transfer',
        outputs: [],
        payable: false,
        type: 'function'
      },
      {
        constant: true,
        inputs: [],
        name: 'symbol',
        outputs: [{ name: '', type: 'string' }],
        payable: false,
        type: 'function'
      },
      {
        constant: false,
        inputs: [
          { name: '_from', type: 'address' },
          { name: '_to', type: 'address' },
          { name: '_tokenId', type: 'uint256' },
          { name: '_data', type: 'bytes' }
        ],
        name: 'safeTransferFrom',
        outputs: [],
        payable: false,
        type: 'function'
      }
   ]
       
    "
"/* Script for an avatar to wave their hand, needs to import three.js */","// Import the Decentraland SDK

import { AnimatedMesh, AnimationClip } from 'THREE'

// Create a new Entity as the avatar
const avatar = new Entity()

// Add a mesh component to the avatar, representing the 3D model

const mesh = new AnimatedMesh(avatar)
mesh.src = 'url_to_your_avatar_model'

// Create an AnimationClip to define the hand waving motion
const clip = new AnimationClip()
clip.name = 'HandWave'
clip.duration = 1.0
clip.tracks = [
  {
    property: 'rotation',
    keyframes: [
      {
        time: 0.0,
        value: new Quaternion()
      },
      {
        time: 0.5,
        value: new Quaternion().setEuler(-15, 0, 0)
      },
      {
        time: 1.0,
        value: new Quaternion()
      }
    ]
  }
]

// Add the AnimationClip to the mesh component
mesh.animations = [clip]

// Play the hand waving animation
mesh.getComponent(AnimationState).play(clip.name)"
/* Script to create a rotating cube */,"const cube = new Entity()
cube.addComponent(new GLTFShape('models/Cube.gltf'))
cube.addComponent(
  new Transform({
    rotation: Quaternion.Euler(0, 45, 0)
  })
)

engine.addEntity(cube)"
/* Script to create an npc with random movement within a scene */,"const npc = new Entity()

npc.addComponent(new Transform({
  position: new Vector3(0, 0, 0)
}))

const update = () => {
  npc.getComponent(Transform).position.x += Math.random() * 0.1 - 0.05
  npc.getComponent(Transform).position.z += Math.random() * 0.1 - 0.05
}

engine.addEntity(npc)


"
/* Script that makes an avatar jump when a user clicks on it */,"
const avatar = new Entity()

avatar.addComponent(new Transform({
  position: new Vector3(0, 0, 0)
}))

new OnPointerDown(() => {
  avatar.getComponent(Transform).position.y += 1
})

engine.addEntity(avatar)"
/* Script for creating a door in Decentraland that opens when the user approaches it */,"const door = new Entity()

door.addComponent(new Transform({
  position: new Vector3(0, 0, 0)
}))

door.addComponent(new OnPointerDown(() => {
  door.getComponent(Transform).position.y -= 1
}))

engine.addEntity(door)"
/* Script to add audio stream to your scene */,"const streamSource = new Entity()

// add the audio stream to the enit
streamSource.addComponent(
  new AudioStream(
    ""Audio Stream URL""
  )
)
engine.addEntity(streamSource)

streamSource.getComponent(AudioStream).playing = true"
/* Script for Implementing a Simple Quest System */,"// Define an interface for a Quest
interface Quest {
  id: string;
  name: string;
  description: string;
  completed: boolean;
}

// Create a class for Quest Manager to handle quest logic
class QuestManager {
  private quests: Quest[] = [];

  addQuest(quest: Quest) {
    this.quests.push(quest);
  }

  completeQuest(questId: string) {
    const questIndex = this.quests.findIndex((quest: any) => quest.id === questId);
    if (questIndex !== -1) {
      this.quests[questIndex].completed = true;
    }
  }
}

// Usage Example
const questManager = new QuestManager();

questManager.addQuest({
  id: '1',
  name: 'Collect 10 coins',
  description: 'Collect 10 coins to receive a reward',
  completed: false
});

// Mark the quest as completed when the player collects 10 coins
questManager.completeQuest('1');"
/* Implementing a Multiplayer Synchronization System */,"class Entity {
  id: string;
  x: number;
  y: number;
  z: number;

  constructor(id: string, x: number, y: number, z: number) {
    this.id = id;
    this.x = x;
    this.y = y;
    this.z = z;
  }
}

class NetworkManager {
  private entities: Map<string, Entity> = new Map();
  private socket: WebSocket;

  constructor() {
    this.socket = new WebSocket('ws://localhost:8080');
    this.socket.onmessage = this.onMessage.bind(this);
  }

  addEntity(entity: Entity) {
    this.entities.set(entity.id, entity);
    this.sendUpdate(entity);
  }

  updateEntity(entityId: string, x: number, y: number, z: number) {
    const entity = this.entities.get(entityId);
    if (entity) {
      entity.x = x;
      entity.y = y;
      entity.z = z;
      this.sendUpdate(entity);
    }
  }

  private sendUpdate(entity: Entity) {
    this.socket.send(JSON.stringify({
      type: 'update',
      entity: {
        id: entity.id,
        x: entity.x,
        y: entity.y,
        z: entity.z
      }
    }));
  }

  private onMessage(event: MessageEvent) {
    const data = JSON.parse(event.data);
    switch (data.type) {
      case 'update':
        this.handleUpdate(data.entity);
        break;
    }
  }

  private handleUpdate(entityData: any) {
    let entity = this.entities.get(entityData.id);
    if (!entity) {
      entity = new Entity(entityData.id, entityData.x, entityData.y, entityData.z);
      this.entities.set(entityData.id, entity);
    } else {
      entity.x = entityData.x;
      entity.y = entityData.y;
      entity.z = entityData.z;
    }
  }
}"
,"import { Scene } from ""three""

const scene = new Scene

const plane = new Entity()
plane.addComponent(new PlaneShape())
plane.addComponent(new Transform({ position: new Vector3(5, 0, 5) }))
engine.addEntity(plane)

const text = new Entity()
text.addComponent(new Transform({ position: new Vector3(5, 1, 5) }))
text.addComponent(new TextShape('Hello World'))
engine.addEntity(text)

scene.listen(""pointerDown"", (event) => {
  text.getComponent(TextShape).value = ""Pointer down""
  text.getComponent(Transform).position.y += 1
})"
/* Script to create a plane and a text shape that raises by a position when the plane is clicked */,"const plane = new Entity()
plane.addComponent(new Transform({ position: new Vector3(5, 0, 5) }))

const text = new Entity()
text.addComponent(new Transform({ position: new Vector3(5, 1, 5) }))
text.addComponent(new TextShape('Hello World'))

text.addComponent(
  new OnPointerDown(() => {
    text.getComponent(TextShape).value = ""Pointer down""
    text.getComponent(Transform).position.y += 1
  })
)
"
/* Script to rotate a plane and update its position every its position based on its rotation */,"import { SystemContainer } from ""@dcl/ecs/dist/engine/systems""

const plane = new Entity()
plane.addComponent(new Transform({ position: new Vector3(5, 0, 5) }))

class AnimatedBox extends Entity {
  constructor() {
    super()
    this.addComponent(new BoxShape())
    this.addComponent(new Transform({ position: new Vector3(2, 1, 2) }))
  }

  update(delta: number) {
    const transform = this.getComponent(Transform)
    transform.rotation.multiplyInPlace(Quaternion.Euler(0, delta, 0))
    transform.position.x = 2 + Math.sin(transform.rotation.eulerAngles.y / 180 * Math.PI)
  }
}

const animatedBox = new AnimatedBox()


engine.update = (delta: number) => {
  animatedBox.update(delta)
  return engine
}

"
/* Script that creates a basketball entity and increases the score when the basketball collides with the hoop. Needs ./label and ./basketball imported */,"// import the basketball class and the label class
import { Basketball } from './basketball';
import { Label } from './label';

// import utils from the engine
import { utils } from '@dcl/ecs-scene-utils';

// create a basketball entity and add it to the engine
const basketball = new Basketball();
engine.addEntity(basketball);

// score variable
let score = 0;
// create a score label and add it to the engine
const scoreLabel = new Label();

// create a function that increases the score when the basketball hits the hoop
const increaseScore = () => {
   score++;
   scoreLabel.text = score.toString();
   }

// creata a basketball hoop entity and add it to the engine
const basketballHoop = new Entity();
basketballHoop.addComponent(new Transform({
   position: new Vector3(8, 0, 8),
   scale: new Vector3(2, 2, 2)
}));
basketballHoop.addComponent(new BoxShape());
basketballHoop.addComponent(new Material());
basketballHoop.getComponent(Material).albedoColor = Color3.Green();
engine.addEntity(basketballHoop);

// create a trigger that calls the increaseScore function when the basketball hits the hoop
basketballHoop.addComponent(new utils.TriggerComponent(
   new utils.TriggerBoxShape(new Vector3(2, 2, 2), Vector3.Zero()),
   0,
   0,
   increaseScore
));
"
/* Script that creates a spinning star and alerts the user that after 10 seconds of looking at the star and shakes the screen. Needs models/Star.glb import */,"import * as utils from '@dcl/ecs-scene-utils'

// create a spinning star entity
const star = new Entity()
star.addComponent(new GLTFShape('models/Star.glb'))
star.addComponent(new Transform({
   position: new Vector3(8, 1, 8)
}))

// when the user looks at the star for 2 seconds, spin it
star.addComponent(new OnPointerDown(
   (e) => {
      star.addComponentOrReplace(new utils.RotateTransformComponent(star.getComponent(Transform).rotation, Quaternion.Euler(0, 360, 0), 2))
   }
))

// after 10 seconds, alert the user that they have been looking at the star for too long and start making the screen shake
engine.addSystem(new utils.Delay(10000, () => {
   star.addComponentOrReplace(new utils.AlertComponent('You have been looking at the star for too long!', 3))
   star.addComponentOrReplace(new utils.ShakeTransformComponent(star.getComponent(Transform).position, 0.5, 0.5, 0.5, 10))
}
))"
"/* Script creates a robot entity that follows a path, needs pathfollower, robot, and path imports */","// import the path follower component and the path class and the robot model
import { PathFollower } from './pathFollower'
import { Path } from './path'
import { Robot } from './robot'

// create a robot object that follows a path on the ground
const robot = new Robot({
   position: new Vector3(0, 0, 0),
   rotation: Quaternion.Euler(0, 180, 0),
   scale: new Vector3(0.5, 0.5, 0.5)
})

// create a path for the robot to follow
const path = new Path()
path.addPoint(new Vector3(0, 0, 0))
path.addPoint(new Vector3(0, 0, 5))
path.addPoint(new Vector3(5, 0, 5))
path.addPoint(new Vector3(5, 0, 0))
path.addPoint(new Vector3(0, 0, 0))

// create a path follower component
const pathFollower = new PathFollower()
pathFollower.path = path
pathFollower.speed = 1
pathFollower.loop = true

// add the path follower component to the robot
robot.addComponentOrReplace(pathFollower)

// add the robot to the scene
engine.addEntity(robot)"
"/* Script that create a bomb that blows up 3 seconds after being clicked, needs models/bomb.glb */","// import utils
import * as utils from '@dcl/ecs-scene-utils'

// create a bomb enitity that blows up 3 seconds after being clicked
const bomb = new Entity()
bomb.addComponent(new GLTFShape('models/bomb.glb'))
bomb.addComponent(new Transform({
   position: new Vector3(8, 0, 8)
}))

// add a click listener to the bomb
bomb.addComponent(new OnClick(e => {
   log('boom!')
   engine.removeEntity(bomb)
}))

// add a delay to the bomb
bomb.addComponent(new utils.Delay(3000, () => {
   engine.removeEntity(bomb)
}))

// add the bomb to the scene
engine.addEntity(bomb)
"
/* Script uses three.js to create the physics for a bedsheet */,"// import three.js
import * as THREE from 'three';

// create a scene
const scene = new THREE.Scene();

// create a bedsheet using three.js and add it to the scene 
const bedsheet = new THREE.Mesh(
      new THREE.PlaneGeometry(1, 1, 1, 1),
      new THREE.MeshBasicMaterial({
         map: new THREE.TextureLoader().load('assets/bedsheet.png'),
         transparent: true,
         side: THREE.DoubleSide,
      })
   );
bedsheet.scale.set(1.5, 1.5, 1.5);
bedsheet.position.set(0, 0, 0);

// add the bedsheet to the scene
scene.add(bedsheet);"
/* Script that creates an LED strip with neopixel and changes the colors according to a sine wave pattern */,"// import the neopixel library
import * as neopixel from ""neopixel""


// create an led strip with 10 leds that change color is a sine wave pattern
let strip = neopixel.create(DigitalPin.P0, 10, NeoPixelMode.RGB)
strip.setBrightness(50)
let i = 0
strip.forever(() => {
      for (let index = 0; index <= 9; index++) {
         strip.setPixelColor(index, neopixel.hsl(i, 100, 50))
         i += 36
      }
      strip.show()
      i = 0
   }
)
"
"/* Script that creates a monsters character with health and a moves list, needs to import character and moves */ ","// import character and move classes
import { Character } from './character';
import { Move } from './move';

// make a monster character with a health bar and combat moves and stats
const monster = new Character({ 
   name: 'Monster',
   health: 100,
   maxHealth: 100,
   attack: 10,
   defense: 5,
   speed: 5,
   moves: [
      new Move({
         name: 'Attack',
         type: 'attack',
         power: 10,
         accuracy: 100,
         description: 'A basic attack'
      }),
      new Move({
         name: 'Defend',
         type: 'defense',
         power: 10,
         accuracy: 100,
         description: 'A basic defense'
      }),
      new Move({
         name: 'Speed',
         type: 'speed',
         power: 10,
         accuracy: 100,
         description: 'A basic speed'
      })
   ]
});
"
/* Script that creates a map entity that sits in the bottom left corner of the screen and displays the current map name */,"// import the MapEntity class
import { MapEntity } from ""./mapEntity"";

// creates a map entity that sits in the bottom left corner of the screen
// and displays the current map name
const map = new MapEntity();
map.x = 0;
map.y = 0;
map.z = 100;
map.width = 100;
map.height = 100;
map.text = ""Map: "" + map.name;
map.textSize = 20;
map.textColor = new Color3(1, 1, 1);
map.textAlign = TextAlign.LEFT;
map.textBaseline = new TextBaseline.TOP;
map.textFont = ""Arial"";
map.textStyle = ""bold"";
map.textShadow = ""1px 1px 1px black"";
map.textShadowColor = new Color3(1, 1, 1);
map.textShadowBlur = 1;
map.textShadowOffsetX = 1;
map.textShadowOffsetY = 1;
map.textShadowOffsetZ = 1;
map.textShadowOffsetW = 1;
map.textShadowOffsetH = 1;
map.textShadowOffsetI = 1;
map.textShadowOffsetJ = 1;
map.textShadowOffsetK = 1;
map.textShadowOffsetL = 1;
map.textShadowOffsetM = 1;
map.textShadowOffsetN = 1;
map.textShadowOffsetO = 1;
map.textShadowOffsetP = 1;
map.textShadowOffsetQ = 1;
map.textShadowOffsetR = 1;
map.textShadowOffsetS = 1;
map.textShadowOffsetT = 1;
map.textShadowOffsetU = 1;
map.textShadowOffsetV = 1;
map.textShadowOffsetW = 1;
map.textShadowOffsetX = 1;
"
/* Script that connects the current player to a websocket server */,"// WebSocket import
import { WebSocket } from ""https://deno.land/std/ws/mod.ts"";

// create a new websocket and connect to the server
const socket = new WebSocket(""ws://localhost:8080"");

// get input from the player
async function getInput() {
   // get input from the player
}

// get the updated game state from the server
async function getGameState() {
   // get the updated game state from the server
}

// gameLoop function
async function gameLoop() {
   // game loop
   while (true) {
      // get input from the player
      const input = await getInput();
      // send the input to the server
      socket.send(input);
      // get the updated game state from the server
      const gameState = await getGameState();
      // render the game state
      render(gameState);
   }
}

// connect the current player to a new server 
// and start the game
function connectToServer() {
   // add event listeners
   socket.addEventListener(""open"", function (event: any) {
      log(""Connected to server"");
   });
   socket.addEventListener(""message"", function (event: { data: any; }) {
      log(""Message from server "", event.data);
   });
   socket.addEventListener(""close"", function (event: any) {
      log(""Disconnected from server"");
   });
   // start the game
   gameLoop();
}

function render(gameState: void) {
   throw new Error(""Function not implemented."");
}
"
"/* Script that defines the logic for player health regeneration and decay, needs player and health pack imports */","// import the player and healthpack class
import { Player } from './player';
import { HealthPack } from './healthpack';

// create a new player for the health regeneration
const player = new Player();

// create a new health pack for the health regeneration
const healthPack = new HealthPack();

// function to create player health rengeneration
function playerHealthRegen() {
   if (player.health < player.maxHealth) {
      player.health += 0.1;
   }
}

// function to increase health at a faster rate when player picks up a health pack
function playerHealthRegenBoost() {
   if (player.health < player.maxHealth) {
      player.health += 0.2;
   }
}

// function to decrease health when player is hit by an enemy
function playerHealthDecay() {
   if (player.health > 0) {
      player.health -= 0.1;
   }
}

"
/* Script to demonstrate the clamp function */,"import * as utils from '@dcl/ecs-scene-utils'
// give an example for the clamp function in decentraland-ecs

// clamp a value between 0 and 1
const value = utils.clamp(2, 0, 1)
log(value) // 1

// function to demonstrate the clamp function
function clampExample() {
   const box = new Entity()
   box.addComponent(new BoxShape())
   box.addComponent(new Transform({ position: new Vector3(8, 1, 8) }))
   box.addComponent(
      new OnPointerDown(
         (e) => {
         // get the position of the pointer
         const position = e.hit ? e.hit : Vector3.Zero()
         // get the x position of the pointer
         const x = position.x
         // clamp the x position between 0 and 1
         const clampedX = utils.clamp(x, 0, 1)
         // set the x position of the box to the clamped x position
         box.getComponent(Transform).position.x = clampedX
         },
         { button: ActionButton.POINTER, hoverText: 'Click me!' }
      )
   )
   engine.addEntity(box)
   }"
"/* A script for Non-fungible token (NFT) integration: Allow users to create and trade NFTs within Decentraland, such as custom avatars or virtual land. */

","//Non-fungible token (NFT) integration: Allow users to create and trade NFTs within Decentraland, such as custom avatars or virtual land.

import { NFTShape } from '@dcl/nft-shape'

// Create a new NFTShape component
const nftShape = new NFTShape(
   'ethereum://0x06012c8cf97bead5deae237070f9587f8e7a266d/1', // NFT contract address and token ID
   {
      color: Color3.Red(), // Color of the NFT
      style: NFTShapeStyle.SQUARE, // NFTShapeStyle.SQUARE, NFTShapeStyle.CIRCLE, NFTShapeStyle.PORTRAIT or NFTShapeStyle.LANDSCAPE
      shadowColor: Color3.Black(), // Color of the shadow
      shadowIntensity: 0.5, // Intensity of the shadow
      shadowAngle: 45, // Angle of the shadow
      shadowDistance: 0.5, // Distance of the shadow
      shadowSoftness: 0.5, // Softness of the shadow
      shadowOnly: false, // Render only the shadow
      opacity: 1, // Opacity value of the NFT
      transparent: false, // Render the NFT as transparent (it will ignore the color property)
      billboard: false, // If true, the NFT will always face the camera
      scale: 1, // Scale of the NFT
      visible: true, // Visibility of the NFT
      position: new Vector3(8, 0, 8), // Position of the NFT
      rotation: Quaternion.Euler(0, 0, 0), // Rotation of the NFT
      anchor: new Vector2(0.5, 0.5), // Anchor of the NFT
      width: 1, // Width of the NFT
      height: 1, // Height of the NFT
      src: '' // Source of the NFT
   }
)

// Add the NFTShape component to the entity
engine.addEntity(nftShape)"
/* A script that teleports a player to another scene */,"// a plater teleports to another scene using teleportto function

import * as utils from '@dcl/ecs-scene-utils'

// create a player entity
const player = new Entity()
player.addComponent(new GLTFShape('models/Player.glb'))
player.addComponent(new Transform({
   position: new Vector3(8, 0, 8)
}))
engine.addEntity(player)

// create a teleporter entity
const teleporter = new Entity()
teleporter.addComponent(new GLTFShape('models/Teleporter.glb'))
teleporter.addComponent(new Transform({
   position: new Vector3(8, 0, 16)
}))
engine.addEntity(teleporter)


// add a click event to the teleporter entity
teleporter.addComponent(new OnClick(e => {
   teleportTo('-51,1')
}
))

"
/* Script to create a world class with a player and game */,"// Create a world class
class World {
   // Create a world with a width and height
   constructor(public width: number, public height: number) { }
}

// Create a world
var world = new World(100, 100);

// Create a player class
class Player {
   // Create a player with a name and a position
   constructor(public name: string, public position: Vector3) { }

   // Update the player
   update() {
      // Move the player
      this.position.x += 1;
   }
}

// Create a player
var player = new Player(""Bob"", new Vector3(10, 10));

// Create a game class
class Game {
   // Create a game with a world and a player
   constructor(public world: World, public player: Player) { }

   // Update the game
   update() {
      // Update the player
      this.player.update();
   }

   // Draw the game
   draw() {
      // Draw the player
      console.log(this.player.name + "" is at "" + this.player.position.x + "", "" + this.player.position.y);
   }

   

}

// Create a game
var game = new Game(world, player);

// Create a game loop
function gameLoop() {
   // Update the game
   game.update();
   // Draw the game
   game.draw();
   // Request another game loop
   requestAnimationFrame(gameLoop);
}

// Start the game loop
gameLoop();



function requestAnimationFrame(gameLoop: () => void) {
   throw new Error(""Function not implemented."");
}
"
/* Script to sets up the weather api to simulate real world weather in decentraland */,"import * as DCL from 'decentraland-api'

import axios from 'axios'
const appId : string = '<your app ID>'
const APIkey : string = '<your API key>'
const lat : string = '-34.55'
const lon: string = '-58.46'
const callUrl : string = 'https://api.weatherunlocked.com/api/current/' + lat + ',%20' + lon + '?app_id=' + appId + '&app_key=' + APIkey

export default class HouseScene extends DCL.ScriptableScene {
  sceneDidMount() {
    setInterval(this.getWeather(), 1000000)
  }

  getWeather() {
    axios.get(callUrl)
      .then( (response:any) => {
        console.log(response.data.wx_desc)
      })
      .catch( (error:any) => {
        console.log(error)
      });
  }

  async render() {
    return <scene/>
  }
}"
/* Script to implement a interface concept for different types of game classes */,"import * as DCL from 'decentraland-api'


// Enum for the game
export enum Game {
   tag,
   cards,
 }

// create an interface IState
export interface IState {
   // define the properties of the interface
   // the properties are the same as the properties of the state object
   // in the game class
   game: Game;
}

export default class GameScene extends DCL.ScriptableScene<any, IState>{
   render(props: any, state: IState): Promise<DCL.ISimplifiedNode> {
      throw new Error('Method not implemented.');
   }
   state: IState = {
     game: Game.cards,
   }
 
}"
/*Script to create a custom animation*/,"// Create a custom animation using the entity.addComponent() function to add an animation component to an entity, and then use the animation.play() function to play the animation.


// Create a new entity
const entity = new Entity();
entity.addComponent(new GLTFShape('models/MyModel.glb'));
entity.addComponent(new Transform({
   position: new Vector3(8, 0, 8)
}));

// Add the entity to the engine
engine.addEntity(entity);

// Create an animator
const animator = new Animator();

// Create a custom animation
const animation = new AnimationState('MyAnimation');
animation.looping = true;
animation.playing = true;
animation.speed = 0.5;
animator.addClip(animation);

// Add the animator to the entity
entity.addComponent(animator);"
/* Script to add customizable options to a player menu */,"// import menu class
import { Menu } from ""./menu"";

// create a customize player menu
const playerMenu = new Menu(""Player"", ""Customize your player"");

// add a menu item
playerMenu.addItem(""Name"", ""Change your name"");

// add a menu item
playerMenu.addItem(""Color"", ""Change your color"");

// add a menu item
playerMenu.addItem(""Hat"", ""Change your hat"");

// add a menu item
playerMenu.addItem(""Shirt"", ""Change your shirt"");

// add a menu item
playerMenu.addItem(""Pants"", ""Change your pants"");

// add a menu item
playerMenu.addItem(""Shoes"", ""Change your shoes"");

// add a menu item
playerMenu.addItem(""Back"", ""Go back to the main menu"");

// add a menu item
playerMenu.addItem(""Exit"", ""Exit the game"");

// add a menu item
playerMenu.addItem(""Quit"", ""Quit the game"");


// create a customize player menu
const mainMenu = new Menu(""Main"", ""Main menu"");

// add a menu item
mainMenu.addItem(""Player"", ""Customize your player"");

// add a menu item
mainMenu.addItem(""Exit"", ""Exit the game"");

// add a menu item
mainMenu.addItem(""Quit"", ""Quit the game"");


// create a game class
class Game {
      // create a menu property
      menu: Menu;
   
      // create a constructor
      constructor() {
         // set the menu property to the main menu
         this.menu = mainMenu;
      }
   
      // create a start method
      start() {
         // create a loop
         while (true) {
               // clear the console
               console.clear();
   
               // display the menu
               this.menu.display();
   
               // get the user's choice
               const choice = this.menu.getChoice();
   
               // if the user chose to exit the game
               if (choice === ""Exit"") {
                  // exit the game
                  return;
               }
   
               // if the user chose to quit the game
               if (choice === ""Quit"") {
                  // quit the game
                  process.exit(0);
               }
   
               // if the user chose to customize their player
               if (choice === ""Player"") {
                  // set the menu property to the player menu
                  this.menu = playerMenu;
               }
   
               // if the user chose to go back to the main menu
               if (choice === ""Back"") {
                  // set the menu property to the main menu
                  this.menu = mainMenu;
               }
         }
      }
   }
   "
"/* Script that creates a bouncing ball entity that bounces off walls, needs models/ball.glb */","// import utils
import * as utils from '@dcl/ecs-scene-utils'

// create a ball entity
const ball = new Entity()
ball.addComponent(new GLTFShape('models/ball.glb'))
ball.addComponent(new Transform({
  position: new Vector3(8, 0, 8)
}))

// add a physics component to the ball
const ballBox = new utils.TriggerBoxShape(new Vector3(0.5, 0.5, 0.5), new Vector3(0, 0.25, 0))
ball.addComponent(new utils.PhysicsComponent({
  mass: 1,
  shape: ballBox,
  friction: 0.2,
  restitution: 0.7,
}))

// add a movement component to the ball
const ballMovement = new utils.MoveTransformComponent(Vector3.Forward(), 5)
ball.addComponent(ballMovement)
"
/* Script for a menu class that outlines a classic menu */,"// create a menu class
class Menu {
   // create a title property
   title: string;

   // create a description property
   description: string;

   // create a items property
   items: string[];

   // create a constructor
   constructor(title: string, description: string) {
      // set the title property
      this.title = title;

      // set the description property
      this.description = description;

      // initialize the items property
      this.items = [];
   }

   // create an addItem method
   addItem(item: string, description: string) {
      // add the item to the items property
      this.items.push(item);
   }

   // create a display method
   display() {
      // display the title
      console.log(this.title);

      // display the description
      console.log(this.description);

      // display the items
      for (let i = 0; i < this.items.length; i++) {
         // display the item
         console.log(`${i + 1}. ${this.items[i]}`);
      }
   }

   // create a getChoice method
   getChoice() {
      // get the user's choice
      const choice = prompt(""Enter your choice: "");

      // return the user's choice
      return this.items[parseInt(choice) - 1];
   }
}


// create a prompt function
function prompt(message: string) {
   // display the message
   log(message);

   // return the user's input
   return process.stdin.readlineSync();
}"
/* Script for a class that opens a present */,"// create a class for opening a present
class OpenPresent {
   // create a method to open a present
   open() {
      // create a variable to store the present
      let present = new Present();
      // open the present
      present.open();
   }
}
// create a class for a present
class Present {
   // create a method to open a present
   open() {
      // open the present
      console.log(""You opened a present!"");
   }
}
// create a class for a game
class Game {
   // create a method to start a game
   start() {
      // create a variable to store the present
      let present = new OpenPresent();
      // open the present
      present.open();
   }
}
// create a variable to store the game
let game = new Game();
// start the game
game.start();

"
/* Script for wind affect on an avatar */,"// create an instance of wind affect on player

// import Wind class
import { Wind } from './wind';

// create a new instance of wind
var wind = new Wind();

// add wind to the game
engine.addEntity(wind);

// function for wind affect on player
function windAffect() {
   // get player
   var player = engine.entities[0];
   // get wind
   var wind = engine.entities[1];
   // get wind direction
   var windDirection = wind.getDirection();
   // get wind speed
   var windSpeed = wind.getSpeed();
   // get player speed
   var playerSpeed = player.getSpeed();
   // get player direction
   var playerDirection = player.getDirection();
   // get player position
   var playerPosition = player.getPosition();
   // get wind position
   var windPosition = wind.getPosition();
   // get distance between player and wind
   var distance = Math.sqrt(Math.pow(playerPosition.x - windPosition.x, 2) + Math.pow(playerPosition.y - windPosition.y, 2));
   // if player is close to wind
   if (distance < 100) {
      // if wind is blowing left
      if (windDirection == 0) {
         // if player is moving left
         if (playerDirection == 0) {
            // increase player speed
            player.setSpeed(playerSpeed + windSpeed);
         }
         // if player is moving right
         else if (playerDirection == 1) {
            // decrease player speed
            player.setSpeed(playerSpeed - windSpeed);
         }
      }
      // if wind is blowing right
      else if (windDirection == 1) {
         // if player is moving left
         if (playerDirection == 0) {
            // decrease player speed
            player.setSpeed(playerSpeed - windSpeed);
         }
         // if player is moving right
         else if (playerDirection == 1) {
            // increase player speed
            player.setSpeed(playerSpeed + windSpeed);
         }
      }
   }
}
"
/* A script to create a class for a kitchen */,"// create class for handeling a kitchen in decentraland
class Kitchen {
   // create a variable for the kitchen
   kitchen: Entity

   // create a constructor for the kitchen
   constructor() {
      // create a new kitchen
      this.kitchen = new Entity()
      // set the position of the kitchen
      this.kitchen.addComponent(new Transform({
         position: new Vector3(8, 0, 8)
      }))
      // add the model of the kitchen
      this.kitchen.addComponent(new GLTFShape(""models/kitchen.glb""))
      // add the kitchen to the engine
      engine.addEntity(this.kitchen)
   }

   // create a function for the kitchen
   kitchenFunction() {
      // log the kitchen
      log(""kitchen"")
   }

   // create a function for handeling food orders
   foodOrder() {
      // log food order
      log(""food order"")
   }
}"
/* A script to create a class for a music catalogue */,"// create a class for handling a music catalog in decentraland sdk
// import the Music class
import { Music } from './music'

class MusicCatalog {
   // variable for storing the catalog
   catalog: Music[]
   // constructor for initializing the catalog
   constructor() {
      this.catalog = []
   }

   // define a method for adding a music to the catalog
   addMusic(music: Music) {
      this.catalog.push(music)
   }

   // define a method for getting a music from the catalog
   getMusic(index: number) {
      return this.catalog[index]
   }
}
"
/* current gas limit (in ETH) */,"import { getGasLimit } from ""eth-connect""
import * as EthereumController from ""@decentraland/EthereumController""

let eth = EthereumController

function getGasLimit() {
  executeTask(async () => {
    const gasLimit = await getGasLimit(eth)
    log(`Current gas limit: ${gasLimit.toString()}`)
  })
}

getGasLimit()"
/* Script to implement a class for music */,"// create a class for music in decentraland
class Music {
   // create a variable for the audio
   audio: AudioClip
   // create a variable for the audio source
   source: AudioSource

   // create a constructor for the class
   constructor() {
      // create a variable for the audio
      this.audio = new AudioClip('sounds/ambient.mp3')
      // create a variable for the audio source
      this.source = new AudioSource(this.audio)
      // set the volume of the audio source
      this.source.volume = 0.5
      // set the loop of the audio source
      this.source.loop = true
      // play the audio source
      this.source.playing = true
   }
}"
/* Script for async/await functionality */,"// an example for asycn/await functions


export async function main() {
   log('Hello world!')
}

// call the async function and put it in a variable
const mainPromise = main()
   .then(() => log('done'))
   .catch(err => log(err))



"
/* Script to remove an entity with a delay */,"// script to delay removing an entity with ExpireIn

import * as utils from '@dcl/ecs-scene-utils'

export class ExpireIn extends Entity {
   constructor(model: GLTFShape, transform: TranformConstructorArgs, delay: number) {
      super()
      engine.addEntity(this)
      this.addComponent(model)
      this.addComponent(new Transform(transform))
      this.addComponent(new utils.ExpireIn(500))
   }
}"
/* Script that adds an interval component to an entity to execute the sme function every nth millisecond */,"// Add an Interval component to an entity to make it execute a same function every n milliseconds.
// This example creates an entity that changes its scale to a random size every 500 milliseconds.

import * as utils from '@dcl/ecs-scene-utils'

const entity = new Entity()
entity.addComponent(new GLTFShape('models/Tree.glb'))
entity.addComponent(new Transform({ position: new Vector3(8, 0, 8) }))

// add a repeated function
entity.addComponent(
   new utils.Interval(500, () => {
      let randomSize = Math.random()
      entity.getComponent(Transform).scale.setAll(randomSize)
   })
)

engine.addEntity(entity)

"
/* Script to set a custom shape for a player */,"// set a custom shape for a player in decentraland

import * as utils from '@dcl/ecs-scene-utils'

utils.TriggerSystem.instance.setCameraTriggerShape(
   new utils.TriggerBoxShape(
     new Vector3(0.5, 1.8, 0.5),
     new Vector3(0, -0.91, 0)
   )
 )"
/* Script to combine toggle with translate to move an entity between two locations */,"// This example combines a toggle component with a move component to switch an entity between two positions every time itâ€™s clicked in decenentraland

import * as utils from '@dcl/ecs-scene-utils'

// Create a new entity
const entity = new Entity()

// Add a transform component to the entity
entity.addComponent(new Transform({
   position: new Vector3(8, 0, 8)
}))

// Add a box shape to the entity
entity.addComponent(new BoxShape())

//toggle for wine bottle
entity.addComponent(
   new utils.ToggleComponent(utils.ToggleState.Off, value => {
      if (value == utils.ToggleState.On) {
         // Add a move component to the entity
         entity.addComponent(new utils.MoveTransformComponent(
            new Vector3(8, 0, 8),
            new Vector3(8, 0, 16),
            1
         ))
      } else {
         // Add a move component to the entity
         entity.addComponent(new utils.MoveTransformComponent(
            new Vector3(8, 0, 8),
            new Vector3(8, 0, 16),
            1
         ))
      }
   })
)

//listen for click on the box and toggle it's state
entity.addComponent(
   new OnPointerDown(event => {
      entity.getComponent(utils.ToggleComponent).toggle()
   })
)

// Add entity to engine
engine.addEntity(entity)
"
"/* script for non linear changes like: Interpolation.LINEAR, Interpolation.EASEINQUAD, Interpolation.EASEOUTQUAD, Interpolation.EASEQUAD*/","// script for non linear changes like: Interpolation.LINEAR, Interpolation.EASEINQUAD, Interpolation.EASEOUTQUAD, Interpolation.EASEQUAD

import * as utils from '@dcl/ecs-scene-utils'

// Create a new entity
const entity = new Entity()
// Add a transform component to the entity
entity.addComponent(new Transform())
// Add a shape component to the entity
entity.addComponent(new BoxShape())
// Add a material component to the entity
entity.addComponent(new Material())
// Add a script component to the entity
entity.addComponent(new utils.MoveTransformComponent(new Vector3(8, 0, 8), 5, { easing: utils.Interpolation.EASEINQUAD }))
// Add the entity to the engine
engine.addEntity(entity)
"
/* Script for a tree entity to follow a curved path */,"// script for an entity folliwing a curved path using FollowCurvedPathComponent

import * as utils from '@dcl/ecs-scene-utils'

// Create an entity
let entity = new Entity()
entity.addComponent(new GLTFShape('models/Tree.glb'))
entity.addComponent(new Transform({
   position: new Vector3(1, 1, 1)
}))


// Create a path
let path = []
path[0] = new Vector3(1, 1, 1)
path[1] = new Vector3(1, 1, 15)
path[2] = new Vector3(15, 1, 15)
path[3] = new Vector3(15, 1, 1)

// Create a FollowCurvedPathComponent
entity.addComponent(new utils.FollowCurvedPathComponent(path, 1, 5))

// Add the entity to the engine
engine.addEntity(entity)


"
/* Script to create a class for a progress bar */,"// create a class for a progress bar
export class ProgressBar {
   // create a variable for the width of the progress bar
   width!: number
   // create a variable for the height of the progress bar
   height!: number
   // create a variable for the color of the progress bar
   color!: Color4

   // create withWidth function for the class
   withWidth(width: number) {
      // set the width of the progress bar
      this.width = width
      // return the progress bar
      return this
   }

   // create withHeight function for the class
   withHeight(height: number) {
      // set the height of the progress bar
      this.height = height
      // return the progress bar
      return this
   }

   // create withColor function for the class
   withColor(color: Color4) {
      // set the color of the progress bar
      this.color = color
      // return the progress bar
      return this
   }

   // create a constructor for the class
   constructor(
      // create a variable for the scene
      scene: Engine,
      // create a variable for the position
      position: Vector3,
      // create a variable for the color
      color: Color4,
      // create a variable for the width
      width: number,
      // create a variable for the height
      height: number,
      // create a variable for the value
      value: number
   ) {
      // create a variable for the progress bar
      const progressBar = new Entity()
      // set the position of the progress bar
      progressBar.addComponent(new Transform({ position }))
      // create a variable for the progress bar shape
      const progressBarShape = new PlaneShape()
      // set the width of the progress bar shape
      progressBarShape.withWidth(width)
      // set the height of the progress bar shape
      progressBarShape.withHeight(height)
      // set the color of the progress bar shape
      progressBarShape.withColor(color)
      // add the progress bar shape to the progress bar
      progressBar.addComponent(progressBarShape)
      // add the progress bar to the scene
      scene.addEntity(progressBar)
      // create a variable for the progress bar value
      const progressBarValue = new Entity()
      // set the position of the progress bar value
      progressBarValue.addComponent(new Transform({ position }))
      // create a variable for the progress bar value shape
      const progressBarValueShape = new PlaneShape()
      // set the width of the progress bar value shape
      progressBarValueShape.withWidth(width * value)
      // set the height of the progress bar value shape
      progressBarValueShape.withHeight(height)
      // set the color of the progress bar value shape
      progressBarValueShape.withColor(Color4.Green())
      // add the progress bar value shape to the progress bar value
      progressBarValue.addComponent(progressBarValueShape)
      // add the progress bar value to the scene
      scene.addEntity(progressBarValue)
   }
}
"
/* Script to send HTTP requests to an API */,"// script to send requests in the decentraland sdk

import * as utils from '@dcl/ecs-scene-utils'

async function request() {
   let response = await utils.sendRequest(
      'https://events.decentraland.org/api/events/?limit=5'
   )

   log(response)
}


"
/* Script for rotating the world from the view of the player*/,"// script for world rotation 
import { getEntityWorldRotation } from ""@dcl/ecs-scene-utils""

const world = new Entity()
world.addComponent(new Transform({ position: new Vector3(0, 0, 1) }))
world.addComponent(new BoxShape())
engine.addEntity(world)
world.setParent(Attachable.FIRST_PERSON_CAMERA)

world.addComponent(
  new OnPointerDown(() => {
        log(getEntityWorldRotation(world))
  })"
"/* Script for organizing low, medium, and high value currency for a player */","// script for organizing currency for a player

import Currency from './currency'

export default class Game {
   private currency: Currency

   constructor() {
      this.currency = new Currency()
   }


   // function to organize three types of currency
   organizeCurrency() {
      // create an array for lowValueCurrency, mediumValueCurrency, and highValueCurrency
      const lowValueCurrency = []
      const mediumValueCurrency = []
      const highValueCurrency = []

      this.currency.map((currency: number) => currency.value === 1 ? lowValueCurrency.push(currency.value) : currency.value === 5 ? mediumValueCurrency.push(currency.value) : highValueCurrency.push(currency.value))
   }

}

"
/* Script to create a class to keep track of a player score */,"// create class for keeping track of a player's score

export class Score {
   // create a text entity to display the score
   text = new UIText(this.entity)
   // create a variable to keep track of the score
   value = 0

   constructor(public entity: Entity) {
      // set the text entity's position
      this.text.vAlign = 'center'
      this.text.hAlign = 'center'
      this.text.positionY = 0.5
      this.text.positionX = 0.5
      // set the text entity's font size
      this.text.fontSize = 100
      // set the text entity's text to the player's score
      this.text.value = this.value.toString()
   }

   // create a method to add to the player's score
   add() {
      // increment the score
      this.value++
      // set the text entity's text to the player's score
      this.text.value = this.value.toString()
   }
}"
/* Script to create a class for a virtual art gallery */,"// create a class for a virtual art gallery
export class ArtGallery extends Entity {
   position!: Vector3
   // create a constructor for the art gallery
   constructor() {
      // call the constructor of the Entity class
      super()
      // set the position of the art gallery
      this.position.set(8, 0, 8)
      // create a new box shape
      const shape = new BoxShape()
      // create a new material
      const material = new Material()
      // set the color of the material
      material.albedoColor = Color3.White()
      // create a new entity
      const gallery = new Entity()
      // set the position of the gallery
      gallery.position.set(0, 0, 0)
      // set the shape of the gallery
      gallery.addComponent(shape)
      // set the material of the gallery
      gallery.addComponent(material)
      // set the parent of the gallery
      gallery.setParent(this)
   }
}"
/* Script for handeling the physics for a cape */,"// create a class in decentraland with three.js for a cape 
export class Cape extends Entity {
   // create a class in decentraland with three.js for a cape
   constructor() {
      super()
      // create a class in decentraland with three.js for a cape
      engine.addEntity(this)
      // create a class in decentraland with three.js for a cape
      this.addComponent(new GLTFShape('models/Cape.glb'))
      // create a class in decentraland with three.js for a cape
      this.addComponent(new Transform({
         position: new Vector3(8, 0, 8),
         scale: new Vector3(0.5, 0.5, 0.5)
      }))
      // create a class in decentraland with three.js for a cape
      this.addComponent(new OnPointerDown(e => {
         // create a class in decentraland with three.js for a cape
         log('cape clicked')
      }))
   }
   }"
/* Script for class and function construction for a wildlife simulator *.,"// Create a wildlife simulator with different animals and habitats.

// Create a class for animals
class Animal {
   name: string;
   habitat: string;
   constructor(name: string, habitat: string) {
      this.name = name;
      this.habitat = habitat;
   }
}

// Create a class for habitats
class Habitat {
   name: string;
   constructor(name: string) {
      this.name = name;
   }
}

// Create a class for the wildlife simulator
class WildlifeSimulator {
   animals: Animal[];
   habitats: Habitat[];
   constructor(animals: Animal[], habitats: Habitat[]) {
      this.animals = animals;
      this.habitats = habitats;
   }
}

// Create a function to create a new animal
function createAnimal(name: string, habitat: string): Animal {
   return new Animal(name, habitat);
}

// Create a function to create a new habitat
function createHabitat(name: string): Habitat {
   return new Habitat(name);
}

// Create a function to create a new wildlife simulator
function createWildlifeSimulator(animals: Animal[], habitats: Habitat[]): WildlifeSimulator {
   return new WildlifeSimulator(animals, habitats);
}

// Create a function to add an animal to the wildlife simulator
function addAnimal(wildlifeSimulator: WildlifeSimulator, animal: Animal): void {
   wildlifeSimulator.animals.push(animal);
}

// Create a function to add a habitat to the wildlife simulator
function addHabitat(wildlifeSimulator: WildlifeSimulator, habitat: Habitat): void {
   wildlifeSimulator.habitats.push(habitat);
}

// Create a function to remove an animal from the wildlife simulator
function removeAnimal(wildlifeSimulator: WildlifeSimulator, animal: Animal): void {
   wildlifeSimulator.animals = wildlifeSimulator.animals.filter(a => a.name !== animal.name);
}

// Create a function to remove a habitat from the wildlife simulator
function removeHabitat(wildlifeSimulator: WildlifeSimulator, habitat: Habitat): void {
   wildlifeSimulator.habitats = wildlifeSimulator.habitats.filter(h => h.name !== habitat.name);
}

// Create a function to get all animals in a habitat
function getAnimalsInHabitat(wildlifeSimulator: WildlifeSimulator, habitat: Habitat): Animal[] {
   return wildlifeSimulator.animals.filter(a => a.habitat === habitat.name);
}

// Create a function to get all habitats an animal lives in
function getHabitatsForAnimal(wildlifeSimulator: WildlifeSimulator, animal: Animal): Habitat[] {
   return wildlifeSimulator.habitats.filter(h => h.name === animal.habitat);
}


// Create a function to print the wildlife simulator
function printWildlifeSimulator(wildlifeSimulator: WildlifeSimulator): void {
   console.log(""Animals:"");
   wildlifeSimulator.animals.forEach(a => console.log(a.name));
   console.log(""Habitats:"");
   wildlifeSimulator.habitats.forEach(h => console.log(h.name));
}


// Create a function to run the wildlife simulator
function runWildlifeSimulator(): void {
   // Create a new wildlife simulator
   const wildlifeSimulator = createWildlifeSimulator([], []);

   // Create a new habitat
   const habitat = createHabitat(""Forest"");

   // Create a new animal
   const animal = createAnimal(""Fox"", ""Forest"");

   // Add the habitat and animal to the wildlife simulator
   addHabitat(wildlifeSimulator, habitat);
   addAnimal(wildlifeSimulator, animal);

   // Print the wildlife simulator
   printWildlifeSimulator(wildlifeSimulator);
}

// Run the wildlife simulator
runWildlifeSimulator();

// Output:
// Animals:
// Fox
// Habitats:
// Forest





















"
"/* Script for a puzzler platformer class needing the imports of player, ground, goal, puzzle, camera, and light */","// Create a decentraland puzzle platformer with physics-based puzzle mechanics
// import player
import { Player } from './player'
import { Ground } from './ground'
import { Goal } from './goal'
import { Puzzle } from './puzzle'
import { Camera } from './camera'
import { Light } from './light'

// Class for the Puzzle Platformer
class PuzzlePlatformer {
   scene: Entity
   // Player
   player: Player
   // Ground
   ground: Ground
   // Goal
   goal: Goal
   // Puzzle
   puzzle: Puzzle
   // Camera
   camera: Camera
   // Light
   light: Light

   // Create a new puzzle platformer
   constructor() {
      // Create a new scene
      this.scene = new Entity()
      this.scene.addComponent(new Transform())
      engine.addEntity(this.scene)

      // Create the player
      this.player = new Player()
      this.scene.addComponent(this.player)

      // Create the ground
      this.ground = new Ground()
      this.scene.addComponent(this.ground)

      // Create the goal
      this.goal = new Goal()
      this.scene.addComponent(this.goal)

      // Create the puzzle
      this.puzzle = new Puzzle()
      this.scene.addComponent(this.puzzle)

      // Create the camera
      this.camera = new Camera()
      this.scene.addComponent(this.camera)

      // Create the light
      this.light = new Light()
      this.scene.addComponent(this.light)
   }

   // Update the puzzle platformer
   update() {
      // Update the player
      this.player.update()

      // Update the puzzle
      this.puzzle.update()

      // Update the camera
      this.camera.update(this.player)
   }

   // Destroy the puzzle platformer
   destroy() {
      // Destroy the player
      this.player.destroy()

      // Destroy the ground
      this.ground.destroy()

      // Destroy the goal
      this.goal.destroy()

      // Destroy the puzzle
      this.puzzle.destroy()

      // Destroy the camera
      this.camera.destroy()

      // Destroy the light
      this.light.destroy()

      // Destroy the scene
      engine.removeEntity(this.scene)
   }

   // Reset the puzzle platformer
   reset() {
      // Reset the player
      this.player.reset()

      // Reset the puzzle
      this.puzzle.reset()
   }

   // Get the player
   getPlayer() {
      return this.player
   }

   // Get the puzzle
   getPuzzle() {
      return this.puzzle
   }

   // Get the goal
   getGoal() {
      return this.goal
   }

}"
/* Script for checking if ETH is valid */,"import { isAddress } from ""eth-connect""

function isValidAddress(address: string) {
  const valid = isAddress(address)
  if (valid) {
    log(`${address} is a valid Ethereum address`)
  } else {
    log(`${address} is not a valid Ethereum address`)
  }
}

isValidAddress(""0x1234567890abcdef1234567890abcdef12345678"")"
/* Script to create a city tour guide with interactive landmarks and information */,"// Create a decentraland city tour guide with interactive landmarks and information


// Create a new Decentraland Interface
const canvas = new UICanvas()

// Create a new TextShape to display the name of the landmark
const text = new UIText(canvas)
text.value = ""Welcome to Decentraland!""
text.fontSize = 24
text.color = Color4.White()
text.hTextAlign = ""center""
text.vTextAlign = ""center""
text.positionY = 220

// Create a new ImageShape to display the image of the landmark
const image = new UIImage(canvas, new Texture(""images/landmark.png""))
image.width = ""200px""
image.height = ""200px""
image.positionY = 100

// Create a new TextShape to display the description of the landmark
const description = new UIText(canvas)
description.value = ""This is the Decentraland landmark""
description.fontSize = 16
description.color = Color4.White()
description.hTextAlign = ""center""
description.vTextAlign = ""center""
description.positionY = 50

// Create a new TextShape to display the name of the landmark
const button = new UIButton(canvas)
button.width = ""200px""
button.height = ""50px""
button.positionY = -100
button.text = ""Next Landmark""
button.fontSize = 16
button.color = Color4.White()
button.hAlign = ""center""
button.vAlign = ""center""


// Create a new Transform to hold the position of the landmark
const transform = new Transform({
   position: new Vector3(8, 0, 8)
})

// Create a new Entity with the transform and the shape
const landmark = new Entity()
landmark.addComponentOrReplace(transform)
landmark.addComponentOrReplace(image)
landmark.addComponentOrReplace(text)
landmark.addComponentOrReplace(description)
landmark.addComponentOrReplace(button)

// Add the entity to the engine
engine.addEntity(landmark)


"
/* Script for a multiple choice quiz game */,"// Create a decentraland quiz game with multiple-choice questions and answers


// Create a new UI canvas
const panel = new UICanvas()

// Create a new text entity
const text = new UIText(panel)
text.value = ""Decentraland Quiz Game""
text.fontSize = 24
text.color = Color4.Black()
text.hTextAlign = ""center""
text.vTextAlign = ""center""
text.positionY = 220

// Create a new text entity
const text2 = new UIText(panel)
text2.value = ""What is Decentraland?""
text2.fontSize = 18
text2.color = Color4.Black()
text2.hTextAlign = ""center""
text2.vTextAlign = ""center""
text2.positionY = 180

// function to create all the text entities
function createTextEntity(textValue: string, positionY: number, fontSize: number, color: Color4, hTextAlign: string, vTextAlign: string) {
   const text = new UIText(panel)
   text.value = textValue
   text.fontSize = fontSize
   text.color = color
   text.hTextAlign = hTextAlign
   text.vTextAlign = vTextAlign
   text.positionY = positionY
}

// create an array questions
const questions = [
   {
      question: ""What is Decentraland?"",
      answers: [
         { answer: ""A"", text: ""A virtual world"" },
         { answer: ""B"", text: ""A virtual reality"" },
         { answer: ""C"", text: ""A virtual planet"" },
         { answer: ""D"", text: ""A virtual galaxy"" }
      ]
   }
]

const answerKey = [
   {
      question: 0,
      answer: ""A""
   },
   ...
]

// function to handle user answer selection
function handleAnswerSelection(answer: string, question: number, answerKey: any) {
   if (answer == answerKey[question].answer) {
      createTextEntity(""Correct!"", 0, 18, Color4.Green(), ""center"", ""center"")
   } else {
      createTextEntity(""Wrong!"", 0, 18, Color4.Red(), ""center"", ""center"")
   }
}












"
/* Script for a teasure hunt game with clues and puzzles */,"// Create a decentraland treasure hunt game with clues and puzzles

// Create a new treasure chest
const chest = new Entity()
chest.addComponent(new GLTFShape('models/Chest.glb'))
chest.addComponent(new Transform({
   position: new Vector3(8, 0, 8)
}))


chest.addComponent(new OnPointerDown(e => {
   openChest()
}
))

function openChest() {
   // Open the chest
   chest.addComponent(new GLTFShape('models/ChestOpen.glb'))
   // Spawn a clue
   engine.addEntity(clue)
   // Spawn a puzzle
   engine.addEntity(puzzle)
   // Spawn a key
   engine.addEntity(key)
   // Spawn a door
   engine.addEntity(door)
}


// Create a new clue
const clue = new Entity()
clue.addComponent(new GLTFShape('models/Clue.glb'))
clue.addComponent(new Transform({
   position: new Vector3(8, 0, 8)
}))

// Create a new puzzle
const puzzle = new Entity()
puzzle.addComponent(new GLTFShape('models/Puzzle.glb'))
puzzle.addComponent(new Transform({
   position: new Vector3(8, 0, 8)
}))

// Create a new key
const key = new Entity()
key.addComponent(new GLTFShape('models/Key.glb'))
key.addComponent(new Transform({
   position: new Vector3(8, 0, 8)
}))

// Create a new door
const door = new Entity()
door.addComponent(new GLTFShape('models/Door.glb'))
door.addComponent(new Transform({
   position: new Vector3(8, 0, 8)
}))


engine.addEntity(chest)
"
/* Script for a tower defense game */,"// Create a decentraland tower defense game with AI-controlled enemies and tower upgrades

// create array for enemies
let enemies: Entity[] = []

// Function to create a tower
function createTower(position: Vector3, color: Color3, range: number, damage: number, attackSpeed: number, upgradeCost: number, upgradeDamage: number, upgradeRange: number, upgradeAttackSpeed: number) {
   // Create a new entity
   const tower = new Entity()
   // Set the position of the entity
   tower.addComponent(new Transform({ position }))
   // Add a box shape to the entity
   tower.addComponent(new BoxShape())
   // Add a material to the entity
   tower.addComponent(new Material())
   // Set the color of the material
   tower.getComponent(Material).albedoColor = color
   // Add a text shape to the entity
   tower.addComponent(new TextShape(`Range: ${range}`))
}

// Function to create an enemy
function createEnemy(position: Vector3, color: Color3, health: number, speed: number) {
   // Create a new entity
   const enemy = new Entity()
   // Set the position of the entity
   enemy.addComponent(new Transform({ position }))
   // Add a box shape to the entity
   enemy.addComponent(new BoxShape())
   // Add a material to the entity
   enemy.addComponent(new Material())
   // Set the color of the material
   enemy.getComponent(Material).albedoColor = color
}

// Function to create a path
function createPath(position: Vector3, color: Color3, length: number, width: number) {
   // Create a new entity
   const path = new Entity()
   // Set the position of the entity
   path.addComponent(new Transform({ position }))
   // Add a box shape to the entity
   path.addComponent(new BoxShape())
   // Add a material to the entity
   path.addComponent(new Material())
   // Set the color of the material
   path.getComponent(Material).albedoColor = color
}

// Function to create a base
function createBase(position: Vector3, color: Color3, health: number) {
   // Create a new entity
   const base = new Entity()
   // Set the position of the entity
   base.addComponent(new Transform({ position }))
   // Add a box shape to the entity
   base.addComponent(new BoxShape())
   // Add a material to the entity
   base.addComponent(new Material())
   // Set the color of the material
   base.getComponent(Material).albedoColor = color
}

// Function to create a wall
function createWall(position: Vector3, color: Color3, health: number) {
   // Create a new entity
   const wall = new Entity()
   // Set the position of the entity
   wall.addComponent(new Transform({ position }))
   // Add a box shape to the entity
   wall.addComponent(new BoxShape())
   // Add a material to the entity
   wall.addComponent(new Material())
   // Set the color of the material
   wall.getComponent(Material).albedoColor = color
}

// Function to create a coin
function createCoin(position: Vector3, color: Color3, value: number) {
   // Create a new entity
   const coin = new Entity()
   // Set the position of the entity
   coin.addComponent(new Transform({ position }))
   // Add a box shape to the entity
   coin.addComponent(new BoxShape())
   // Add a material to the entity
   coin.addComponent(new Material())
   // Set the color of the material
   coin.getComponent(Material).albedoColor = color
}

// Function to handle automated enemy movement
function handleEnemyMovement() {
   // Loop through all enemies
   for (let i = 0; i < enemies.length; i++) {
      // Get the current enemy
      const enemy = enemies[i]
      // Get the current enemy's transform
      const enemyTransform = enemy.getComponent(Transform)
      // Get the current enemy's position
      const enemyPosition = enemyTransform.position
      // Get the current enemy's speed
      const enemySpeed = enemy.speed
      // Get the current enemy's path
      const enemyPath = enemy.path
      // Get the current enemy's path index
      const enemyPathIndex = enemy.pathIndex
      // Get the current enemy's path position
      const enemyPathPosition = enemyPath[enemyPathIndex]
      // Get the current enemy's path position's x coordinate
      const enemyPathPositionX = enemyPathPosition.x
      // Get the current enemy's path position's y coordinate
      const enemyPathPositionY = enemyPathPosition.y
      // Get the current enemy's path position's z coordinate
      const enemyPathPositionZ = enemyPathPosition.z
      // Get the current enemy's path position's vector
      const enemyPathPositionVector = new Vector3(enemyPathPositionX, enemyPathPositionY, enemyPathPositionZ)
      // Get the current enemy's distance to the next path position
      const enemyDistanceToPathPosition = Vector3.Distance(enemyPosition, enemyPathPositionVector)
      // If the current enemy's distance to the next path position is less than the current enemy's speed
      if (enemyDistanceToPathPosition < enemySpeed) {
         // Set the current enemy's position to the next path position
         enemyTransform.position = enemyPathPositionVector
         // Increment the current enemy's path index
         enemy.pathIndex++
      } else {
         // Get the current enemy's path position's vector
         const enemyPathPositionVector = new Vector3(enemyPathPositionX, enemyPathPositionY, enemyPathPositionZ)
         // Get the current enemy's direction to the next path position
         const enemyDirectionToPathPosition = Vector3.Normalize(Vector3.Subtract(enemyPathPositionVector, enemyPosition))
         // Get the current enemy's movement vector
         const enemyMovementVector = Vector3.Multiply(enemyDirectionToPathPosition, enemySpeed)
         // Set the current enemy's position to the next path position
         enemyTransform.position = Vector3.Add(enemyPosition, enemyMovementVector)

      }
   }
}
"
"/* Script for intializing a chat room, needs chatmessage import */","// Create a decentraland chat room
// import the chat message class
import { ChatMessage } from './ChatMessage'

// chat class
class Chat {
   // define chat
   chat: ChatMessage

   // create a new chat room
   constructor() {
      this.chat = new ChatMessage()
   }

   // send a message to the chat room
   send(message: string) {
      this.chat.message = message
      this.chat.send()
   }

   // get the messages from the chat room
   getMessages() {
      return this.chat.getMessages()
   }

   // post messages to the chat room
   postMessages() {
      this.chat.postMessages()
   }
   
}"
/* Script where user can change the opacity of a box */,"// create a box that the user can set the transparency of

const canvas = new UICanvas()

const rect = new UIContainerRect(canvas)
rect.width = ""100%""
rect.height = ""100%""
rect.color = Color4.Blue()
rect.opacity = 0.5

// create a text entity that will display the current transparency
const text = new TextShape(`Transparency: ${rect.opacity}`)
text.fontSize = 3
text.color = Color3.White()
text.width = 6
text.height = 2
text.hTextAlign = 'center'
text.vTextAlign = 'center'

// create a transparent entity that will display the box
const transparentEntity = new Entity()
transparentEntity.addComponent(rect)
transparentEntity.addComponent(text)
transparentEntity.addComponent(new Transform({
   position: new Vector3(8, 1, 8)
}))
engine.addEntity(transparentEntity)

// create a slider that will control the transparency of the box
const slider = new UIInputText(canvas)
slider.width = 6
slider.height = 0.2
slider.onChange(updateInput)


function updateInput() {
   rect.opacity = parseFloat(slider.value)
   text.value = `Transparency: ${rect.opacity}`
}
"
/* Script to set up a show */,"import * as showMgmt from '@dcl/show-management'
import { ShowDataType, ShowType } from '@dcl/show-management'

const defaultShow: ShowType = {
   id: -1,
   title: ""Intermission"",
   artist: ""Artist Name"",
   startTime: -1,
   length: 17,
   loop: true //if the video should loop when over
   ,
   link: ''
}

const showData: ShowDataType = {
   defaultShow: defaultShow,
   shows: [
      {
         id: -1, //
         title: ""Title"",//the title of the show
         artist: ""Artist Name"", //name of the artist
         link: `videos/tunnelVisuals.mp4`, //link to the video, can be internal or external
         startTime: 1652117754, //UTC time in seconds for which a show will start
         length: 17, //length of video in seconds
         loop: false //if the video should loop when over
      }
   ]
}"
"/* Script to create a building when a player clicks the groud, needs player and building imports */","// when a player clicks the ground, add a building
// import the player class
import { Player } from ""./player"";
import { Building } from ""./building"";

// create a player 
var player = new Player();

// if the player has enough money
function onGroundClick() {
      if (player.money >= 100) {
         player.money -= 100;
         player.buildings.push(new Building());
      }
   }



"
/* Script to create a bundle of balloons that move when wind touches them */,"

// create array of ballon enities
const balloons: Entity[] = []

// create a balloon entity
const balloon = new Entity()
balloon.addComponent(new GLTFShape('models/balloon.glb'))
balloon.addComponent(new Transform({ position: new Vector3(8, 0, 8) }))
engine.addEntity(balloon)
balloons.push(balloon)

// function to create new bundle of balloons
function createBalloons() {
   // create a new balloon entity
   const balloon = new Entity()
   balloon.addComponent(new GLTFShape('models/balloon.glb'))
   balloon.addComponent(new Transform({ position: new Vector3(8, 0, 8) }))
   engine.addEntity(balloon)
   balloons.push(balloon)
}

// function to move balloons when wind blows
function moveBalloons() {
   // loop through balloons
   for (let i = 0; i < balloons.length; i++) {
      // get balloon position
      const position = balloons[i].getComponent(Transform).position
      // move balloon
      balloons[i].getComponent(Transform).position = new Vector3(
         position.x + Math.random() * 0.1 - 0.05,
         position.y + Math.random() * 0.1 - 0.05,
         position.z + Math.random() * 0.1 - 0.05
      )
   }
}
"
/* Script to create a UI canvas and add text */,"
// create canvas
const canvas = new UICanvas()
// create container inside canvas
const rect = new UIContainerRect(canvas)
rect.hAlign = 'left'
rect.vAlign = 'top'
rect.opacity = 0.8

// create text
const text = new UIText(rect)
text.value = 'Hello World!'
text.fontSize = 24
text.hAlign = 'left'
text.vAlign = 'top'
text.positionX = 10
text.positionY = 10"
/* Script for creating a static image in the UI canvas */,"// create canvas
const canvas = new UICanvas()
// create container inside canvas
const rect = new UIContainerRect(canvas)
rect.hAlign = 'left'
rect.vAlign = 'top'
rect.opacity = 0.5

let texture = new Texture(...)
const image = new UIImage(rect, texture)
image.hAlign = 'left'
image.vAlign = 'top'
image.sourceLeft = 0
image.sourceTop = 0
image.sourceWidth = 1024
image.sourceHeight = 483
image.width = 1024
image.height = 512"
/* Script for incorportating a close button to a static image in the canvas */,"// create canvas
const canvas = new UICanvas()
// create container inside canvas
const rect = new UIContainerRect(canvas)
rect.hAlign = 'left'
rect.vAlign = 'top'
rect.opacity = 0.5

let texture = new Texture(...)
const image = new UIImage(rect, texture)
image.hAlign = 'left'
image.vAlign = 'top'
image.sourceLeft = 0
image.sourceTop = 0
image.sourceWidth = 1024
image.sourceHeight = 483
image.width = 1024
image.height = 512

let imgCloseBtn = new Texture(""images/UI/close.png"")
const closeBtn = new UIImage(rect, imgCloseBtn)
closeBtn.name = 'close_btn'
closeBtn.width = '50px'
closeBtn.height = '50px'
closeBtn.sourceWidth = 112
closeBtn.sourceHeight = 112
closeBtn.positionX = 953
closeBtn.positionY = -5
closeBtn.isPointerBlocker = true
closeBtn.onClick = new OnPointerDown(() => {
   log(""Close Button Clicked"")
   canvas.visible = false
})"
/* Script that groups elements of UICanvas together */,"// create canvas
const canvas = new UICanvas()
// create container inside canvas
const rect = new UIContainerRect(canvas)
rect.hAlign = 'left'
rect.vAlign = 'top'
rect.opacity = 0.5

let texture = new Texture(...)
const image = new UIImage(rect, texture)
image.hAlign = 'left'
image.vAlign = 'top'
image.sourceLeft = 0
image.sourceTop = 0
image.sourceWidth = 1024
image.sourceHeight = 483
image.width = 1024
image.height = 512

let texture1 = new Texture(...)
const image1 = new UIImage(rect, texture)
image.hAlign = 'left'
image.vAlign = 'top'
image.sourceLeft = 0
image.sourceTop = 0
image.sourceWidth = 1024
image.sourceHeight = 483
image.width = 1024
image.height = 512

let texture2 = new Texture(...)
const image2 = new UIImage(rect, texture)
image.hAlign = 'left'
image.vAlign = 'top'
image.sourceLeft = 0
image.sourceTop = 0
image.sourceWidth = 1024
image.sourceHeight = 483
image.width = 1024
image.height = 512

let imgCloseBtn = new Texture(""images/UI/close.png"")
const closeBtn = new UIImage(rect, imgCloseBtn)
closeBtn.name = 'close_btn'
closeBtn.width = '50px'
closeBtn.height = '50px'
closeBtn.sourceWidth = 112
closeBtn.sourceHeight = 112
closeBtn.positionX = 953
closeBtn.positionY = -5
closeBtn.isPointerBlocker = true
closeBtn.onClick = new OnPointerDown(() => {
   log(""Close Button Clicked"")
   canvas.visible = false
})

const imageGroup = {
   ""sun"": image,
   ""mercury"": image1,
   ""disclaimer1"": image2,
}"
/* Script to handle grouped elements in UICanvas */,"// create canvas
const canvas = new UICanvas()
// create container inside canvas
const rect = new UIContainerRect(canvas)
rect.hAlign = 'left'
rect.vAlign = 'top'
rect.opacity = 0.5

let texture = new Texture(...)
const image = new UIImage(rect, texture)
image.hAlign = 'left'
image.vAlign = 'top'
image.sourceLeft = 0
image.sourceTop = 0
image.sourceWidth = 1024
image.sourceHeight = 483
image.width = 1024
image.height = 512

let texture1 = new Texture(...)
const image1 = new UIImage(rect, texture)
image.hAlign = 'left'
image.vAlign = 'top'
image.sourceLeft = 0
image.sourceTop = 0
image.sourceWidth = 1024
image.sourceHeight = 483
image.width = 1024
image.height = 512

let texture2 = new Texture(...)
const image2 = new UIImage(rect, texture)
image.hAlign = 'left'
image.vAlign = 'top'
image.sourceLeft = 0
image.sourceTop = 0
image.sourceWidth = 1024
image.sourceHeight = 483
image.width = 1024
image.height = 512

let imgCloseBtn = new Texture(""images/UI/close.png"")
const closeBtn = new UIImage(rect, imgCloseBtn)
closeBtn.name = 'close_btn'
closeBtn.width = '50px'
closeBtn.height = '50px'
closeBtn.sourceWidth = 112
closeBtn.sourceHeight = 112
closeBtn.positionX = 953
closeBtn.positionY = -5
closeBtn.isPointerBlocker = true
closeBtn.onClick = new OnPointerDown(() => {
   log(""Close Button Clicked"")
   canvas.visible = false
})

const imageGroup = {
   ""sun"": image,
   ""mercury"": image1,
   ""disclaimer1"": image2,
}

function stateDynamicUI(bPlanetMenu: boolean, bDisclaimerMenu: boolean, bCloseMenu: boolean) {

   for (let key in imageGroup) {
      imageGroup[key].visible = bPlanetMenu
   }
}"
/* Script for creating a 3d menu */,"// parent entity
const menu3D = new Entity()
engine.addEntity(menu3D)

const menu1 = new Entity()
menu1.addComponent(new BoxShape())
menu1.addComponent(new Transform({
   position: new Vector3(8, 1.5, 8),
   scale: new Vector3(0.1, 0.25, 0.5)
}))
menu1.setParent(menu3D)
engine.addEntity(menu1)

const menu2 = new Entity()
menu2.addComponent(new BoxShape())
menu2.addComponent(new Transform({
   position: new Vector3(8, 1, 8),
   scale: new Vector3(0.1, 0.25, 0.5)
}))
menu2.setParent(menu3D)
engine.addEntity(menu2)

const menu3 = new Entity()
menu3.addComponent(new BoxShape())
menu3.addComponent(new Transform({
   position: new Vector3(8, 0.5, 8),
   scale: new Vector3(0.1, 0.25, 0.5)
}))
menu3.setParent(menu3D)
engine.addEntity(menu3)"
/* Script that creates a function to handle when a menu item is clicked from a UICanvas 3d menu */,"// parent entity
const menu3D = new Entity()
engine.addEntity(menu3D)

const menu1 = new Entity()
menu1.addComponent(new BoxShape())
menu1.addComponent(new Transform({
   position: new Vector3(8, 1.5, 8),
   scale: new Vector3(0.1, 0.25, 0.5)
}))
menu1.setParent(menu3D)
engine.addEntity(menu1)

const menu2 = new Entity()
menu2.addComponent(new BoxShape())
menu2.addComponent(new Transform({
   position: new Vector3(8, 1, 8),
   scale: new Vector3(0.1, 0.25, 0.5)
}))
menu2.setParent(menu3D)
engine.addEntity(menu2)

const menu3 = new Entity()
menu3.addComponent(new BoxShape())
menu3.addComponent(new Transform({
   position: new Vector3(8, 0.5, 8),
   scale: new Vector3(0.1, 0.25, 0.5)
}))
menu3.setParent(menu3D)
engine.addEntity(menu3)

menu1.addComponent(
   new OnPointerDown(e => {
      log(""sun CLICKED"")
}))"
/* Script for a class that allows a player to switch between items in their inventory */,"// create a class for a player to switch between items in their inventory

import { Item } from './item';

class Player {
   private inventory: Item[];
   private current: number;
   constructor() {
      this.inventory = [];
      this.current = 0;
   }
   // add an item to the inventory
   addItem(item: Item) {
      this.inventory.push(item);
   }
   // switch to the next item in the inventory
   next() {
      this.current = (this.current + 1) % this.inventory.length;
   }
   // switch to the previous item in the inventory
   previous() {
      this.current = (this.current - 1 + this.inventory.length) % this.inventory.length;
   }
   // get the current item in the inventory
   getCurrentItem() {
      return this.inventory[this.current];
   }
}"
/* Script that rotates an orb in a players hand */,"// Script that rotates an orb in a players hand

import { Player } from ""./Player"";

// This is the main function that is called when the script is run
function main() {
      // create player
      var player = new Player();

   
      // Get the orb
      var orb = player.getOrb();
   
      // Rotate the orb
      orb.rotate(0.1, 0.1, 0.1);
   
   }"
/* television from gltf */,"const television = new Entity()
television.addComponent(new GLTFShape('models/Television.gltf'))
television.addComponent(
  new Transform({
    position: new Vector3(8, 0, 10),
    rotation: Quaternion.Euler(0, 180, 0),
    scale: new Vector3(0.6, 0.6, 0.6),
  })
)
engine.addEntity(television)
"
"/* Script that creates a building entity and makes it disappear when it is clicked, needs models/building.glb */","// import utils
import * as utils from '@dcl/ecs-scene-utils'

// create a building entity
const building = new Entity()
building.addComponent(new GLTFShape('models/building.glb'))
building.addComponent(new Transform({
  position: new Vector3(8, 0, 8)
}))

// add a click listener to the building
building.addComponent(new OnClick(() => {
  engine.removeEntity(building)
}))

// add the building to the scene
engine.addEntity(building)
"
/* Script that sends a message to everyone in the scene */,"// Create a script to send a message to all other players in scene
// when the player presses the space bar
// This script is attached to the player

// Create a player
const player = new Entity()
player.addComponent(new GLTFShape(""models/Player.glb""))
player.addComponent(new Transform({ position: new Vector3(8, 0, 8) }))
engine.addEntity(player)

// define button
const button = new Entity()

// Create a new message bus
const sceneMessageBus = new MessageBus()

button.addComponent(
  new OnPointerDown((e) => {
    sceneMessageBus.emit(""Message to everyone in the scene"", {})
  })
)

"
/* Script that allows a user to accept messages from other players in a scene */,"const sceneMessageBus = new MessageBus()

sceneMessageBus.on(""spawn"", (info: NewBoxPosition) => {
  let newCube = new Entity()
  let transform = new Transform()
  transform.position.set(info.position.x, info.position.y, info.position.z)
  newCube.addComponent(transform)
  engine.addComponent(newCube)
})"
/* Script to create an authentication chain header */,"import { AuthChain } from 'dcl-crypto/dist/types'
import {
  AUTH_CHAIN_HEADER_PREFIX,
  AUTH_METADATA_HEADER,
  AUTH_TIMESTAMP_HEADER,
} from './types'

export default function createAuthChainHeaders(
  authChain: AuthChain,
  timetamp: number,
  metadata: any = {}
) {
  const headers = {} as Record<string, string>

  authChain.forEach((item: any, index: any) => {
    headers[AUTH_CHAIN_HEADER_PREFIX + index] = JSON.stringify(item)
  })

  headers[AUTH_TIMESTAMP_HEADER] = String(timetamp)
  headers[AUTH_METADATA_HEADER] = JSON.stringify(metadata)

  return headers
}

// Types file
import RequestError from './errors'

export const AUTH_CHAIN_HEADER_PREFIX = 'x-identity-auth-chain-'
export const AUTH_TIMESTAMP_HEADER = 'x-identity-timestamp'
export const AUTH_METADATA_HEADER = 'x-identity-metadata'

export const DEFAULT_CATALYST = 'https://peer-lb.decentraland.org'
export const DEFAULT_EXPIRATION = (1000 * 60) | 0
export const DEFAULT_ERROR_FORMAT = (err: RequestError) => ({
  ok: false,
  message: err.message,
})

export type DecentralandSignatureData<P extends {} = {}> = {
  auth: string
  authMetadata: P
}

export type DecentralandSignatureContext<P extends {} = {}> = {
  verification?: DecentralandSignatureData<P>
}

export type DecentralandSignatureRequiredContext<P extends {} = {}> = {
  verification: DecentralandSignatureData<P>
}

export type VerifyAuthChainHeadersOptions = {
  catalyst?: string
  expiration?: number
}

export type SessionOptions = {
  optional?: boolean
  onError?: (err: RequestError) => any
}

export type Options = VerifyAuthChainHeadersOptions & SessionOptions"
/* Script that sends mana to a wallet */,"import * as crypto from '@dcl/crypto-scene-utils'

// create a button
const button = new Entity()

let myWallet = `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`

// send dencentraland mana to a wallet
button.addComponent(new OnPointerDown(async e => {
	await crypto.mana.send(myWallet, 100, true).then(
		// open door
	)
  }
))"
/* Script to get a players balance and a specific wallet ballance */,"import * as crypto from '@dcl/crypto-scene-utils'

executeTask(async () => {
	let balance = await crypto.mana.myBalance()
	log(balance)
})

let myWallet = `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`

executeTask(async () => {
	let balance = await crypto.mana.balance(myWallet)
	log(balance)
})"
"/* Script for a button that requires sending any wearable item to the scene creator's personal wallet. The button opens a door, but only once a transaction is sent to transfer the token. */","import * as crypto from '@dcl/crypto-scene-utils'

// create button
const button = new Entity()
button.addComponent(new GLTFShape('models/button.glb'))
button.addComponent(new Transform({
   position: new Vector3(8, 0, 8),
   scale: new Vector3(0.5, 0.5, 0.5)
}))
engine.addEntity(button)

// create door
const door = new Entity()
door.addComponent(new GLTFShape('models/door.glb'))
door.addComponent(new Transform({
   position: new Vector3(8, 0, 8),
   scale: new Vector3(0.5, 0.5, 0.5)
}))
engine.addEntity(door)

// create function to open door
const openDoor = () => {
   door.addComponentOrReplace(new Transform({
      position: new Vector3(8, 0, 8),
      scale: new Vector3(0.5, 0.5, 0.5),
      rotation: Quaternion.Euler(0, 90, 0)
   }))
}



let myWallet = `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`

button.addComponent(new OnPointerDown(async e => {
   await crypto.nft.transfer(crypto.contract.mainnet.Halloween2019Collection, myWallet, 1, true).then(
      // open door
      openDoor
   )
}
))"
/* Script that checks a users wallet for a specific token and if they have the token it opens the door */,"import * as crypto from '@dcl/crypto-scene-utils'

// function to open door
export function openDoor() {
   // open door
}


// function to only open door to vip area for those that have the tokens
export function openDoorToVipArea(hasToken: boolean) {
   if (hasToken) {
      openDoor()
   }
}


executeTask(async () => {
	let hasToken = await crypto.nft.checkTokens(crypto.contract.mainnet.Halloween2019Collection, [1, 2, 3, 4, 5])
   openDoorToVipArea(hasToken)
})"
/* Script to request a player to use their secret ethereum key and sign a message*/,"import * as crypto from '@dcl/crypto-scene-utils'

executeTask(async () => {
  const message = await crypto.ethereum.signMessage('msg: this is a top secret message')
  log(`MESSAGE: `, message)
})"
/* Script to buy an item from a crypto marketplace */,"
// buy an item from the marketplace
import * as crypto from '@dcl/crypto-scene-utils'



// buy an item from the marketplace
executeTask(async () => {
   await crypto.marketplace.executeOrder(
      `0xd35147be6401dcb20811f2104c33de8e97ed6818`,
      28706,
      30
   )
})
"
/* Script to create a grid of cubes at random heights to create noise */,"import { Noise } from '@dcl/noise-utils'

// spawn cube function
function spawnCube(box: Entity, x: number, y: number, z: number) {
   const cube = new Entity()
   cube.addComponent(new BoxShape())
   cube.addComponent(new Transform({
      position: new Vector3(x, y, z),
      scale: new Vector3(1, 1, 1)
   }))
   cube.setParent(box)
}

// create box entity
const box = new Entity()
box.addComponent(new Transform({
   position: new Vector3(8, 0, 8)
}))
engine.addEntity(box)

for (var x = 0.5; x < 16; x++) {
   for (var y = 0.5; y < 16; y++) {
      let height = Noise.simplex2(x / 16, y / 16) + 1
      spawnCube(box, x, height, y)
   }
}"
/* Script to create noise using the perlin function */,"import { Noise } from '@dcl/noise-utils'

// spawn cube function
function spawnCube(box: Entity, x: number, y: number, z: number) {
   const cube = new Entity()
   cube.addComponent(new BoxShape())
   cube.addComponent(new Transform({
      position: new Vector3(x, y, z),
      scale: new Vector3(1, 1, 1)
   }))
   cube.setParent(box)
}

// create box entity
const box = new Entity()
box.addComponent(new Transform({
   position: new Vector3(8, 0, 8)
}))
engine.addEntity(box)


for (var x = 0.5; x < 16; x++) {
   for (var y = 0.5; y < 16; y++) {
      let height = Noise.perlin2(x / 16, y / 16) + 1
      spawnCube(box, x, height, y)
   }
}"
"/* Script employs a 3D simplex formula to chart the elevations of multiple cubes and animate them in an up-and-down motion over time. The first two dimensions of the formula correspond to the grid locations of each cube, while the third dimension progresses over time to create wave-like movements.*/","import { Noise } from '@dcl/noise-utils'

// --- Set up a system ---

class PerlinNoiseSystem implements ISystem {
  group: Entity[] = []
  active: boolean = false
  timer: number = 0
  update(dt: number) {
    this.timer += dt / 4

    // iterate over the entities of the group
    for (let entity of this.group) {
      // get the Transform component of the entity
      const transform = entity.getComponent(Transform)

      // set the height of the entity based on a simplex3 function, using its position on the grid and the time
      transform.position.y =
        Noise.simplex3(
          transform.position.x / 16,
          this.timer,
          transform.position.z / 16
        ) + 1
    }
  }
}

/// --- Spawner function ---
let noiseSystem = new PerlinNoiseSystem()

function spawnCube(box: Shape, x: number, y: number, z: number) {
  // create the entity
  const cube = new Entity()
  cube.addComponent(new Transform({ position: new Vector3(x, y, z) }))
  cube.addComponent(box)
  engine.addEntity(cube)

  let col = new Material()
  col.albedoColor = new Color3(x / 16, y / 16, z / 4)
  cube.addComponent(col)

  cube.addComponent(
    new OnClick(() => {
      if (!noiseSystem.active) {
        engine.addSystem(noiseSystem)
        noiseSystem.active = true
      } else {
        engine.removeSystem(noiseSystem)
        noiseSystem.active = false
      }
    })
  )

  noiseSystem.group.push(cube)

  return cube
}

/// --- Reusable box shape ---
let box = new BoxShape()

/// --- Spawn the cubes as a grid ---
for (var x = 0.5; x < 16; x++) {
  for (var y = 0.5; y < 16; y++) {
    let height = Noise.simplex3(x / 16, 0, y / 16) + 1
    spawnCube(box, x, height, y)
  }
}"
/* Script to make an npc */,"import { NPC } from '@dcl/npc-scene-utils'

// create a new NPC
const npc = new NPC(
   { position: new Vector3(10, 0.1, 10) },
   'models/RobotExpressive.glb',
   () => {
      // the voice of the NPC
      new AudioClip('sounds/voice.mp3')
   }
)"
/*Script to create a npc that faces the user */,"import { NPC } from '@dcl/npc-scene-utils'

// create a new NPC
export let npc = new NPC(
   { position: new Vector3(10, 0.1, 10) },
   'models/Robot.glb',
   () => {
      log('NPC activated!')
   },
   {
      faceUser: true,
      portrait: { path: 'images/catguy.png', height: 128, width: 128 },
      darkUI: true,
      coolDownDuration: 3,
      idleAnim: `Weight_Shift`,
      hoverText: 'CHAT',
      reactDistance: 4,
      continueOnWalkAway: true,
      onWalkAway: () => {
         log('walked away')
      }
   }
)

// add the NPC to the scene
engine.addEntity(npc)




"
/* Create an npc and have it follow a curved path */,"import { NPC } from '@dcl/npc-scene-utils'
import * as utils from '@dcl/ecs-scene-utils'

// create a new NPC
const npc = new NPC(
   { position: new Vector3(10, 0.1, 10) },
   // the model of the NPC
   'models/RobotExpressive.glb',
   () => {
      // callback function that will be called when the NPC is activated
      log('NPC activated!')
   })

// add the NPC to the scene
engine.addEntity(npc)

//Define the positions of the path
let path = []
path[0] = new Vector3(1, 1, 1)
path[1] = new Vector3(1, 1, 15)
path[2] = new Vector3(15, 1, 15)
path[3] = new Vector3(15, 1, 1)


// Move entity
npc.addComponent(new utils.FollowCurvedPathComponent(path, 5, 40))


"
/* Script that initializes an npc to follow a path */,"import { NPC } from '@dcl/npc-scene-utils'
import * as utils from '@dcl/ecs-scene-utils'

// create a new NPC
const npc = new NPC(
   { position: new Vector3(10, 0.1, 10) },
   // the model of the NPC
   'models/RobotExpressive.glb',
   () => {
      // callback function that will be called when the NPC is activated
      log('NPC activated!')
   })

// add the NPC to the scene
engine.addEntity(npc)

//Define the positions of the path
let path = []
path[0] = new Vector3(1, 1, 1)
path[1] = new Vector3(1, 1, 15)
path[2] = new Vector3(15, 1, 15)
path[3] = new Vector3(15, 1, 1)

// Move entity
npc.addComponent(new utils.FollowPathComponent(path, 2))


"
/* Script to rotate an npc from a start point to an end point */,"import { NPC } from '@dcl/npc-scene-utils'
import * as utils from '@dcl/ecs-scene-utils'

// create a new NPC
const npc = new NPC(
   { position: new Vector3(10, 0.1, 10) },
   // the model of the NPC
   'models/RobotExpressive.glb',
   () => {
      // callback function that will be called when the NPC is activated
      log('NPC activated!')
   })

// add the NPC to the scene
engine.addEntity(npc)

//Define the positions of the path
let path = []
path[0] = new Vector3(1, 1, 1)
path[1] = new Vector3(1, 1, 15)
path[2] = new Vector3(15, 1, 15)
path[3] = new Vector3(15, 1, 1)

//Define start and end directions
let StartRot = Quaternion.Euler(90, 0, 0)
let EndRot = Quaternion.Euler(270, 0, 0)

// Rotate entity
npc.addComponent(new utils.RotateTransformComponent(StartRot, EndRot, 2))


"
/* Script that creates a class for recreating npcs */,"// class to create npcs
import { NPC } from '@dcl/npc-scene-utils'

// class
export class NPCManager {
   // array of npcs
   npcs: NPC[] = []

   // function to create npc
   createNPC(position: Vector3, model: GLTFShape, animation: AnimationState, dialog: Dialog) {
      // create npc
      let npc = new NPC({ position: new Vector3(10, 0.1, 10) },
      // the model of the NPC
      'models/RobotExpressive.glb',
      () => {
         // callback function that will be called when the NPC is activated
         log('NPC activated!')
      }))

      // add npc to array
      this.npcs.push(npc)
   }
}"
/* Script for sendoing outbound links */,"const entity = new Entity()
entity.addComponent(new BoxShape())
const transform = new Transform({ position: new Vector3(4, 0, 4) })
entity.addComponent(transform)

// function to add outbound link to the entity
function addOutboundLink(entity: Entity, url: string) {
   entity.addComponent(
      new OnPointerDown(() => {
         openExternalURL(url)
      })
   )
}

engine.addEntity(entity)"
/* Script to create an access area */,"// Create an access area to block any players that don't meet the criteria from being able to enter an area.
import * as access from 'dcl-access-area'

// Create a new access area
let wall = access.createArea({
   // The position of the area
   transform: {
      position: new Vector3(8, 0, 8)
   },
   type: access.Type.NFT,
   chain: access.ChainType.ETH,
   nftType: access.NFTType.ERC721,
   debug: false,
   contract: '0x06012c8cf97BEaD5deAe237070F9587f8E7A266d',
   name: 'wall',
   deniedMessage: 'You are not allowed to enter this area',
   wallType: ""..."".BOX
})
"
/* Script that creates a trigger for increasing the scale of an npc */,"import { NPC } from '@dcl/npc-scene-utils'
import * as utils from '@dcl/ecs-scene-utils'

// create a new NPC
const npc = new NPC(
   { position: new Vector3(10, 0.1, 10) },
   // the model of the NPC
   'models/RobotExpressive.glb',
   () => {
      // callback function that will be called when the NPC is activated
      log('NPC activated!')
   })


//Define start and end positions
let StartSize = new Vector3(1, 1, 1)
let EndSize = new Vector3(0.75, 2, 0.75)

// function to change the scale of the NPC
function changeScale() {
   // Move entity
   npc.addComponent(new utils.ScaleTransformComponent(StartSize, EndSize, 2))
}

// create entity to trigger the changeScale function
const trigger = new Entity()
trigger.addComponent(new BoxShape())
trigger.addComponent(new Transform({ position: new Vector3(10, 0.1, 10) }))
trigger.addComponent(
   new utils.TriggerComponent(
      new utils.TriggerBoxShape(new Vector3(1, 1, 1), Vector3.Zero()),
      {
         onCameraEnter: changeScale,
      }
   )
)

// add the trigger to the scene
engine.addEntity(trigger)

// add the NPC to the scene
engine.addEntity(npc)


"
/* Script to have a continued rotation on a cube */,"import * as utils from '@dcl/ecs-scene-utils'

// Create entity
const box = new Entity()

// Give entity a shape and transform
box.addComponent(new BoxShape())
box.addComponent(new Transform({ position: new Vector3(8, 1, 8) }))


// Rotate entity
box.addComponent(new utils.KeepRotatingComponent(Quaternion.Euler(0, 45, 0)))

// Listen for click
box.addComponent(
  new OnPointerDown(() => {
    box.getComponent(utils.KeepRotatingComponent).stop()
  })
)

// Add entity to engine
engine.addEntity(box)"
/* Script to adjust the scale of a entity over time */,"import * as utils from '@dcl/ecs-scene-utils'

// Create entity
const box = new Entity()

// Give entity a shape and transform
box.addComponent(new BoxShape())
box.addComponent(new Transform({
   position: new Vector3(8, 1, 8)
}))

//Define start and end positions
let StartSize = new Vector3(1, 1, 1)
let EndSize = new Vector3(0.75, 2, 0.75)

// Move entity
box.addComponent(new utils.ScaleTransformComponent(StartSize, EndSize, 2))


// Add entity to engine
engine.addEntity(box)"
/* Script to toggle bewteen two different states */,"import * as utils from '@dcl/ecs-scene-utils'

// Create entity
const box = new Entity()

// Give entity a shape and transform
box.addComponent(new BoxShape())
box.addComponent(new Transform({ position: new Vector3(8, 1, 8) }))

//Define two different materials
let blueMaterial = new Material()
blueMaterial.albedoColor = Color3.Blue()
let blackMaterial = new Material()
blackMaterial.albedoColor = Color3.Black()

// Add a Toggle component
box.addComponent(
   new utils.ToggleComponent(utils.ToggleState.Off, value => {
      if (value == utils.ToggleState.On) {
         //set color to green
         box.addComponentOrReplace(blueMaterial)
      } else {
         //set color to red
         box.addComponentOrReplace(blackMaterial)
      }

      //log the state
      log(value)
   })
)

//listen for click on the box and toggle it's state
box.addComponent(
   new OnPointerDown(event => {
      box.getComponent(utils.ToggleComponent).toggle()
   })
)

// Add entity to engine
engine.addEntity(box)"
/* Script that triggers a random position for an entity when player enters a specific spot */,"import * as utils from '@dcl/ecs-scene-utils'

//create entity
const box = new Entity()

//create shape for entity and disable its collision
box.addComponent(new BoxShape())
box.getComponent(BoxShape).withCollisions = false

//set transform component with initial position
box.addComponent(new Transform({ position: new Vector3(2, 1, 2) }))

// create trigger area object, setting size and relative position
let triggerBox = new utils.TriggerBoxShape()

//create trigger for entity
box.addComponent(
  new utils.TriggerComponent(
    triggerBox, //shape
    {
      onCameraEnter : () => {
	  log('triggered!')
	  box.getComponent(Transform).position = new Vector3(
		1 + Math.random() * 14,
		0,
		1 + Math.random() * 14
	        )
      }
    }
  )
)

//add entity to engine
engine.addEntity(box)"
"/* Script that defines different layers of triggers, outlining the extent of players triggers */","import * as utils from '@dcl/ecs-scene-utils'

//define layers
const layer1 = 1
const layer2 = 2
const layer3 = 4

//define a reusable collision shape object
let triggerBox = new utils.TriggerBoxShape(Vector3.One(), Vector3.Zero())

//create resource
const resource = new Entity()
resource.addComponent(new ConeShape())
resource.getComponent(ConeShape).withCollisions = false
resource.addComponent(
  new Transform({
    position: new Vector3(1 + Math.random() * 14, 0, 1 + Math.random() * 14)
  })
)
resource.addComponent(new utils.TriggerComponent(
  triggerBox,
  {
	layer: layer1,
	triggeredByLayer: layer2 | layer3,
	onTriggerEnter: () => {
	  resource.getComponent(Transform).position = new Vector3(
	    1 + Math.random() * 14,
	    0,
	    1 + Math.random() * 14
	  )
	  player1.addComponentOrReplace(
	    new utils.MoveTransformComponent(
		player1.getComponent(Transform).position,
		resource.getComponent(Transform).position,
		4
	    )
	  )
	  player2.addComponentOrReplace(
	    new utils.MoveTransformComponent(
		player2.getComponent(Transform).position,
		resource.getComponent(Transform).position,
		4
	    )
	 )
       }
  }
))

//create player1
const player1 = new Entity()
player1.addComponent(new SphereShape())
player1.getComponent(SphereShape).withCollisions = false
player1.addComponent(
  new Transform({
    position: new Vector3(1 + Math.random() * 14, 0, 1 + Math.random() * 14),
    scale: new Vector3(0.5, 0.5, 0.5)
  })
)
player1.addComponent(new utils.TriggerComponent(
  triggerBox,
  {
	layer: layer2,
	triggeredByLayer: layer3,
	onTriggerEnter: () => {
	  player1.getComponent(Transform).position = new Vector3(
	    1 + Math.random() * 14,
	    0,
	    1 + Math.random() * 14
	  )
	  player1.addComponentOrReplace(
	    new utils.MoveTransformComponent(
	      player1.getComponent(Transform).position,
	      resource.getComponent(Transform).position,
	      4
	    )
          )
        }
  }
))

//create player2
const player2 = new Entity()
player2.addComponent(new BoxShape())
player2.getComponent(BoxShape).withCollisions = false
player2.addComponent(
  new Transform({
    position: new Vector3(1 + Math.random() * 14, 0, 1 + Math.random() * 14)
  })
)
player2.addComponent(new utils.TriggerComponent(
	triggerBox,
	{
		layer: layer3
	}
))

//set initial movement for players 1 and 2
player1.addComponentOrReplace(
  new utils.MoveTransformComponent(
    player1.getComponent(Transform).position,
    resource.getComponent(Transform).position,
    4
  )
)
player2.addComponentOrReplace(
  new utils.MoveTransformComponent(
    player2.getComponent(Transform).position,
    resource.getComponent(Transform).position,
    4
  )
)

//add entities to engine
engine.addEntity(resource)
engine.addEntity(player1)
engine.addEntity(player2)"
/* Script to add a label to an enitity and have it always facing the player */,"// import
import * as utils from '@dcl/ecs-scene-utils'

// create a new entity
const entity = new Entity()
// add a transform component to the entity
entity.addComponent(new Transform({ position: new Vector3(8, 1, 8) }))
// add a box shape to the entity
entity.addComponent(new BoxShape())


// create a label for the entity
utils.addLabel('Random Cube', entity)
new Billboard(true) // make the label face the camera"
"/* Script that creates a box that changes scale until it is clicked, then resets the scale and moves the box to another location */","import * as utils from '@dcl/ecs-scene-utils'

//set clicked flag
let boxClicked = false

//create box entity
const box = new Entity()
box.addComponent(new BoxShape())
box.addComponent(new Transform({ position: new Vector3(0, 0, 0) }))
box.addComponent(new OnPointerDown(() => (boxClicked = true)))
engine.addEntity(box)

//Use IAction to define action for scaling
class ScaleAction implements utils.ActionsSequenceSystem.IAction {
  hasFinished: boolean = false
  entity: Entity
  scale: Vector3

  constructor(entity: Entity, scale: Vector3) {
    this.entity = entity
    this.scale = scale
  }

  //Method when action starts
  onStart(): void {
    const transform = this.entity.getComponent(Transform)
    this.hasFinished = false

    this.entity.addComponentOrReplace(
      new utils.ScaleTransformComponent(
        transform.scale,
        this.scale,
        1.5,
        () => {
          this.hasFinished = true
        },
        utils.InterpolationType.EASEINQUAD
      )
    )
  }
  //Method to run on every frame
  update(dt: number): void {}
  //Method to run at the end
  onFinish(): void {}
}

//Use IAction to define action for movement
class MoveAction implements utils.ActionsSequenceSystem.IAction {
  hasFinished: boolean = false
  entity: Entity
  position: Vector3

  constructor(entity: Entity, position: Vector3) {
    this.entity = entity
    this.position = position
  }

  //Method when action starts
  onStart(): void {
    const transform = this.entity.getComponent(Transform)

    this.entity.addComponentOrReplace(
      new utils.MoveTransformComponent(
        transform.position,
        this.position,
        4,
        () => {
          this.hasFinished = true
        }
      )
    )
  }
  //Method to run on every frame
  update(dt: number): void {}
  //Method to run at the end
  onFinish(): void {}
}

//Use sequence builder to create a sequence
const sequence = new utils.ActionsSequenceSystem.SequenceBuilder()
  .while(() => !boxClicked)
  .then(new ScaleAction(box, new Vector3(1.5, 1.5, 1.5)))
  .then(new ScaleAction(box, new Vector3(0.5, 0.5, 0.5)))
  .endWhile()
  .then(new ScaleAction(box, new Vector3(1, 1, 1)))
  .then(new MoveAction(box, new Vector3(1, 0, 1)))

//Create a sequence system, and add it to the engine to run the sequence
engine.addSystem(new utils.ActionsSequenceSystem(sequence))"
/* Script for a custom shader */,"// Create a custom shader in decentraland
import three from 'three'


// Create a new entity
const entity = new Entity()

// Add a transform component to the entity
entity.addComponent(new Transform({
   position: new Vector3(8, 1, 8)
}))

// Add a box shape to the entity
entity.addComponent(new BoxShape())

// Add a material to the entity
entity.addComponent(new Material())

// Add a shader to the entity
entity.addComponent(new three.ShaderMaterial({
   uniforms: {
      uTime: { value: 0 },
      uColor: { value: new three.Color(0.5, 0.5, 0.5) }
   },
   vertexShader: `
      varying vec2 vUv;
      void main() {
         vUv = uv;
         gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
   `,
   fragmentShader: `
      uniform float uTime;
      uniform vec3 uColor;
      varying vec2 vUv;
      void main() {
         gl_FragColor = vec4(uColor, 1.0);
      }
   `
}))

// Add the entity to the engine
engine.addEntity(entity)

"
/* Script that creates a custom snowball animation and plays when the snowball object is clicked */,"// Create a decentraland throwing a snowball animation
// and a snowball object
// The animation is played when the user clicks on the snowball object

import { CameraMode } from ""@dcl/ecs""

// Create the snowball animation
const snowballAnimation = new AnimationState('snowball_throw', { looping: false })

// Create the snowball object
const snowball = new Entity()
snowball.addComponent(new GLTFShape('models/snowball.glb'))
snowball.addComponent(new Transform({ position: new Vector3(8, 0, 8) }))
engine.addEntity(snowball)

// When the user clicks on the snowball object, play the animation
snowball.addComponent(
   new OnPointerDown(() => {
       snowballAnimation.playing = true
    }
   )
)

// When the animation ends, stop it
snowballAnimation.stop = () => {
   snowballAnimation.playing = false
}

// Add the animation to the snowball object
snowball.addComponent(snowballAnimation)



"
/* Script using scalar functionality */,"// define variables
let number1 = 10
let number2 = 20
let myInput = 50

// Call functions from the Scalar class
let random = Scalar.RandomRange(1, 100)

let midPoint = Scalar.Lerp(number1, number2, 0.5)

let clampedValue = Scalar.Clamp(myInput, 0, 100)"
"/* Script to define a class for a leaderboard, needs a Table import */","// Create a decentraland leaderboard class

// create Table class
import { Table } from '@dcl/ecs-scene-utils'

class Leaderboard {
   // Create a table to store the leaderboard
   table: Table

   // Create a constructor to initialize the table
   constructor() {
      this.table = new Table('leaderboard', 'player')
   }

   // Create a method to get the top 10 players
   async getTop10Players() {
      // Get the top 10 players from the table
      const top10Players = await this.table.top(10)

      // Return the top 10 players
      return top10Players
   }

   // Create a method to add a player to the leaderboard
   async addPlayer(player: string, score: number) {
      // Add the player to the table
      await this.table.set(player, score)
   }

   // Create a method to get the player's score
   async getPlayerScore(player: string) {
      // Get the player's score from the table
      const playerScore = await this.table.get(player)

      // Return the player's score
      return playerScore
   }
}"
/* Script to create a component that makes an NPC always face a player */,"
@Component('trackUserFlag')

// This component is used to track the user and face them during interaction
export class TrackUserFlag {
   // If true, the NPC will not rotate on the X or Z axis
   lockXZRotation: boolean = false
   active: boolean = false
   rotSpeed: number

   // Constructor for the TrackUserFlag component
   constructor(lockXZRotation?: boolean, rotSpeed?: number, active?: boolean) {
      if (!faceUserAdded) {
         addFaceUserSystem()
      }

      // If true, the NPC will not rotate on the X or Z axis
      this.lockXZRotation = lockXZRotation ? lockXZRotation : false

      // The speed at which the NPC will rotate to face the user
      this.rotSpeed = rotSpeed ? rotSpeed : 2

      if (active) {
         this.active = true
      }
   }
}

// This system is used to rotate the NPC to face the user during interaction
let faceUserAdded: boolean = false
const player = Camera.instance

// Rotates NPC to face the user during interaction
export function addFaceUserSystem() {
   faceUserAdded = true

   engine.addSystem(new FaceUserSystem())
}

// Rotates NPC to face the user during interaction
class FaceUserSystem implements ISystem {

   // The group of entities that have the TrackUserFlag component
   private followingNPCs = engine.getComponentGroup(TrackUserFlag)
   update(dt: number) {
      // Loop through all entities with the TrackUserFlag component
      for (let npc of this.followingNPCs.entities) {
         let transform = npc.getComponent(Transform)
         let trackUser = npc.getComponent(TrackUserFlag)
         // If the NPC is active, rotate to face the user
         if (trackUser.active) {
            // Rotate to face the player
            let lookAtTarget = new Vector3(player.position.x, player.position.y, player.position.z)
            // Calculate the direction to look at
            let direction = lookAtTarget.subtract(transform.position)
            transform.rotation = Quaternion.Slerp(
               transform.rotation,
               Quaternion.LookRotation(direction),
               dt * trackUser.rotSpeed
            )

            // If the NPC is not supposed to rotate on the X or Z axis, set them to 0
            if (trackUser.lockXZRotation) {
               transform.rotation.x = 0
               transform.rotation.z = 0
            }
         }
      }
   }
}"
/* Script to continually rotate an npc */,"import { NPC } from '@dcl/npc-scene-utils'
import * as utils from '@dcl/ecs-scene-utils'

// create a new NPC
const npc = new NPC(
   { position: new Vector3(10, 0.1, 10) },
   // the model of the NPC
   'models/RobotExpressive.glb',
   () => {
      // callback function that will be called when the NPC is activated
      log('NPC activated!')
   })


// Rotate entity
npc.addComponent(new utils.KeepRotatingComponent(Quaternion.Euler(0, 45, 0)))

// Listen for click
npc.addComponent(
  new OnPointerDown(() => {
    npc.getComponent(utils.KeepRotatingComponent).stop()
  })
)

// add the NPC to the scene
engine.addEntity(npc)


"
/* create avocado */,"/* At the end of your sceneâ€™s index.ts file, add the following lines: */`
let avocado = engine.addEntity()

GltfContainer.create(avocado, {src: (""models/avocado.gltf""})

Transform.create(avocado, {
          position:  Vector3.create(3, 1, 3),
          scale: Vector3.create(10, 10, 10)
})"
/* Danse-floor */,"import { Animator, AudioSource, engine, Entity, GltfContainer, Material, MeshRenderer, Transform } from ""@dcl/sdk/ecs""
import {Quaternion, Vector3 } from ""@dcl/sdk/math""
export * from '@dcl/sdk'

import { engine, Schemas } from ""@dcl/sdk/ecs"";
import { Color3 } from '@dcl/sdk/math'

export const colors: Color3[] = [
    Color3.fromHexString('#1dccc7'),
    Color3.fromHexString('#ffce00'),
    Color3.fromHexString('#9076ff'),
    Color3.fromHexString('#fe3e3e'),
    Color3.fromHexString('#3efe94'),
    Color3.fromHexString('#3d30ec'),
    Color3.fromHexString('#6699cc')
]

enum CustomComponentIds {
  Tile = 2002,
  Beat = 2003
}

export const Tile = engine.defineComponent({}, CustomComponentIds.Tile)

export const Beat = engine.defineComponent(
    {
        interval: Schemas.Number,
        timer: Schemas.Number
    },
    CustomComponentIds.Beat
)
function randomizeTileColor(entity: Entity) {
    const colorNum = Math.floor(Math.random() * colors.length)
    Material.setPbrMaterial(entity, {
        albedoColor: colors[colorNum],
        metallic: 0
    })
}

// Add floor Tiles
;[0, 1, 2, 3].forEach((x) => {
    ;[0, 1, 2, 3].forEach((z) => {
        const tileEntity = engine.addEntity()
        
        MeshRenderer.setPlane(tileEntity)
        
        Transform.create(tileEntity, {
            position: Vector3.create(x * 4 + 2, 0, z * 4 + 2),
            rotation: Quaternion.fromEulerDegrees(90, 0, 0),
            scale: Vector3.create(4, 4, 4)
        })
        
        randomizeTileColor(tileEntity)
        
        Tile.create(tileEntity)
    })
})

// Add Trevor NPC dancing
const trevorNPCEntity = engine.addEntity()
GltfContainer.create(trevorNPCEntity, {
    src: ""models/Trevor.glb""
})
Animator.create(trevorNPCEntity, {
    states: [{
        name: ""idle"",
        clip: ""Armature_Idle"",
        playing: true,
        loop: true
    }]
})
Transform.create(trevorNPCEntity, {
    position: Vector3.create(5, 0.1, 5),
    rotation: Quaternion.fromEulerDegrees(0, -90, 0),
    scale: Vector3.create(1.5, 1.5, 1.5)
})

// Add audio
AudioSource.create(trevorNPCEntity, {
    audioClipUrl: ""sounds/Vexento.mp3"",
    playing: true,
    loop: true
})

// Add beat keeper
const beatKeeperEntity = engine.addEntity()
const beatKeeperComponent = Beat.create(beatKeeperEntity, {
    interval: 0.5,
    timer: 0.5
})

// System to change tiles color
function tilesColorChangeSystem(dt: number) {
    beatKeeperComponent.timer -= dt

    if (beatKeeperComponent.timer < 0) {
        beatKeeperComponent.timer = beatKeeperComponent.interval

        for (const [tileEntity] of engine.getEntitiesWith(Tile)) {
            randomizeTileColor(tileEntity)
        }
    }
}
engine.addSystem(tilesColorChangeSystem)"
/* Gnark */,"// Coordinates of path to patrol
import {Animator, engine, Entity, GltfContainer, Transform} from '@dcl/sdk/ecs'
import {} from '@dcl/sdk/math'


const point1 = { x: 8, y: 0, z: 8 }
const point2 = { x: 8, y: 0, z: 24 }
const point3 = { x: 24, y: 0, z: 24 }
const point4 = { x: 24, y: 0, z: 8 }
const pathArray = [point1, point2, point3, point4]

// const TURN_TIME = 0.9


import { Schemas, engine } from ""@dcl/sdk/ecs""

const COMPONENT_ID = 2066

export enum gnarkStates {
  WALKING,
  TURNING,
  YELLING
}

const NPCData = {
  state: Schemas.Enum<gnarkStates>(Schemas.Int),
  previousState: Schemas.Enum<gnarkStates>(Schemas.Int)
}

export const NPComponent = engine.defineComponent(NPCData, COMPONENT_ID)

const COMPONENT_ID = 2048

const TimeOut = {
  timeLeft: Schemas.Float,
  hasFinished: Schemas.Boolean,
  paused: Schemas.Boolean
}

export const TimeOutComponent = engine.defineComponent(TimeOut, COMPONENT_ID) 

// TODO: use higher number so we dont have conflicts (i.e. > 2000)
import { Schemas, engine } from '@dcl/sdk/ecs'
import { InterpolationType } from '../helper/interpolation'

const COMPONENT_ID = 2046

const Vector3EcsSchema = Schemas.Map({
  x: Schemas.Float,
  y: Schemas.Float,
  z: Schemas.Float
})

const MoveTransportData = {
  hasFinished: Schemas.Boolean,
  start: Vector3EcsSchema,
  end: Vector3EcsSchema,
  normalizedTime: Schemas.Float,
  lerpTime: Schemas.Float,
  speed: Schemas.Float,
  interpolationType: Schemas.Enum<InterpolationType>(Schemas.Int)
}

export const MoveTransformComponent = engine.defineComponent(MoveTransportData, COMPONENT_ID)


import { Schemas, engine } from ""@dcl/sdk/ecs""

const COMPONENT_ID = 2047

const Vector3EcsSchema = Schemas.Map({
  x: Schemas.Float,
  y: Schemas.Float,
  z: Schemas.Float
})

const PathData = {
  path: Schemas.Array(Vector3EcsSchema),
  origin: Schemas.Float,
  target: Schemas.Float,
  paused: Schemas.Boolean
}

export const PathDataComponent = engine.defineComponent(PathData, COMPONENT_ID)

export function createGnark(startingSegment: number = 1): Entity {
  const gnark = engine.addEntity()

  Transform.create(gnark, {
    position: point1
  })

  GltfContainer.create(gnark, {
    src: 'models/gnark.glb'
  })

  Animator.create(gnark, {
    states: [
      {
        name: 'walk',
        clip: 'walk',
        playing: true,
        weight: 1,
        speed: 1,
        loop: true,
        shouldReset: false
      },
      {
        name: 'turnRight',
        clip: 'turnRight',
        playing: false,
        weight: 1,
        speed: 1,
        loop: false,
        shouldReset: true
      },
      {
        name: 'raiseDead',
        clip: 'raiseDead',
        playing: false,
        weight: 1,
        speed: 1,
        loop: true,
        shouldReset: true
      }
    ]
  })

  NPComponent.create(gnark, { state: gnarkStates.TURNING, previousState: gnarkStates.WALKING })

  PathDataComponent.create(gnark, {
    path: pathArray,
    paused: false,
    origin: startingSegment,
    target: startingSegment + 1
  })

  MoveTransformComponent.create(gnark, {
    start: pathArray[startingSegment],
    end: pathArray[startingSegment + 1],
    normalizedTime: 0,
    lerpTime: 0,
    speed: 0.1,
    hasFinished: false,
    interpolationType: 0
  })

  TimeOutComponent.create(gnark, {
    timeLeft: 0.9,
    hasFinished: false,
    paused: false
  })

  return gnark
}"
/* Hummingbirds */,"import { Schemas, engine, Transform, GltfContainer, Animator, CameraMode, Entity } from '@dcl/sdk/ecs'
import { Quaternion, Vector3 } from '@dcl/sdk/math'

import { Schemas, engine } from '@dcl/sdk/ecs'


// TODO: use higher number so we dont have conflicts (i.e. > 2000)
const COMPONENT_ID = 2046

const MoveTransportData = {
  speed: Schemas.Float,
  start: Schemas.Vector3,
  end: Schemas.Vector3,
  normalizedTime: Schemas.Float,
  lerpTime: Schemas.Float,
  interpolationType: Schemas.Enum<InterpolationType>(Schemas.Int)
}

export const MoveTransformComponent = engine.defineComponent(MoveTransportData, COMPONENT_ID)/**
 * @public
 */
export enum InterpolationType {
  LINEAR,

  EASEINQUAD,
  EASEOUTQUAD,
  EASEQUAD,

  EASEINSINE,
  EASEOUTSINE,
  EASESINE,

  EASEINEXPO,
  EASEOUTEXPO,
  EASEEXPO,

  EASEINELASTIC,
  EASEOUTELASTIC,
  EASEELASTIC,

  EASEINBOUNCE,
  EASEOUTEBOUNCE,
  EASEBOUNCE
}

/**
 * @public
 */
export function Interpolate(type: InterpolationType, t: number): number {
  switch (type) {
    case InterpolationType.LINEAR:
      return InterpolateLinear(t)
      break
    case InterpolationType.EASEINQUAD:
      return InterpolateEaseInQuad(t)
      break
    case InterpolationType.EASEOUTQUAD:
      return InterpolateEaseOutQuad(t)
      break
    case InterpolationType.EASEQUAD:
      return InterpolateEaseQuad(t)
      break
    case InterpolationType.EASEINSINE:
      return InterpolateEaseInSine(t)
      break
    case InterpolationType.EASEOUTSINE:
      return InterpolateEaseOutSine(t)
      break
    case InterpolationType.EASESINE:
      return InterpolateEaseInOutSine(t)
      break
    case InterpolationType.EASEINEXPO:
      return InterpolateEaseInExpo(t)
      break
    case InterpolationType.EASEOUTEXPO:
      return InterpolateEaseOutExpo(t)
      break
    case InterpolationType.EASEEXPO:
      return InterpolateEaseInOutExpo(t)
      break
    case InterpolationType.EASEINELASTIC:
      return InterpolateEaseInElastic(t)
      break
    case InterpolationType.EASEOUTELASTIC:
      return InterpolateEaseOutElastic(t)
      break
    case InterpolationType.EASEELASTIC:
      return InterpolateEaseInOutElastic(t)
      break
    case InterpolationType.EASEINBOUNCE:
      return InterpolateEaseInBounce(t)
      break
    case InterpolationType.EASEOUTEBOUNCE:
      return InterpolateEaseOutBounce(t)
      break
    case InterpolationType.EASEBOUNCE:
      return InterpolateEaseInOutBounce(t)
      break
    default:
      return InterpolateLinear(t)
  }
}
function InterpolateLinear(t: number): number {
  return t
}
function InterpolateEaseInQuad(t: number): number {
  return t * t
}
function InterpolateEaseOutQuad(t: number): number {
  return t * (2 - t)
}
function InterpolateEaseQuad(t: number): number {
  return (t * t) / (2.0 * (t * t - t) + 1.0)
}

function InterpolateEaseInSine(t: number): number {
  return 1 - Math.cos((t * Math.PI) / 2)
}

function InterpolateEaseOutSine(t: number): number {
  return Math.sin((t * Math.PI) / 2)
}

function InterpolateEaseInOutSine(t: number): number {
  return -(Math.cos(Math.PI * t) - 1) / 2
}

function InterpolateEaseInExpo(t: number): number {
  return t === 0 ? 0 : Math.pow(2, 10 * t - 10)
}

function InterpolateEaseOutExpo(t: number): number {
  return t === 1 ? 1 : 1 - Math.pow(2, -10 * t)
}

function InterpolateEaseInOutExpo(t: number): number {
  return t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2
}

function InterpolateEaseInElastic(t: number): number {
  const c4 = (2 * Math.PI) / 3

  return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4)
}

function InterpolateEaseOutElastic(t: number): number {
  const c5 = (2 * Math.PI) / 3

  return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c5) + 1
}

function InterpolateEaseInOutElastic(t: number): number {
  const c6 = (2 * Math.PI) / 4.5

  return t === 0
    ? 0
    : t === 1
    ? 1
    : t < 0.5
    ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c6)) / 2
    : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c6)) / 2 + 1
}

function InterpolateEaseInBounce(t: number): number {
  return 1 - bounce(1 - t)
}

function InterpolateEaseOutBounce(t: number): number {
  return bounce(t)
}

function InterpolateEaseInOutBounce(t: number): number {
  return t < 0.5 ? (1 - bounce(1 - 2 * t)) / 2 : (1 + bounce(2 * t - 1)) / 2
}

function bounce(x: number) {
  const n1 = 7.5625
  const d1 = 2.75

  if (x < 1 / d1) {
    return n1 * x * x
  } else if (x < 2 / d1) {
    return n1 * (x -= 1.5 / d1) * x + 0.75
  } else if (x < 2.5 / d1) {
    return n1 * (x -= 2.25 / d1) * x + 0.9375
  } else {
    return n1 * (x -= 2.625 / d1) * x + 0.984375
  }
}
const BirdData = {
  waitingTime: Schemas.Int
}

export const isBird = engine.defineComponent(BirdData, 3333)

export function createHummingBird() {
  const bird = engine.addEntity()
  Transform.create(bird, {
    position: { x: 13, y: 3.5, z: 5 },
    rotation: { x: 0, y: 0, z: 0, w: 1 },
    scale: { x: 0.2, y: 0.2, z: 0.2 }
  })
  GltfContainer.create(bird, {
    src: 'models/hummingbird.glb'
  })
  Animator.create(bird, {
    states: [
      {
        clip: 'fly',
        loop: true,
        playing: true,
        shouldReset: false,
        speed: 2,
        name: 'fly'
      },
      {
        clip: 'look',
        loop: false,
        playing: false,
        shouldReset: false,
        name: 'look'
      },
      {
        clip: 'shake',
        loop: false,
        playing: false,
        shouldReset: false,
        name: 'shake'
      }
    ]
  })

  isBird.create(bird, {
    waitingTime: 0
  })

  const cameraEntity = CameraMode.getMutable(engine.CameraEntity)
  console.log('CAMERA MODE: ', cameraEntity.mode)
  cameraEntity.mode = 0
}

export function birdSystem(dt: number) {
  for (const [bird] of engine.getEntitiesWith(isBird)) {
    if (MoveTransformComponent.has(bird)) return

    const birdData = isBird.getMutable(bird)

    birdData.waitingTime -= dt
    if (birdData.waitingTime <= 0) {
      const currentPos = Transform.get(bird).position

      birdData.waitingTime = 2

      // next target
      const nextPos = {
        x: Math.random() * 12 + 2,
        y: Math.random() * 3 + 1,
        z: Math.random() * 12 + 2
      }

      MoveTransformComponent.create(bird, {
        speed: 1,
        start: currentPos,
        end: nextPos,
        normalizedTime: 0,
        lerpTime: 0,
        interpolationType: InterpolationType.EASESINE
      })

      const mutableTransform = Transform.getMutable(bird)
	  mutableTransform.rotation = Quaternion.fromLookAt(mutableTransform.position, nextPos)

    }
  }
}

engine.addSystem(birdSystem)"
/* Laser-ray-Casting */,"import { engine, Transform, RaycastResult, Material, Entity, Raycast, RaycastQueryType } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'
import { PBMaterial_PbrMaterial, engine, Schemas } from '@dcl/sdk/ecs'
import { Color3 } from '@dcl/sdk/math'

// Configuration constants
export const boxesCount = 10
export const speed = 1
export const rayDistance = 20

export const defaultMaterial: PBMaterial_PbrMaterial = {
  metallic: 0,
  roughness: 1,
  albedoColor: Color3.create(0.2, 0.1, 1)
}
export const hitMaterial: PBMaterial_PbrMaterial = {
  metallic: 1,
  roughness: 0.5,
  albedoColor: Color3.create(1, 1, 30)
}
export const hitMaterial2: PBMaterial_PbrMaterial = {
  metallic: 1,
  roughness: 0.5,
  albedoColor: Color3.create(0.2, 1, 0.2)
}
export const rayMaterial: PBMaterial_PbrMaterial = {
  metallic: 1,
  roughness: 0.5,
  albedoColor: Color3.create(30, 1, 1)
}

export enum CustomComponentIds {
  Ray = 12001,
  MovingCube = 12002
}

export const Ray = engine.defineComponent(
  {
    power: Schemas.Int,
    timestamp: Schemas.Int
  },
  CustomComponentIds.Ray
)

export const MovingCube = engine.defineComponent({}, CustomComponentIds.MovingCube)

import { engine, Transform } from '@dcl/sdk/ecs'


// a limit is reached, teleports the cube to the left
export default function movingCubesSystem(dt: number) {
  const delta = speed * dt
  for (const [entity] of engine.getEntitiesWith(MovingCube, Transform)) {
    const transform = Transform.getMutable(entity)
    transform.position.x += delta
    if (transform.position.x >= 2 + boxesCount * 3) transform.position.x -= 2 + boxesCount * 3
  }
}

export default function raycastSystem() {
  for (const [entity, ray, transform] of engine.getEntitiesWith(Ray, Transform)) {
    const result = RaycastResult.getOrNull(entity)
    if (result?.timestamp === ray.timestamp) {
      if (result.hits.length > 0) {
        for (const hit of result.hits) {
          if (hit.entityId) {
            Material.setPbrMaterial(hit.entityId as Entity, entity === engine.CameraEntity ? hitMaterial2 : hitMaterial)
          }
        }
      } else {
        for (const [entity] of engine.getEntitiesWith(MovingCube)) {
          Material.setPbrMaterial(entity, defaultMaterial)
        }
      }
    }

    const shouldUpdateRaycast = Raycast.getOrNull(entity) === null || (result && ray.timestamp === result.timestamp)

    if (shouldUpdateRaycast) {
      const raycastMut = Ray.getMutable(entity)
      raycastMut.timestamp += 1

      Raycast.createOrReplace(entity, {
        origin: transform.position,
        direction: Vector3.rotate(Vector3.Forward(), transform.rotation),
        maxDistance: raycastMut.power,
        queryType: RaycastQueryType.RQT_QUERY_ALL
      })
    }
  }
}"
/* Random noise Movement */,"import { engine } from ""@dcl/sdk/ecs""


const COMPONENT_ID = 2033

export const WaveGrass = engine.defineComponent({}, COMPONENT_ID)

import { Noise } from '@dcl/noise-utils'
import { engine, GltfContainer, Material, Transform } from '@dcl/sdk/ecs'
import { Color3, Quaternion, Vector3 } from '@dcl/sdk/math'

// export all the functions required to make the scene work
export * from '@dcl/sdk'




// --- Set up a system ---

// timer variable
let t = 0
function PerlinNoiseSystem(dt: number) {

        // update the timer based on the time since the last tick
    t += dt / 2

        // iterate over the entities of the group
        for (const [entity] of engine.getEntitiesWith(Transform, WaveGrass)) {
                // get the Transform component of the entity
                const transform = Transform.getMutable(entity)

                if(!transform.rotation) return

                // // rotate grass blades along x axis based on noise
                const rotX = Noise.simplex3(
                        transform.position.x / 16,
                        t,
                        transform.position.z / 16
                ) *2

                //  // rotate grass blades along z axis based on noise
                const rotZ = Noise.simplex3(
                   transform.position.z / 16,
                   t,
                   transform.position.x / 16
                 ) *2

                transform.rotation = Quaternion.fromEulerDegrees(rotX, 0, rotZ)
         }

}

engine.addSystem(PerlinNoiseSystem)


// --- ground ---
const ground = engine.addEntity()
Transform.create(ground, {
        position: Vector3.create(8, 0, 8)
})
GltfContainer.create(ground, {
        src: 'models/ground.glb'
})

/// --- Spawner function ---

function spawnGrass(shape: string, x: number, y: number, z: number) {
  // create the entity
  const grass = engine.addEntity()

  // add a transform to the entity
  Transform.create(grass,{
        position: Vector3.create(x, y, z),
        rotation: Quaternion.fromEulerDegrees(0, Math.random() * 30, 0),
        scale: Vector3.create(1, 0.5 + Math.random() / 2, 1),
  })
 
  // add a shape to the entity
  GltfContainer.create(grass, {
        src: shape
  })

  WaveGrass.create(grass)

  Material.setPbrMaterial(grass, {
         albedoColor: Color3.create(x / 16, y / 16, z / 4)
  })

  return grass
}

/// --- Spawn grass blades ---

const grassModel = 'models/grass.glb'
const grass2Model = 'models/grass2.glb'
const grass3Model = 'models/grass3.glb'

for (let x = 0.7; x < 15.4; x++) {
  for (let y = 0.7; y < 15.4; y++) {
    // select a glb mesh randomly from the 3 variations
    const selector = Math.random()

    if (selector > 0.66) {
      spawnGrass(grassModel, x, 0, y)
    } else if (selector > 0.33) {
      spawnGrass(grass2Model, x, 0, y)
    } else {
      spawnGrass(grass3Model, x, 0, y)
    }
  }
}

let started = false"
/* Swimming shark */,"import { engine, Schemas } from '@dcl/sdk/ecs'

const COMPONENT_ID = 1111

export const SpeedComponent = engine.defineComponent({ speed: Schemas.Float }, COMPONENT_ID)


import { Schemas, engine } from '@dcl/sdk/ecs'

const COMPONENT_ID = 2048

const Vector3EcsSchema = Schemas.Map({
  x: Schemas.Float,
  y: Schemas.Float,
  z: Schemas.Float
})

const QuaternionEcsType = Schemas.Map({
  x: Schemas.Float,
  y: Schemas.Float,
  z: Schemas.Float,
  w: Schemas.Float
})

const PathData = {
  path: Schemas.Array(Vector3EcsSchema),
  origin: Schemas.Int,
  target: Schemas.Int,
  startRot: QuaternionEcsType,
  endRot: QuaternionEcsType,
  fraction: Schemas.Float,
  paused: Schemas.Boolean
}

export const PathDataComponent = engine.defineComponent(PathData, COMPONENT_ID)



export const cpoints: { x: number; y: number; z: number }[] = [
  { x: 12.8, y: 8, z: 3.2 },
  { x: 12.9253376, y: 8.069056, z: 3.3972224000000004 },
  { x: 13.044940800000001, y: 8.124608, z: 3.6420992000000005 },
  { x: 13.158195200000002, y: 8.167232, z: 3.9304448000000005 },
  { x: 13.264486400000001, y: 8.197504, z: 4.2580736 },
  { x: 13.3632, y: 8.216000000000001, z: 4.620800000000001 },
  { x: 13.453721600000002, y: 8.223296, z: 5.0144384 },
  { x: 13.535436800000003, y: 8.219968, z: 5.434803200000001 },
  { x: 13.607731200000002, y: 8.206592, z: 5.877708800000001 },
  { x: 13.6699904, y: 8.183743999999999, z: 6.3389696 },
  { x: 13.7216, y: 8.152, z: 6.8144 },
  { x: 13.761945599999999, y: 8.111936, z: 7.2998144 },
  { x: 13.790412800000002, y: 8.064128, z: 7.7910272 },
  { x: 13.806387200000001, y: 8.009152, z: 8.283852799999998 },
  { x: 13.809254400000002, y: 7.947584, z: 8.7741056 },
  { x: 13.7984, y: 7.880000000000001, z: 9.2576 },
  { x: 13.773209600000001, y: 7.806975999999999, z: 9.7301504 },
  { x: 13.7330688, y: 7.729087999999999, z: 10.1875712 },
  { x: 13.677363200000002, y: 7.646912, z: 10.6256768 },
  { x: 13.6054784, y: 7.561024, z: 11.040281600000004 },
  { x: 13.5168, y: 7.4719999999999995, z: 11.427200000000003 },
  { x: 13.4107136, y: 7.380415999999999, z: 11.782246400000002 },
  { x: 13.2866048, y: 7.286847999999999, z: 12.101235200000001 },
  { x: 13.1438592, y: 7.191872, z: 12.379980800000004 },
  { x: 12.9818624, y: 7.096063999999998, z: 12.6142976 },
  { x: 12.8, y: 7, z: 12.8 },
  { x: 12.583116799999999, y: 6.896691199999999, z: 12.9465856 },
  { x: 12.3193344, y: 6.7796096, z: 13.067084800000002 },
  { x: 12.012953600000001, y: 6.650022399999999, z: 13.1626112 },
  { x: 11.6682752, y: 6.5091968, z: 13.2342784 },
  { x: 11.2896, y: 6.3584, z: 13.2832 },
  { x: 10.8812288, y: 6.1988992, z: 13.310489600000002 },
  { x: 10.4474624, y: 6.031961600000001, z: 13.317260800000001 },
  { x: 9.9926016, y: 5.8588544, z: 13.3046272 },
  { x: 9.5209472, y: 5.6808448, z: 13.273702400000001 },
  { x: 9.0368, y: 5.4992, z: 13.225600000000002 },
  { x: 8.544460800000001, y: 5.3151872000000004, z: 13.1614336 },
  { x: 8.048230400000001, y: 5.130073600000001, z: 13.082316800000001 },
  { x: 7.552409600000001, y: 4.945126400000001, z: 12.989363199999998 },
  { x: 7.0612992000000006, y: 4.761612800000001, z: 12.8836864 },
  { x: 6.5792, y: 4.580800000000001, z: 12.766399999999999 },
  { x: 6.110412800000001, y: 4.4039552, z: 12.6386176 },
  { x: 5.6592384, y: 4.2323456, z: 12.5014528 },
  { x: 5.2299776, y: 4.067238400000001, z: 12.3560192 },
  { x: 4.8269312, y: 3.9099008, z: 12.2034304 },
  { x: 4.4544, y: 3.7616, z: 12.0448 },
  { x: 4.1166848, y: 3.6236032, z: 11.881241600000001 },
  { x: 3.8180863999999994, y: 3.4971775999999997, z: 11.7138688 },
  { x: 3.5629056000000006, y: 3.3835904, z: 11.543795200000002 },
  { x: 3.3554432000000016, y: 3.2841087999999994, z: 11.3721344 },
  { x: 3.2, y: 3.2, z: 11.2 },
  { x: 3.0896128000000003, y: 3.126272, z: 11.0149248 },
  { x: 3.0132224, y: 3.057216, z: 10.8051584 },
  { x: 2.9689856000000003, y: 2.9930240000000006, z: 10.5728896 },
  { x: 2.9550592, y: 2.933888, z: 10.320307199999998 },
  { x: 2.9696, y: 2.8800000000000003, z: 10.0496 },
  { x: 3.0107648000000005, y: 2.831552, z: 9.762956799999998 },
  { x: 3.0767104000000005, y: 2.788736, z: 9.462566399999998 },
  { x: 3.1655936000000002, y: 2.751744, z: 9.150617599999997 },
  { x: 3.2755712000000003, y: 2.720768, z: 8.8292992 },
  { x: 3.4048, y: 2.6960000000000006, z: 8.500799999999998 },
  { x: 3.5514368000000003, y: 2.6776320000000005, z: 8.1673088 },
  { x: 3.7136384000000002, y: 2.6658560000000002, z: 7.831014399999999 },
  { x: 3.8895616, y: 2.660864000000001, z: 7.494105599999999 },
  { x: 4.077363200000001, y: 2.662848, z: 7.158771199999999 },
  { x: 4.2752, y: 2.6720000000000006, z: 6.8271999999999995 },
  { x: 4.4812288, y: 2.6885120000000007, z: 6.5015807999999975 },
  { x: 4.6936064, y: 2.7125760000000003, z: 6.184102399999998 },
  { x: 4.910489600000001, y: 2.7443840000000006, z: 5.8769535999999984 },
  { x: 5.130035200000001, y: 2.784128000000001, z: 5.582323199999998 },
  { x: 5.350400000000002, y: 2.8320000000000007, z: 5.302399999999996 },
  { x: 5.569740800000002, y: 2.8881920000000005, z: 5.039372799999995 },
  { x: 5.786214400000002, y: 2.952896000000001, z: 4.795430399999995 },
  { x: 5.997977600000002, y: 3.026304000000001, z: 4.572761599999995 },
  { x: 6.203187200000001, y: 3.1086080000000016, z: 4.373555199999995 },
  { x: 6.4, y: 3.2, z: 4.2 },
  { x: 6.6019328, y: 3.3079808, z: 4.0412672 },
  { x: 6.822502400000001, y: 3.4385664000000005, z: 3.8856576000000005 },
  { x: 7.059865600000001, y: 3.5897216, z: 3.7340544 },
  { x: 7.312179200000001, y: 3.7594112, z: 3.5873408000000007 },
  { x: 7.5776, y: 3.9456, z: 3.4464000000000006 },
  { x: 7.8542848, y: 4.1462528, z: 3.3121152 },
  { x: 8.140390400000001, y: 4.359334400000001, z: 3.1853696 },
  { x: 8.434073600000001, y: 4.5828096, z: 3.0670464 },
  { x: 8.7334912, y: 4.8146432, z: 2.9580288000000006 },
  { x: 9.0368, y: 5.0527999999999995, z: 2.8592000000000004 },
  { x: 9.3421568, y: 5.2952448, z: 2.7714432 },
  { x: 9.6477184, y: 5.5399424, z: 2.6956416 },
  { x: 9.951641600000002, y: 5.7848576000000005, z: 2.6326784000000005 },
  { x: 10.252083200000001, y: 6.0279552, z: 2.5834368000000003 },
  { x: 10.547200000000002, y: 6.267200000000001, z: 2.548800000000001 },
  { x: 10.8351488, y: 6.5005568, z: 2.5296512000000004 },
  { x: 11.114086400000001, y: 6.725990400000001, z: 2.5268736000000005 },
  { x: 11.382169600000001, y: 6.941465600000002, z: 2.5413504000000002 },
  { x: 11.637555200000001, y: 7.144947200000001, z: 2.5739648000000006 },
  { x: 11.878400000000003, y: 7.3344000000000005, z: 2.6256000000000004 },
  { x: 12.102860800000002, y: 7.507788800000002, z: 2.697139200000001 },
  { x: 12.309094400000003, y: 7.663078400000002, z: 2.7894656000000015 },
  { x: 12.495257600000002, y: 7.798233600000001, z: 2.9034624000000013 },
  { x: 12.659507200000004, y: 7.911219200000001, z: 3.0400128000000013 },
  { x: 12.8, y: 8, z: 3.2 }
]

import { engine, Transform, GltfContainer, Animator } from '@dcl/sdk/ecs'
import { Quaternion } from '@dcl/sdk/math'
import { PathDataComponent } from './components/path'


export function createShark() {
  const shark = engine.addEntity()
  Transform.create(shark, {
    position: { x: 8, y: 3, z: 8 },
    rotation: { x: 0, y: 0, z: 0, w: 1 },
    scale: { x: 0.5, y: 0.5, z: 0.5 }
  })
  GltfContainer.create(shark, {
    src: 'models/shark.glb'
  })
  Animator.create(shark, {
    states: [
      {
        clip: 'swim',
        loop: true,
        playing: true,
        speed: 0.5,
        weight: 0.5,
        name: 'swim'
      },
      {
        clip: 'bite',
        loop: true,
        playing: false,
        shouldReset: false,
        name: 'bite'
      }
    ]
  })

  PathDataComponent.create(shark, {
    path: cpoints,
    origin: 0,
    target: 1,
    startRot: Quaternion.Zero(),
    endRot: Quaternion.Zero(),
    fraction: 0,
    paused: false
  })

  SpeedComponent.create(shark, {
    speed: 0.5
  })

  // MoveTransformComponent.create(shark, {
  // 	hasFinished: false,
  // 	start: cpoints[0],
  // 	end: cpoints[1],
  // 	fraction: 0
  // })

  // RotateTransformComponent.create(shark, {
  // 	hasFinished: false,
  // 	start: Quaternion.Zero(),
  // 	end: Quaternion.Zero(),
  // 	fraction: 1,
  // 	interpolationType: 0
  // })
}


// // Lerp over the points of the curve
export function PatrolPath() {
  for (const [entity] of engine.getEntitiesWith(PathDataComponent)) {
    const transform = Transform.getMutable(entity)
    const path = PathDataComponent.getMutable(entity)
    const speed = SpeedComponent.get(entity)

    // move
    path.fraction += speed.speed / 10
    transform.position = Vector3.lerp(path.path[path.origin], path.path[path.target], path.fraction)

    // rotate
    transform.rotation = Quaternion.slerp(path.startRot, path.endRot, path.fraction)

    // next segment
    if (path.fraction > 1) {
      path.origin = path.target
      path.target += 1
      if (path.target >= path.path.length - 1) {
        path.target = 0
      }
      path.fraction = 0

      // rotation
      path.startRot = transform.rotation
      const difference = Vector3.subtract(path.path[path.target], path.path[path.origin])
      const normalizedDifference = Vector3.normalize(difference)
      path.endRot = Quaternion.lookRotation(normalizedDifference)

      UpdateSpeed()
    }
  }
}

export function UpdateSpeed() {
  for (const [shark] of engine.getEntitiesWith(SpeedComponent)) {
    const speed = SpeedComponent.getMutable(shark)
    const path = PathDataComponent.get(shark)

    let depthDiff = path.path[path.target].y - path.path[path.origin].y //* curvePoints
    if (depthDiff > 1) {
      depthDiff = 1
    } else if (depthDiff < -1) {
      depthDiff = -1
    }
    depthDiff += 1.5 // from 0.5 to 2.5

    const clipSwim = Animator.getMutable(shark).states[0]
    clipSwim.speed = depthDiff
    clipSwim.weight = depthDiff

    speed.speed = depthDiff * -1 + 3 // from 2.5 to 0.5
  }
}"
/* Zombie-shooter */,"import { Schemas, engine } from ""@dcl/sdk/ecs""

const COMPONENT_ID = 2066

const GameControlleType = {
  spawnActive: Schemas.Boolean,
  spawnInterval: Schemas.Float,
  spawnCountDown: Schemas.Float,
  livesLeft: Schemas.Int,
  score: Schemas.Int,
  winningScore: Schemas.Int,
  maxZombies: Schemas.Int
}

export const GameControllerComponent = engine.defineComponent(GameControlleType, COMPONENT_ID)

/**
 * @public
 */
export enum InterpolationType {
  LINEAR,

  EASEINQUAD,
  EASEOUTQUAD,
  EASEQUAD,

  EASEINSINE,
  EASEOUTSINE,
  EASESINE,

  EASEINEXPO,
  EASEOUTEXPO,
  EASEEXPO,

  EASEINELASTIC,
  EASEOUTELASTIC,
  EASEELASTIC,

  EASEINBOUNCE,
  EASEOUTEBOUNCE,
  EASEBOUNCE
}

/**
 * @public
 */
export function Interpolate(type: InterpolationType, t: number): number {
  switch (type) {
    case InterpolationType.LINEAR:
      return InterpolateLinear(t)
      break
    case InterpolationType.EASEINQUAD:
      return InterpolateEaseInQuad(t)
      break
    case InterpolationType.EASEOUTQUAD:
      return InterpolateEaseOutQuad(t)
      break
    case InterpolationType.EASEQUAD:
      return InterpolateEaseQuad(t)
      break
    case InterpolationType.EASEINSINE:
      return InterpolateEaseInSine(t)
      break
    case InterpolationType.EASEOUTSINE:
      return InterpolateEaseOutSine(t)
      break
    case InterpolationType.EASESINE:
      return InterpolateEaseInOutSine(t)
      break
    case InterpolationType.EASEINEXPO:
      return InterpolateEaseInExpo(t)
      break
    case InterpolationType.EASEOUTEXPO:
      return InterpolateEaseOutExpo(t)
      break
    case InterpolationType.EASEEXPO:
      return InterpolateEaseInOutExpo(t)
      break
    case InterpolationType.EASEINELASTIC:
      return InterpolateEaseInElastic(t)
      break
    case InterpolationType.EASEOUTELASTIC:
      return InterpolateEaseOutElastic(t)
      break
    case InterpolationType.EASEELASTIC:
      return InterpolateEaseInOutElastic(t)
      break
    case InterpolationType.EASEINBOUNCE:
      return InterpolateEaseInBounce(t)
      break
    case InterpolationType.EASEOUTEBOUNCE:
      return InterpolateEaseOutBounce(t)
      break
    case InterpolationType.EASEBOUNCE:
      return InterpolateEaseInOutBounce(t)
      break
    default:
      return InterpolateLinear(t)
  }
}
function InterpolateLinear(t: number): number {
  return t
}
function InterpolateEaseInQuad(t: number): number {
  return t * t
}
function InterpolateEaseOutQuad(t: number): number {
  return t * (2 - t)
}
function InterpolateEaseQuad(t: number): number {
  return (t * t) / (2.0 * (t * t - t) + 1.0)
}

function InterpolateEaseInSine(t: number): number {
  return 1 - Math.cos((t * Math.PI) / 2)
}

function InterpolateEaseOutSine(t: number): number {
  return Math.sin((t * Math.PI) / 2)
}

function InterpolateEaseInOutSine(t: number): number {
  return -(Math.cos(Math.PI * t) - 1) / 2
}

function InterpolateEaseInExpo(t: number): number {
  return t === 0 ? 0 : Math.pow(2, 10 * t - 10)
}

function InterpolateEaseOutExpo(t: number): number {
  return t === 1 ? 1 : 1 - Math.pow(2, -10 * t)
}

function InterpolateEaseInOutExpo(t: number): number {
  return t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2
}

function InterpolateEaseInElastic(t: number): number {
  const c4 = (2 * Math.PI) / 3

  return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4)
}

function InterpolateEaseOutElastic(t: number): number {
  const c5 = (2 * Math.PI) / 3

  return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c5) + 1
}

function InterpolateEaseInOutElastic(t: number): number {
  const c6 = (2 * Math.PI) / 4.5

  return t === 0
    ? 0
    : t === 1
    ? 1
    : t < 0.5
    ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c6)) / 2
    : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c6)) / 2 + 1
}

function InterpolateEaseInBounce(t: number): number {
  return 1 - bounce(1 - t)
}

function InterpolateEaseOutBounce(t: number): number {
  return bounce(t)
}

function InterpolateEaseInOutBounce(t: number): number {
  return t < 0.5 ? (1 - bounce(1 - 2 * t)) / 2 : (1 + bounce(2 * t - 1)) / 2
}

function bounce(x: number) {
  const n1 = 7.5625
  const d1 = 2.75

  if (x < 1 / d1) {
    return n1 * x * x
  } else if (x < 2 / d1) {
    return n1 * (x -= 1.5 / d1) * x + 0.75
  } else if (x < 2.5 / d1) {
    return n1 * (x -= 2.25 / d1) * x + 0.9375
  } else {
    return n1 * (x -= 2.625 / d1) * x + 0.984375
  }
}

// TODO: use higher number so we dont have conflicts (i.e. > 2000)
const COMPONENT_ID = 2046

const MoveTransportData = {
  hasFinished: Schemas.Boolean,
  duration: Schemas.Float,
  start: Schemas.Vector3,
  end: Schemas.Vector3,
  normalizedTime: Schemas.Float,
  lerpTime: Schemas.Float,
  speed: Schemas.Float,
  interpolationType: Schemas.Enum<InterpolationType>(Schemas.Int)
}

export const MoveTransformComponent = engine.defineComponent(MoveTransportData, COMPONENT_ID)


import { engine, Transform, MeshRenderer, MeshCollider } from ""@dcl/sdk/ecs""

export function createCone() {
  const cone = engine.addEntity()

  Transform.create(cone, {
    position: { x: 3, y: 1, z: 3 }
  })

  MeshRenderer.setCylinder(cone, 1, 0)
  MeshCollider.setCylinder(cone, 1, 0)

  return cone
}


import { Entity, engine, PointerEvents, InputAction, PointerEventType, inputSystem } from ""@dcl/sdk/ecs""

const callbackMap = new Map<Entity, (entity: Entity) => void>()

export function clickedSystem() {
  for (const [entity] of engine.getEntitiesWith(PointerEvents)) {
    if (inputSystem.isTriggered(InputAction.IA_PRIMARY, PointerEventType.PET_DOWN, entity)) {
      const fn = callbackMap.get(entity)
      if (fn) fn(entity)
    }
  }
}

engine.addSystem(clickedSystem)

export function addClickBehavior(entity: Entity, fn: (entity: Entity) => void) {
  PointerEvents.create(entity, {
    pointerEvents: [
      {
        eventType: PointerEventType.PET_DOWN,
        eventInfo: {
          button: InputAction.IA_PRIMARY,
          hoverText: ""Click"",
          maxDistance: 100,
          showFeedback: true,
        },
      },
    ],
  })
  callbackMap.set(entity, fn)

  return entity
}

import { Entity, engine, Transform } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'


const callbackMap = new Map<Entity, () => void>()

export function onMoveZombieFinish(entity: Entity, callback: () => void) {
  callbackMap.set(entity, callback)
}

export function moveSystem(dt: number) {
  for (const [entity] of engine.getEntitiesWith(MoveTransformComponent, Transform)) {
    const move = MoveTransformComponent.getMutable(entity)
    const transform = Transform.getMutable(entity)

    move.normalizedTime = Math.min(Math.max(move.normalizedTime + dt * move.speed, 0), 1)
    move.lerpTime = Interpolate(move.interpolationType, move.normalizedTime)

    // assign value to transform
    transform.position = Vector3.lerp(move.start, move.end, move.lerpTime)

    // has finished
    move.hasFinished = move.normalizedTime >= 1

    if (move.hasFinished) {
      const fn = callbackMap.get(entity)
      if (fn) fn()
      MoveTransformComponent.deleteFrom(entity)
    }
  }
}
import { engine, AudioSource, Entity } from ""@dcl/sdk/ecs""

type State = {
  t: number
}

export function playSounds(dt: number, state: State) {
  state.t += dt
  if (state.t < 4) {
    return
  }
  state.t = 0

  const entitiesWSound = engine.getEntitiesWith(AudioSource)
  for (const [entity] of entitiesWSound) {
    const audioSource = AudioSource.getMutable(entity)
    audioSource.volume = 1
    audioSource.pitch = Math.random() * 5
    audioSource.playing = true
  }
}

export function playSound(entity: Entity, soundPath: string, rndPitch?: boolean) {
  const pitch = rndPitch ? Math.random() * 3 + 0.3 : 1

  if (AudioSource.has(entity)) {
    const source = AudioSource.getMutable(entity)
    ;(source.audioClipUrl = soundPath), (source.loop = false)
    source.playing = true
    source.pitch = pitch
  } else {
    AudioSource.create(entity, {
      audioClipUrl: soundPath,
      loop: false,
      pitch: pitch,
      playing: true
    })
  }
}import { Entity, engine, Transform, GltfContainer, Animator, NftShape } from '@dcl/sdk/ecs'



export function createZombie(xPos: number): Entity {
  const zombie = engine.addEntity()

  Transform.create(zombie, {
    position: { x: xPos, y: 1, z: 3 }
  })

  GltfContainer.create(zombie, {
    src: 'models/zombie.glb'
  })

  MoveTransformComponent.create(zombie, {
    start: { x: xPos, y: 1, z: 3 },
    end: { x: xPos, y: 1, z: 12 },
    duration: 6,
    normalizedTime: 0,
    lerpTime: 0,
    speed: 0.04,
    hasFinished: false,
    interpolationType: 1
  })

  Animator.create(zombie, {
    states: [
      {
        clip: 'Walking',
        loop: true,
        name: 'Walk',
        playing: true
      },
      {
        clip: 'Attacking',
        loop: true,
        name: 'Attack',
        playing: false
      }
    ]
  })

  onMoveZombieFinish(zombie, () => {
    console.log('finished zombie', zombie)

    if (GameControllerComponent.has(coneEntity)) {
      GameControllerComponent.getMutable(coneEntity).livesLeft -= 1
    }

    const animator = Animator.getMutable(zombie)
    const walkAnim = Animator.getClip(zombie, ""Walking"")
    const attackAnim = Animator.getClip(zombie, ""Attacking"")
    if (walkAnim && attackAnim) {
      walkAnim.playing = false
      walkAnim.loop = false
      attackAnim.playing = true
      attackAnim.loop = true
    }

    const nfts = engine.getEntitiesWith(NftShape)

    //only remove first
    for (const [entity] of nfts) {
      engine.removeEntity(entity)
      break
    }

    playSound(zombie, 'sounds/attack.mp3', true)
  })

  addClickBehavior(zombie, () => {
    console.log('BOOM!!!')

    engine.removeEntity(zombie)
    playSound(zombie, 'sounds/explosion.mp3', true)

    if (GameControllerComponent.has(coneEntity)) {
      GameControllerComponent.getMutable(coneEntity).score += 1
    }
  })

  return zombie
}"
/* Avatar swap */,"import {
    engine,
    Entity,
    Transform,
    Animator,
    AvatarModifierArea,
    AvatarModifierType,
    MeshRenderer,
    Material,
    MeshCollider,
} from '@dcl/sdk/ecs'

import { Color4, Vector3 } from '@dcl/sdk/math'

export type IntervalUtilType = 'delta'|'abs-time'

export class IntervalUtil {
    type:IntervalUtilType = 'delta'
    elapsedTime: number
    targetTime: number
    lastUpdateTime:number
    onTargetTimeReached: () => void

    onTimeReachedCallback?: () => void

    /**
     * @param millisecs - amount of time in milliseconds
     * @param onTimeReachedCallback - callback for when time is reached
     */
    constructor( millisecs: number,type?:IntervalUtilType, onTimeReachedCallback?: () => void) {
        if(type) this.type = type

        this.elapsedTime = 0
        if(this.type == 'delta'){
            this.targetTime = millisecs / 1000
        }else{
            this.targetTime = millisecs
        }

        this.reset()
        this.onTimeReachedCallback = onTimeReachedCallback
        this.onTargetTimeReached = () => {
            this.elapsedTime = 0
            if (this.onTimeReachedCallback) this.onTimeReachedCallback()
        }
    }

    reset(){
        this.elapsedTime = 0
        if(this.type == 'delta'){
        }else{
            this.lastUpdateTime = Date.now()
        }
    }
    setCallback(onTimeReachedCallback: () => void) {
        this.onTimeReachedCallback = onTimeReachedCallback
    }
    /**
     * 
     * @param dt 
     * @returns false if not hit interval, true if hit interval
     */
    update(dt:number): boolean{
        const now = Date.now()
        if(this.type == 'delta'){
            this.elapsedTime += dt
        }else{
            
            //real time
            this.elapsedTime += now - this.lastUpdateTime

            //log(""this.elapsedTime"",this.elapsedTime.toFixed(3))
        }

        this.lastUpdateTime = now

        if(this.elapsedTime > this.targetTime){
            this.onTargetTimeReached()
            return true
            //this.elapsedTime -= this.targetTime //push back
        }

        return false;
    }
    
}

import {
    engine,
    Entity,
    GltfContainer,
    Transform,
    Animator,
    PBAnimator,
    PBAnimationState,
} from '@dcl/sdk/ecs'
import { Vector3 } from ""@dcl/sdk/math"";

export enum TeamModels{
    None = ""None"",
    Krampus = ""Krampus"",
    Santa = ""Santa"",
}

const santaModel = ""models/Santa_FullBody.glb"";
const krampusModel = ""models/Grinch_FullBody.glb"";

const santaStates : PBAnimationState[] = [
    {   name: ""Idle"",
        clip: ""Idle_Santa"",
        loop: true,
        shouldReset : false
    },
    {   name: ""Running"",
        clip: ""Run_Santa"",
        loop: true,
        shouldReset : false
    }
];

const krampusStates : PBAnimationState[] = [
    {   name: ""Idle"",
        clip: ""Idle"",
        loop: true,
        shouldReset : false
    },
    {   name: ""Running"",
        clip: ""Run"",
        loop: true,
        shouldReset : false
    }
];

let parentEntity : Entity;
let modelEntity : Entity;
let animator : PBAnimator;

export function initializeCharacter() : Entity {
    parentEntity = engine.addEntity()

    modelEntity = engine.addEntity()
    
    GltfContainer.create(modelEntity, {
        src: santaModel
    })
    Transform.create(modelEntity, {
        position: Vector3.create(0, .75, 0),
        scale: Vector3.create(1, 1, 1),
        parent: parentEntity
    })
    animator = Animator.create(modelEntity, {
        states: santaStates,
    })

    return modelEntity
}

let currentModel : TeamModels;
export function changeModel(targetModel : TeamModels){
    if(currentModel == targetModel) return;
    currentModel = targetModel;
    switch (currentModel) {
        case TeamModels.Krampus:
            console.log(""Swap model to Kramps"");
            GltfContainer.createOrReplace(modelEntity, {
                src : krampusModel,
            });
            animator.states = krampusStates;
            break;
        case TeamModels.Santa:
            console.log(""Swap model to Santa"");
            GltfContainer.createOrReplace(modelEntity, {
                src : santaModel,
            });
            animator.states = santaStates;
            break;
    }
}

export enum AniamtionState{
    None = ""None"",
    Idle = ""Idle"",
    Run = ""Run"",
}

let currentAnimation : AniamtionState;
export function playAnimation(animation : AniamtionState){
    if(currentAnimation === animation) return;
    currentAnimation = animation;
    switch (currentAnimation) {
        case AniamtionState.Idle:
            Animator.playSingleAnimation(modelEntity, ""Idle"", false);
            break;
    
        case AniamtionState.Run:
            Animator.playSingleAnimation(modelEntity, ""Running"", false);
            break;
    }
}

export function initializeModels(){
    let santaHolder = engine.addEntity();
    GltfContainer.create(santaHolder, {
        src : santaModel,
    });
    
    Transform.create(santaHolder, {
        position : Vector3.create(0,4,0),
        scale: Vector3.create(0,0,0)
    })

    let krampusHolder = engine.addEntity();
    GltfContainer.create(krampusHolder, {
        src : krampusModel,
    });

    Transform.create(krampusHolder, {
        position : Vector3.create(0,4,0),
        scale: Vector3.create(0,0,0)
    })
}


let areaCenter: Vector3
let areaSize: Vector3
let areaMinPosition: Vector3
let areaMaxPosition: Vector3

function setupAreaData(center: Vector3, size: Vector3) {
    areaCenter = center
    areaSize = size

    const halfSize = Vector3.scale(size, 0.5)
    areaMinPosition = Vector3.create(
        areaCenter.x - halfSize.x,
        areaCenter.y - halfSize.y,
        areaCenter.z - halfSize.z
    )
    areaMaxPosition = Vector3.create(
        areaCenter.x + halfSize.x,
        areaCenter.y + halfSize.y,
        areaCenter.z + halfSize.z
    )
}

function isPositionInsideArea(targetPosition: Vector3): boolean {
    return targetPosition.x > areaMinPosition.x
        && targetPosition.y > areaMinPosition.y
        && targetPosition.z > areaMinPosition.z
        && targetPosition.x < areaMaxPosition.x
        && targetPosition.y < areaMaxPosition.y
        && targetPosition.z < areaMaxPosition.z
}

let otherAvatarEntity: Entity
export function createAvatarSwappingArea(center: Vector3, size: Vector3, avatarEntity: Entity) {
    setupAreaData(center, size)
    otherAvatarEntity = avatarEntity
    const avatarHiderAreaEntity = engine.addEntity()
    AvatarModifierArea.create(avatarHiderAreaEntity, {
        area: areaSize,
        modifiers: [AvatarModifierType.AMT_HIDE_AVATARS],
        excludeIds: []
    })
    Transform.create(avatarHiderAreaEntity, {
        position: areaCenter
    })
}

export function createSeparationWall(center: Vector3, size: Vector3) {
    let separationWall = engine.addEntity()

    Transform.create(separationWall, {
        position: center,
        scale: size,
    });

    MeshRenderer.setBox(separationWall);
    Material.setPbrMaterial(separationWall, {
        albedoColor: Color4.Gray(),
        metallic : 0,
        roughness : 1
    });
    MeshCollider.setBox(separationWall);
}

let lastPlayerPos: Vector3 | undefined = undefined
const intervalUtil = new IntervalUtil(50);

export function avatarSwappingSystem (dt: number) {
    if (!Transform.has(engine.PlayerEntity)) return

    if(!intervalUtil.update(dt)) return;

    const playerPos = Transform.get(engine.PlayerEntity).position
    const moved = playerPos != lastPlayerPos

    let animation = moved ? AniamtionState.Run : AniamtionState.Idle;
    playAnimation(animation);

    if (!moved) return

    const playerIsInsideHidingArea = isPositionInsideArea(playerPos)
    const otherAvatarTransform = Transform.getMutable(otherAvatarEntity)
    otherAvatarTransform.scale.x = playerIsInsideHidingArea ? 1 : 0
    otherAvatarTransform.scale.y = playerIsInsideHidingArea ? 1 : 0
    otherAvatarTransform.scale.z = playerIsInsideHidingArea ? 1 : 0

    lastPlayerPos = playerPos
}"
/* Arissa avatar */,"import {
    engine,
    Entity,
    GltfContainer,
    Transform,
    Animator
} from '@dcl/sdk/ecs'
import { Vector3 } from ""@dcl/sdk/math"";

export function createArissaCharacter() : Entity {
    const parentEntity = engine.addEntity()
    const entity = engine.addEntity()
    
    GltfContainer.create(entity, {
        src: ""models/arissa.glb""
    })
    Transform.create(entity, {
        position: Vector3.create(0, 1.75, 0),
        scale: Vector3.create(0, 0, 0),
        parent: parentEntity
    })
    Animator.create(entity, {
        states: [
            {
                name: ""Running"",
                clip: ""Running"",
                loop: true
            },
            {
                name: ""Idle"",
                clip: ""Idle"",
                loop: true
            }
        ]
    })
    
    return entity
}"
/* Beer dispenser */,"import { engine, inputSystem, InputAction, PointerEventType, Entity, Transform, AvatarAttach, AvatarAnchorPointType, Animator } from '@dcl/sdk/ecs'
import { Vector3, Quaternion } from '@dcl/sdk/math'
import {Vector3} from '@dcl/sdk/math'
import {engine, Schemas} from '@dcl/sdk/ecs'
/**
 * Types
 */

export enum BeerType {
  NONE,
  RED,
  YELLOW,
  GREEN
}

export type TapDataType = {
  model: string
  position: Vector3
  name: string
}

export const TAP_DATA: Record<string, TapDataType> = {
  [BeerType.RED]: {
    name: 'Red',
    model: 'models/redTap.glb',
    position: Vector3.create(0.368, 0, 0.31)
  },
  [BeerType.YELLOW]: {
    name: 'Yellow',
    model: 'models/yellowTap.glb',
    position: Vector3.create(0, 0, 0.31)
  },
  [BeerType.GREEN]: {
    name: 'Green',
    model: 'models/greenTap.glb',
    position: Vector3.create(-0.368, 0, 0.31)
  }
}

export function getTapData(tapBeerType: BeerType) {
  return (TAP_DATA as any)[tapBeerType] as TapDataType
}

/**
 * Component Definitions
 */

enum CustomComponentIds {
  BeerGlass = 2000,
  PickedUp = 2001,
  TapComponent = 2002,
  TapBase = 2003
}

export const BeerGlass = engine.defineComponent(
  {
    beingFilled: Schemas.Boolean,
    filled: Schemas.Boolean,
    beerType: Schemas.Enum<BeerType>(Schemas.Int),
    drinking: Schemas.Boolean
  },
  CustomComponentIds.BeerGlass
)
export const PickedUp = engine.defineComponent(
  {
    child: Schemas.Int
  },
  CustomComponentIds.PickedUp
)

export const TapComponent = engine.defineComponent(
  {
    pouringTime: Schemas.Number,
    pouring: Schemas.Boolean,
    beerType: Schemas.Enum<BeerType>(Schemas.Int)
  },
  CustomComponentIds.TapComponent
)

export const TapBase = engine.defineComponent(
  {
    beerType: Schemas.Enum<BeerType>(Schemas.Int)
  },
  CustomComponentIds.TapBase
)

import {
  engine,
  GltfContainer,
  Transform,
  Animator,
  PointerEvents,
  PointerEventType,
  InputAction,
  Entity,
  MeshCollider,
  MeshRenderer,
  AudioSource,
} from ""@dcl/sdk/ecs""
import { Vector3, Quaternion } from ""@dcl/sdk/math""

export function createBeerGlass(model: string, position: Vector3) {
  const glassEntity = engine.addEntity()

  GltfContainer.create(glassEntity, { src: model })

  Transform.create(glassEntity, { position })

  Animator.create(glassEntity, {
    states: [
      {
        clip: ""Blank"",
        name: ""Blank"",
        playing: true,
      },
      {
        clip: ""PourRed"",
        name: ""PourRed"",
        loop: false,
      },
      {
        clip: ""PourYellow"",
        name: ""PourYellow"",
        loop: false,
      },
      {
        clip: ""PourGreen"",
        name: ""PourGreen"",
        loop: false,
      },
    ],
  })
  BeerGlass.create(glassEntity)

  PointerEvents.create(glassEntity, {
    pointerEvents: [
      {
        eventType: PointerEventType.PET_DOWN,
        eventInfo: {
          hoverText: ""Pick up"",
          maxDistance: 5,
          button: InputAction.IA_PRIMARY,
        },
      },
    ],
  })
}

export function createTap(tapBeerType: BeerType, dispenseEntity: Entity) {
  const tapEntity = engine.addEntity()
  const tapData = getTapData(tapBeerType)

  TapComponent.create(tapEntity, {
    beerType: tapBeerType,
  })
  GltfContainer.create(tapEntity, {
    src: tapData.model,
  })
  Transform.create(tapEntity, {
    parent: dispenseEntity,
  })
  Animator.create(tapEntity, {
    states: [
      {
        clip: ""Blank"",
        name: ""Blank"",
        playing: true,
        loop: false,
      },
      {
        clip: ""Pour"",
        name: ""Pour"",
        loop: false,
      },
    ],
  })

  PointerEvents.create(tapEntity, {
    pointerEvents: [
      {
        eventType: PointerEventType.PET_DOWN,
        eventInfo: {
          hoverText: ""Pour"",
          maxDistance: 5,
          button: InputAction.IA_PRIMARY,
        },
      },
    ],
  })

  const tapColliderPosition = Vector3.add(tapData.position, Vector3.create(0, 0.05, 0))
  const colliderParentEntity = engine.addEntity()
  Transform.create(colliderParentEntity, {
    parent: tapEntity,
    position: tapColliderPosition,
  })
  TapBase.create(colliderParentEntity, {
    beerType: tapBeerType,
  })

  const colliderEntity = engine.addEntity()
  Transform.create(colliderEntity, {
    parent: colliderParentEntity,
    scale: Vector3.scale(Vector3.One(), 0.33),
    rotation: Quaternion.fromEulerDegrees(90, 0, 0),
  })

  MeshCollider.setPlane(colliderEntity)
  // Debug to see the collider
  MeshRenderer.setPlane(colliderEntity)
}

export function playSound(audio: string, loop: boolean = false, position?: Vector3) {
  const entity = engine.addEntity()
  AudioSource.create(entity, {
    audioClipUrl: audio,
    loop,
    playing: true,
  })

  Transform.create(entity, {
    position,
  })

  return entity
}

import { Transform, engine, executeTask, Entity, Animator } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'
import { getUserData } from '~system/UserIdentity'

export function getPlayerPosition() {
  return Transform.getOrNull(engine.PlayerEntity)?.position || Vector3.create()
}

export let currentPlayerId: string

void executeTask(async () => {
  const user = await getUserData({})
  if (!user.data) return
  currentPlayerId = user.data?.userId
})

export function* getEntitiesWithParent(parent: Entity) {
  for (const [entity, transform] of engine.getEntitiesWith(Transform)) {
    if (transform.parent === parent) {
      yield [entity, transform]
    }
  }
}

export function getEntityParent(entity: Entity) {
  return Transform.getOrNull(entity)?.parent || engine.RootEntity
}

export function pickingGlassSystem() {
  // If there is some PickedUp, so the behvior is to listen when this
  //  can be dropped
  for (const [entity, pickedUp] of engine.getEntitiesWith(PickedUp)) {
    const tryToDropCommand = inputSystem.getInputCommand(InputAction.IA_PRIMARY, PointerEventType.PET_DOWN)
    if (tryToDropCommand) {
      const hitPosition = tryToDropCommand.hit?.position || getPlayerPosition()
      const hitEntity = tryToDropCommand.hit?.entityId as Entity
      const hitParentEntity = getEntityParent(hitEntity)
      let drop = false

      // If there is a tap base (the collider)
      if (TapBase.getOrNull(hitParentEntity)) {
        Transform.createOrReplace(pickedUp.child as Entity, {
          parent: hitParentEntity
        })
        drop = true
      } else {
        // Only it's allowed to hold the beer in surface parallel to floor
        const diff = Vector3.subtract(Vector3.Up(), tryToDropCommand.hit?.normalHit || Vector3.Zero())
        if (Vector3.length(diff) < 0.01) {
          Transform.createOrReplace(pickedUp.child as Entity, {
            position: hitPosition
          })
          drop = true
        }
      }

      // TODO: These line crashes the renderer
      // AvatarAttach.deleteFrom(entity)
      // engine.removeEntity(entity)
      if (drop) {
        PickedUp.deleteFrom(entity)
        playSound('sounds/putDown.mp3', false, hitPosition)
      }
    }

    const glass = BeerGlass.get(pickedUp.child as Entity)

    const tryToDrinkCommand = inputSystem.getInputCommand(InputAction.IA_SECONDARY, PointerEventType.PET_DOWN)
    if (glass.filled && tryToDrinkCommand) {
      BeerGlass.getMutable(pickedUp.child as Entity).filled = false
          Animator.playSingleAnimation(pickedUp.child, 'Blank')
      playSound('sounds/swallow.mp3', false, getPlayerPosition())
    }
    return
  }

  // Only happens when there isn't any PickedUp component
  for (const [entity, glass] of engine.getEntitiesWith(BeerGlass)) {
    if (!glass.beingFilled && inputSystem.isTriggered(InputAction.IA_PRIMARY, PointerEventType.PET_DOWN, entity)) {
      const parentBeer = engine.addEntity()
      PickedUp.create(parentBeer, {
        child: entity as any
      })

      AvatarAttach.create(parentBeer, {
        avatarId: currentPlayerId,
        anchorPointId: AvatarAnchorPointType.AAPT_RIGHT_HAND
      })
      Transform.createOrReplace(entity, {
        position: Vector3.create(0, 0.1, 0.175),
        rotation: Quaternion.fromEulerDegrees(0, -90, 30),
        parent: parentBeer
      })

      playSound('sounds/pickUp.mp3', false, getPlayerPosition())
    }
  }
}
function getBeerBehindTap(beerType: BeerType) {
  for (const [glassEntity, _1, _2, glassTransform] of engine.getEntitiesWith(BeerGlass, Animator, Transform)) {
    if (glassTransform.parent && TapBase.getOrNull(glassTransform.parent)?.beerType === beerType) {
      return glassEntity
    }
  }
}

export function tapPumpSystem(dt: number) {
  for (const [entity, tapReadonly] of engine.getEntitiesWith(TapComponent)) {
    // While is pouring
    if (tapReadonly.pouring) {
      // At start the pouring, play the sound an animation
      if (Scalar.withinEpsilon(tapReadonly.pouringTime, 0)) {
                Animator.playSingleAnimation(entity, `Pour`)
        playSound('sounds/beerPump.mp3', false, getPlayerPosition())
        const glassEntity = getBeerBehindTap(tapReadonly.beerType)
        if (glassEntity) Animator.playSingleAnimation(glassEntity, `Pour${getTapData(tapReadonly.beerType).name}`)
      }

      const tap = TapComponent.getMutable(entity)
      tap.pouringTime += dt

      if (tap.pouringTime >= 2.5) {
        tap.pouring = false
        tap.pouringTime = 0

        const glassEntity = getBeerBehindTap(tap.beerType)
        if (glassEntity) {
          const glass = BeerGlass.getMutable(glassEntity)
          glass.beerType = tap.beerType
          glass.beingFilled = false
          glass.filled = true
        }
      }

      // Listen the action
    } else if (inputSystem.isTriggered(InputAction.IA_PRIMARY, PointerEventType.PET_DOWN, entity)) {
      const glassEntity = getBeerBehindTap(tapReadonly.beerType)
      if (!glassEntity) {
        // TODO: notify that there is no glass
        return
      }

      const glass = BeerGlass.getMutable(glassEntity)
      if (glass.filled) {
        // TODO: notify that the glass is filled
        return
      }

      const tap = TapComponent.getMutable(entity)
      tap.pouring = true
      tap.pouringTime = 0

      glass.beingFilled = true
      glass.beerType = tap.beerType
    }
  }
}"
/* Bird field */,"// Params

import { engine, GltfContainer, Raycast, RaycastQueryType, RaycastResult, Transform } from ""@dcl/sdk/ecs""
import { Quaternion, Vector3 } from ""@dcl/sdk/math""
import { engine, Schemas } from ""@dcl/sdk/ecs""

export enum CustomComponentIds {
	DistanceBird = 2096,

  }


const DistanceBird = {
	originalPos: Schemas.Vector3,    
  	flying: Schemas.Boolean,
  	elapsed: Schemas.Number
  }
  
export const DistanceBirdComopnent = engine.defineComponent(DistanceBird, CustomComponentIds.DistanceBird)

import { Vector3 } from ""@dcl/sdk/math""

//function to calculate 3D distance between two points
export function realDistance(pos1: Vector3, pos2: Vector3): number 
{
    const a = pos1.x - pos2.x
    const b = pos1.y - pos2.y
    const c = pos1.z - pos2.z
    return Math.sqrt(a * a + b * b + c * c )
}

//// FIXED PARAMS


//set the center of the bird scattering area to the center of the scene
const CENTER =  Vector3.create(24,10,24)    

const SIDE_LENGTH:number = 20 // size of the area to spawn birds in
const ROWS:number = 10 
const COLS:number = 10 
const SPACING:number = SIDE_LENGTH/ROWS

//set the starting positions of the bird spawn grid to the south-west corner of the spawn area
const BASE = Vector3.create(CENTER.x - SIDE_LENGTH/2, CENTER.y, CENTER.z - SIDE_LENGTH/2) 

const RADIUS :number = 8 // how close you can get to a bird before it reacts
const AMPLITUDE:number = 1  



export function spawnBirds(){

	// TODO: find a way for rays to only be read once?
	let lastTimestamp: number = -1

	engine.addSystem(() => {
		for (const [entity, result] of engine.getEntitiesWith(RaycastResult)) {
			
			if(result.timestamp > lastTimestamp && result.hits[0]){          
					
				console.log(""GOT A RAYCAST HIT"", result)
				lastTimestamp = result.timestamp
				//if we hit the collider set the generated bird position's Y coord to the hitpoint's height
				const newPos = result.hits[0].position 
				
				//spawn a bird at the generated and terrain adapted position
				Transform.create(entity, {
					position: newPos,
					rotation: Quaternion.fromEulerDegrees(0, Math.random()*360,0)
				})
				GltfContainer.create(entity, {
					src: ""models/bird.glb""
				})
				DistanceBirdComopnent.create(entity, {elapsed: Math.random(), flying: false, originalPos: newPos})
			
			}        
			}       
		}
	)


	// TODO add delay before sending rays
    for(let i=0; i< ROWS; i++){
		for(let j=0; j< COLS; j++){     
  
		  //generate positions iterating through all rows and columns  and add large random offsets along X an Z (Y will adapt to the terrain later)
		  const newPos = Vector3.create(
			BASE.x + i* SPACING + Math.random()*20-10, 
			BASE.y , 
			BASE.z  + j * SPACING + Math.random()*20-10
			) 

			const birdEntity = engine.addEntity()

			// create a ray at the X,Z coord of the generated position which starts high up and has a downward direction
			// cast the ray downward and try to intersect it with the terrain's collider
			Raycast.createOrReplace(birdEntity, {
				origin: newPos,
				direction: Vector3.Down(),
				maxDistance: 22,
				queryType: RaycastQueryType.RQT_HIT_FIRST
			  })
		}
	  }
	engine.addSystem(proximitySystem)
}  



// System that checks distances to each bird
export function proximitySystem(dt:number){

	for (const [entity, birdInfo] of engine.getEntitiesWith(DistanceBirdComopnent)) {

		const playerTransform = Transform.getOrNull(engine.PlayerEntity)
		if(!playerTransform){return}

		const playerPos = playerTransform.position
		
		// calculate the distance between the player and the birds original position
		let dist = realDistance(birdInfo.originalPos, playerPos)

		// if the player is within a certain distance from the birds original perching position
		if( dist < RADIUS ){  

			  const mutableBirdInfo  = DistanceBirdComopnent.getMutable(entity)
			  const mutableTransform = Transform.getMutable(entity) 

			  // calculate a ratio (0-1) based on how close the player is to the bird and multiply it with a constant to amplify the effect
			  let multiplier = ( 1 - dist / RADIUS) * AMPLITUDE

			  // calculate the direction pointing from the player to the bird's default position
			  let playerDir = Vector3.subtract(birdInfo.originalPos, playerPos)

			  // if the bird was idle, change it to flying and replace the GLTF model with the flying one
			  if(!birdInfo.flying){
				mutableBirdInfo.flying = true
				GltfContainer.createOrReplace(entity, 
						{ src:'models/bird_fly.glb' }
				)
			  }
			  
			  // move the bird away from the player on the X and Z axis based on the closeness multiplier
			  mutableTransform.position = Vector3.add(birdInfo.originalPos, Vector3.multiplyByFloats(playerDir, multiplier, 0, multiplier))
	  
			  // always move the bird upwards on the Y axis (never downwards) regardless of player direction
			  mutableTransform.position.y = birdInfo.originalPos.y + 6*multiplier
	  
			  // increment the timer stored for each bird and use the sine of this time to wiggle the bird around the actual position calculated above
			  mutableBirdInfo.elapsed += dt
			  mutableTransform.position.x += Math.sin( birdInfo.elapsed * 10) * multiplier
			  mutableTransform.position.y += Math.sin( birdInfo.elapsed * 8 ) * multiplier
			  mutableTransform.position.z += Math.sin( birdInfo.elapsed * 11) * multiplier
	  
			  // make the flying bird always face the player
			  mutableTransform.rotation = Quaternion.fromLookAt(mutableTransform.position, playerPos)
		}  // in case the player is farther from the bird than the given radius
		 // make the flying bird change GLTF shape to the idle one
		else if(birdInfo.flying){

			const mutableBirdInfo  = DistanceBirdComopnent.getMutable(entity)
			const mutableTransform = Transform.getMutable(entity) 

			mutableBirdInfo.flying = false
			GltfContainer.createOrReplace(entity, 
				{ src:'models/bird.glb' }
			)

			 //make the bird land on its original position
			 mutableTransform.position = birdInfo.originalPos

		  }		  
		}
}"
/* coin pickup */,"import { AudioSource, AvatarAttach, engine, Entity, GltfContainer, Transform } from ""@dcl/sdk/ecs""
import { Vector3 } from ""@dcl/sdk/math""
import { engine, Entity, IEngine, Schemas, Transform } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'

function isPositionInsideTriggerArea(
    targetPosition: Vector3,
    areaPosition: Vector3,
    areaSize: Vector3,
    areaCenterOffset: Vector3
): boolean {
    const detectionAreaCenter = Vector3.add(areaPosition, areaCenterOffset)
    const detectionAreaSize = areaSize

    const halfSize = Vector3.scale(detectionAreaSize, 0.5)
    const areaMinPosition = Vector3.create(
        detectionAreaCenter.x - halfSize.x,
        detectionAreaCenter.y - halfSize.y,
        detectionAreaCenter.z - halfSize.z
    )
    const areaMaxPosition = Vector3.create(
        detectionAreaCenter.x + halfSize.x,
        detectionAreaCenter.y + halfSize.y,
        detectionAreaCenter.z + halfSize.z
    )

    return (
        targetPosition.x > areaMinPosition.x &&
        targetPosition.y > areaMinPosition.y &&
        targetPosition.z > areaMinPosition.z &&
        targetPosition.x < areaMaxPosition.x &&
        targetPosition.y < areaMaxPosition.y &&
        targetPosition.z < areaMaxPosition.z
    )
}

export function createTriggerArea(targetEngine: IEngine) {
    const TriggerBox = targetEngine.defineComponent({}, 2004)
    const TriggerArea = targetEngine.defineComponent(
        {
            size: Schemas.Vector3,
            centerOffset: Schemas.Vector3
        },
        2000
    )

    const TriggerState = targetEngine.defineComponent(
        {
            state: Schemas.Array(Schemas.Number)
        },
        2001
    )
    enum EventType {
        Enter,
        Exit
    }
    type EventMapType = Map<EventType, { cb: (entities: Entity[]) => void }>

    const eventsMap = new Map<Entity, EventMapType>()

    function checkTrigger(positionEntity: Entity, position: Vector3) {
        for (const [entity, area, state, transform] of targetEngine.getEntitiesWith(TriggerArea, TriggerState, Transform)) {
            const nextState = isPositionInsideTriggerArea(position, transform.position, area.size, area.centerOffset)
            const stateIndex = state.state.indexOf(positionEntity as number)
            const currentState = stateIndex !== -1

            if (currentState !== nextState) {
                const eventType = nextState ? EventType.Enter : EventType.Exit
                const data = eventsMap.get(entity)?.get(eventType)

                const triggerStateMutable = TriggerState.getMutable(entity)
                if (!currentState) {
                    triggerStateMutable.state.push(positionEntity as number)
                } else {
                    triggerStateMutable.state = triggerStateMutable.state.filter((item) => item !== positionEntity)
                }

                if (data) data.cb(triggerStateMutable.state)
            }
        }
    }

    function system() {
        const playerPosition = Transform.getOrNull(targetEngine.PlayerEntity)?.position || Vector3.Zero()
        checkTrigger(engine.PlayerEntity, playerPosition)
        for (const [entity, , transform] of targetEngine.getEntitiesWith(TriggerBox, Transform)) {
            checkTrigger(entity, transform.position)
        }
    }

    targetEngine.addSystem(system)

    return {
        setTriggerArea(entity: Entity, areaSize: Vector3, areaCenterOffset: Vector3) {
            TriggerArea.createOrReplace(entity, {
                size: areaSize,
                centerOffset: areaCenterOffset
            })
            TriggerState.createOrReplace(entity)
        },
        removeTriggerArea(entity: Entity) {
            TriggerArea.deleteFrom(entity)
            TriggerState.deleteFrom(entity)
        },
        onPlayerEnter(entity: Entity, cb: (entities: Entity[]) => void) {
            const event = eventsMap.get(entity) || eventsMap.set(entity, new Map()).get(entity)!
            event.set(EventType.Enter, { cb })
        },
        onPlayerExit(entity: Entity, cb: (entities: Entity[]) => void) {
            const event = eventsMap.get(entity) || eventsMap.set(entity, new Map()).get(entity)!
            event.set(EventType.Exit, { cb })
        },
        removeOnPlayerExit(entity: Entity) {
            eventsMap.get(entity)?.delete(EventType.Exit)
            if (eventsMap.get(entity)?.size === 0) {
                eventsMap.delete(entity)
            }
        },
        removeOnPlayerEnter(entity: Entity) {
            eventsMap.get(entity)?.delete(EventType.Enter)
            if (eventsMap.get(entity)?.size === 0) {
                eventsMap.delete(entity)
            }
        },
        addTriggerBox(entity: Entity) {
            TriggerBox.createOrReplace(entity)
        },
        removeTriggerBox(entity: Entity) {
            TriggerBox.deleteFrom(entity)
        }
    }
}

export const triggerAreaSystem = createTriggerArea(engine)


/**
 * Sound is a separated from the coin entity so that you can
 * still hear it even when the coin is removed from the engine.
 */
const coinPickupSound = engine.addEntity()
Transform.create(coinPickupSound)
AudioSource.create(coinPickupSound, { audioClipUrl: 'sounds/coinPickup.mp3' })

export function createCoin(
  model: string,
  position: Vector3,
  size: Vector3,
  centerOffset: Vector3
): Entity {
  const entity = engine.addEntity()
  GltfContainer.create(entity, { src: model })
  Transform.create(entity, { position })

  triggerAreaSystem.setTriggerArea(entity, size, centerOffset)

  triggerAreaSystem.onPlayerEnter(entity, () => {
    triggerAreaSystem.removeTriggerArea(entity)
    AudioSource.getMutable(coinPickupSound).playing = true
    Transform.getMutable(coinPickupSound).position = Transform.get(engine.PlayerEntity).position
    engine.removeEntity(entity)
  })

  return entity
}"
/* Cube wave 16x16 */,"import { engine, Transform, MeshRenderer, TextShape, Billboard } from '@dcl/sdk/ecs'
import { engine, MeshRenderer, Transform } from ""@dcl/sdk/ecs""

let hoverState: number = 0

export function CircleHoverSystem(dt: number) {
  hoverState += Math.PI * dt * 0.5

  const entitiesWithBoxShapes = engine.getEntitiesWith(MeshRenderer)

  // iterate over the entities of the group
  for (const [entity] of entitiesWithBoxShapes) {
    const transform = Transform.getMutable(entity)

    // mutate the position
    transform.position.y =
      Math.cos(
        hoverState + Math.sqrt(Math.pow(transform.position.x - 8, 2) + Math.pow(transform.position.z - 8, 2)) / Math.PI
      ) *
        2 +
      2

    //entity.getComponent(Material).albedoColor.set(transform.position.x / 16, transform.position.y / 16, transform.position.z / 4);
  }
}
// My cube generator
function createCube(x: number, y: number, z: number) {
  // Dynamic entity because we aren't loading static entities out of this scene code
  const myEntity = engine.addEntity(true)

  Transform.create(myEntity, {
    position: { x, y, z }
  })

  MeshRenderer.setBox(myEntity)

  return myEntity
}

for (let x = 0.5; x < 16; x += 1) {
  for (let y = 0.5; y < 16; y += 1) {
    createCube(x, 0, y)
  }
}

engine.addSystem(CircleHoverSystem)

const sign = engine.addEntity(true)
Transform.create(sign, {
  position: { x: 8, y: 6, z: 8 },
  scale: { x: 1.2, y: 1.2, z: 1.2 },
  rotation: { x: 0, y: 0, z: 0, w: 0 }
})

TextShape.create(sign, {
  text: 'Stress test SDK v7.0-EA\n16x16 cubes',
  fontAutoSize: false,
  fontSize: 5,
  height: 2,
  width: 4,
  lineCount: 1,
  lineSpacing: 1,
  outlineWidth: 0.1,
  outlineColor: { r: 0, g: 0, b: 1 },
  textColor: { r: 1, g: 0, b: 0, a: 1 },
  paddingBottom: 0,
  paddingLeft: 0,
  paddingRight: 0,
  paddingTop: 0,
  shadowBlur: 1,
  shadowColor: { r: 1, g: 0, b: 0 },
  shadowOffsetX: 0,
  shadowOffsetY: 5,
  textWrapping: false
})

Billboard.create(sign, {
  oppositeDirection: true
})"
/* Cube wave 32x32 */,"import { engine, MeshRenderer, Transform } from ""@dcl/sdk/ecs""

let hoverState: number = 0

export function CircleHoverSystem(dt: number) {
  hoverState += Math.PI * dt * 0.5

  const entitiesWithBoxShapes = engine.getEntitiesWith(MeshRenderer)

  // iterate over the entities of the group
  for (const [entity] of entitiesWithBoxShapes) {
    const transform = Transform.getMutable(entity)

    // mutate the rotation
    transform.position.y =
      Math.cos(
        hoverState + Math.sqrt(Math.pow(transform.position.x - 8, 2) + Math.pow(transform.position.z - 8, 2)) / Math.PI
      ) *
        2 +
      2

    //entity.getComponent(Material).albedoColor.set(transform.position.x / 16, transform.position.y / 16, transform.position.z / 4);
  }
}


import { engine } from ""@dcl/sdk/ecs""

export function addSystem<T>(fn: (dt: number, state: T) => void, initialState: T) {
  const state = { ...initialState }
  engine.addSystem((dt: number) => fn(dt, state))
}

import { Billboard, engine, MeshRenderer, TextShape, Transform } from ""@dcl/sdk/ecs""

// My cube generator
function createCube(x: number, y: number, z: number) {
  // Dynamic entity because we aren't loading static entities out of this scene code
  const myEntity = engine.addEntity(true)

  Transform.create(myEntity, {
    position: { x, y, z },
    scale: { x: 0.5, y: 0.5, z: 0.5 }
  })

  MeshRenderer.setBox(myEntity)

  return myEntity
}

for (let x = 0.5; x < 16; x += 0.5) {
  for (let y = 0.5; y < 16; y += 0.5) {
    createCube(x, 0, y)
  }
}

addSystem(CircleHoverSystem, { t: 0 })

const sign = engine.addEntity(true)
Transform.create(sign, {
  position: { x: 8, y: 6, z: 8 },
  scale: { x: 1.2, y: 1.2, z: 1.2 },
  rotation: { x: 0, y: 0, z: 0, w: 0 }
})

TextShape.create(sign, {
  text: 'Stress test SDK v7.0-EA\n16x16 cubes',
  fontAutoSize: false,
  fontSize: 5,
  height: 2,
  width: 4,
  lineCount: 1,
  lineSpacing: 1,
  outlineWidth: 0.1,
  outlineColor: { r: 0, g: 0, b: 1 },
  textColor: { r: 1, g: 0, b: 0, a: 1 },
  paddingBottom: 0,
  paddingLeft: 0,
  paddingRight: 0,
  paddingTop: 0,
  shadowBlur: 1,
  shadowColor: { r: 1, g: 0, b: 0 },
  shadowOffsetX: 0,
  shadowOffsetY: 5,
  textWrapping: false
})

Billboard.create(sign, {
  oppositeDirection: true
})"
/* dbmonster */,"import { YGDisplay, YGJustify, YGAlign, TextAlignMode, Font, engine } from ""@dcl/sdk/ecs""
import ReactEcs, { Label, UiEntity } from ""@dcl/sdk/react-ecs""
import { Color4 } from ""@dcl/sdk/math""

let dt = 0

engine.addSystem((d) => {
  dt = d
})

const Monster = (props: { index: number }) => (
  <Label
    // key={props.index.toString()}
    uiTransform={{ width: 80 + Math.random() * 100, height: 20 + props.index * 3 }}
    value={Math.random().toString(36)}
    textAlign={props.index % TextAlignMode.TAM_BOTTOM_RIGHT}
    fontSize={12 + props.index}
    color={Color4.Black()}
    font={Font.F_SANS_SERIF}
    uiBackground={{ color: { r: 0, g: Math.random(), b: Math.random(), a: 1 } }}
  />
)

const Column = () => {
  const amount = (3 + Math.random() * 10) | 0
  const monsters = new Array(amount).fill(null).map((_, i) => <Monster index={i} />)

  return (
    <UiEntity
      uiTransform={{
        width: 100 + dt * 200,
        display: YGDisplay.YGD_FLEX,
        justifyContent: YGJustify.YGJ_CENTER,
        alignItems: YGAlign.YGA_CENTER,
      }}
      uiBackground={{ color: { r: 1, g: 0.45, b: 0.85, a: Math.random() } }}
    >
      <Label
        uiTransform={{ width: 80, height: 20 }}
        value={""Amount:"" + monsters.length}
        textAlign={TextAlignMode.TAM_BOTTOM_CENTER}
        fontSize={15}
        color={Color4.Black()}
        font={Font.F_SANS_SERIF}
        uiBackground={{ color: { r: 1, g: 0.45, b: 0.85, a: 1 } }}
      />
      {...monsters}
    </UiEntity>
  )
}

export const ui = () => {
  return (
    <UiEntity
      uiTransform={{
        width: ""100%"",
        height: ""100%"",
        margin: { left: 300 },
        padding: { top: 10, right: 10, bottom: 10, left: 10 },
      }}
      uiBackground={{ color: { r: 0, g: 0, b: 0, a: 0.8 } }}
    >
      <Label
        uiTransform={{ width: 80, height: 20 }}
        value={""Delta time:"" + dt.toFixed(4)}
        textAlign={TextAlignMode.TAM_BOTTOM_CENTER}
        fontSize={12}
        color={Color4.Black()}
        font={Font.F_SANS_SERIF}
        uiBackground={{ color: { r: 1, g: 0.45, b: 0.85, a: 1 } }}
      />
      <Column />
      <Column />
      <Column />
      <Column />
      <Column />
    </UiEntity>
  )
}"
/* ennemy spawner */,"import { Entity, engine, Transform, GltfContainer, Animator, NftShape, Vector3Type, AudioSource } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'
import { Schemas, engine } from '@dcl/sdk/ecs'
/**
 * @public
 */
export enum InterpolationType {
  LINEAR,

  EASEINQUAD,
  EASEOUTQUAD,
  EASEQUAD,

  EASEINSINE,
  EASEOUTSINE,
  EASESINE,

  EASEINEXPO,
  EASEOUTEXPO,
  EASEEXPO,

  EASEINELASTIC,
  EASEOUTELASTIC,
  EASEELASTIC,

  EASEINBOUNCE,
  EASEOUTEBOUNCE,
  EASEBOUNCE
}

/**
 * @public
 */
export function Interpolate(type: InterpolationType, t: number): number {
  switch (type) {
    case InterpolationType.LINEAR:
      return InterpolateLinear(t)
      break
    case InterpolationType.EASEINQUAD:
      return InterpolateEaseInQuad(t)
      break
    case InterpolationType.EASEOUTQUAD:
      return InterpolateEaseOutQuad(t)
      break
    case InterpolationType.EASEQUAD:
      return InterpolateEaseQuad(t)
      break
    case InterpolationType.EASEINSINE:
      return InterpolateEaseInSine(t)
      break
    case InterpolationType.EASEOUTSINE:
      return InterpolateEaseOutSine(t)
      break
    case InterpolationType.EASESINE:
      return InterpolateEaseInOutSine(t)
      break
    case InterpolationType.EASEINEXPO:
      return InterpolateEaseInExpo(t)
      break
    case InterpolationType.EASEOUTEXPO:
      return InterpolateEaseOutExpo(t)
      break
    case InterpolationType.EASEEXPO:
      return InterpolateEaseInOutExpo(t)
      break
    case InterpolationType.EASEINELASTIC:
      return InterpolateEaseInElastic(t)
      break
    case InterpolationType.EASEOUTELASTIC:
      return InterpolateEaseOutElastic(t)
      break
    case InterpolationType.EASEELASTIC:
      return InterpolateEaseInOutElastic(t)
      break
    case InterpolationType.EASEINBOUNCE:
      return InterpolateEaseInBounce(t)
      break
    case InterpolationType.EASEOUTEBOUNCE:
      return InterpolateEaseOutBounce(t)
      break
    case InterpolationType.EASEBOUNCE:
      return InterpolateEaseInOutBounce(t)
      break
    default:
      return InterpolateLinear(t)
  }
}
function InterpolateLinear(t: number): number {
  return t
}
function InterpolateEaseInQuad(t: number): number {
  return t * t
}
function InterpolateEaseOutQuad(t: number): number {
  return t * (2 - t)
}
function InterpolateEaseQuad(t: number): number {
  return (t * t) / (2.0 * (t * t - t) + 1.0)
}

function InterpolateEaseInSine(t: number): number {
  return 1 - Math.cos((t * Math.PI) / 2)
}

function InterpolateEaseOutSine(t: number): number {
  return Math.sin((t * Math.PI) / 2)
}

function InterpolateEaseInOutSine(t: number): number {
  return -(Math.cos(Math.PI * t) - 1) / 2
}

function InterpolateEaseInExpo(t: number): number {
  return t === 0 ? 0 : Math.pow(2, 10 * t - 10)
}

function InterpolateEaseOutExpo(t: number): number {
  return t === 1 ? 1 : 1 - Math.pow(2, -10 * t)
}

function InterpolateEaseInOutExpo(t: number): number {
  return t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2
}

function InterpolateEaseInElastic(t: number): number {
  const c4 = (2 * Math.PI) / 3

  return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4)
}

function InterpolateEaseOutElastic(t: number): number {
  const c5 = (2 * Math.PI) / 3

  return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c5) + 1
}

function InterpolateEaseInOutElastic(t: number): number {
  const c6 = (2 * Math.PI) / 4.5

  return t === 0
    ? 0
    : t === 1
    ? 1
    : t < 0.5
    ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c6)) / 2
    : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c6)) / 2 + 1
}

function InterpolateEaseInBounce(t: number): number {
  return 1 - bounce(1 - t)
}

function InterpolateEaseOutBounce(t: number): number {
  return bounce(t)
}

function InterpolateEaseInOutBounce(t: number): number {
  return t < 0.5 ? (1 - bounce(1 - 2 * t)) / 2 : (1 + bounce(2 * t - 1)) / 2
}

function bounce(x: number) {
  const n1 = 7.5625
  const d1 = 2.75

  if (x < 1 / d1) {
    return n1 * x * x
  } else if (x < 2 / d1) {
    return n1 * (x -= 1.5 / d1) * x + 0.75
  } else if (x < 2.5 / d1) {
    return n1 * (x -= 2.25 / d1) * x + 0.9375
  } else {
    return n1 * (x -= 2.625 / d1) * x + 0.984375
  }
}

const COMPONENT_IDs = {
        enemyShip: 2228,
        moveTransform: 2229,
        enemySpawner: 2230,
        expire: 2231
}

export const EnemyShip = engine.defineComponent({}, COMPONENT_IDs.enemyShip)


const MoveTransportData = {
  hasFinished: Schemas.Boolean,
  start: Schemas.Vector3,
  end: Schemas.Vector3,
  speed:  Schemas.Float,
  normalizedTime: Schemas.Float,
  lerpTime: Schemas.Float,
  interpolationType: Schemas.Enum<InterpolationType>(Schemas.Int)
}

export const MoveTransformComponent = engine.defineComponent(MoveTransportData, COMPONENT_IDs.moveTransform)


// Spawner shapes
export enum SpawnerShape {
        CIRCLE,
        SQUARE,
        TRIANGLE
  }

// Enemy shapes
export enum ShipShapes {
        BLUE = 'models/blueSpaceship.glb',
        RED = 'models/redSpaceship.glb',
        GREEN  = 'models/greenSpaceship.glb'
  }

const SpawnerComponentType = {
  timeToNextSpawn: Schemas.Int,
  spawnerShape: Schemas.Enum<SpawnerShape>(Schemas.Int),
  enemyShape: Schemas.Enum<ShipShapes>(Schemas.String),
  size: Schemas.Int,
}

export const SpawnerComponent = engine.defineComponent(SpawnerComponentType, COMPONENT_IDs.enemySpawner)


export const Expire = engine.defineComponent({timeLeft: Schemas.Float}, COMPONENT_IDs.expire)



// Configuration
const TRAVEL_DISTANCE = 28
const SPEED = 2
const MAX_TRAVEL_SPEED_OFFSET = 0.2



export function spawnEnemy(shape: ShipShapes, x:number, y: number, z: number): Entity {
  const enemy = engine.addEntity()

  Transform.create(enemy, {
    position: Vector3.create(x, y, z)
  })

  GltfContainer.create(enemy, {
    src: shape
  })

  MoveTransformComponent.create(enemy, {
    start: { x: x, y: y, z: z },
    end: { x: x, y: y, z: z - TRAVEL_DISTANCE },
    speed: SPEED/10 + Math.random() * (MAX_TRAVEL_SPEED_OFFSET/10),
    normalizedTime: 0,
    lerpTime: 0,
    hasFinished: false,
    interpolationType: InterpolationType.EASEINSINE
  })

  EnemyShip.create(enemy)

  return enemy
}


export function destroyEnemy(entity: Entity){
        MoveTransformComponent.deleteFrom(entity)
        EnemyShip.deleteFrom(entity)
        GltfContainer.createOrReplace(entity,{
                src: 'models/glowingSpaceship.glb'
        })
        AudioSource.create(entity, {
                audioClipUrl: 'sounds/explosion.mp3',
                playing: true,
                volume: 2
        })
        
        Expire.create(entity, {
                timeLeft: 1
        })
}"
/* item pickup */,"import { Vector3 } from ""@dcl/sdk/math"";
import { engine, GltfContainer, Transform, AudioSource, Entity, VisibilityComponent } from ""@dcl/sdk/ecs"";
import { engine, Schemas } from ""@dcl/sdk/ecs"";

enum CustomComponentIds {
    PickableItem = 2002
}

export const PickableItem = engine.defineComponent({
    respawnSeconds: Schemas.Number,
    respawnTimer: Schemas.Number,
    playerDetectionArea: Schemas.Vector3
}, CustomComponentIds.PickableItem) 


export function instantiatePickableItem(modelPath: string, pos: Vector3, sfxPath: string, respawnSeconds: number) {
    const entity = engine.addEntity()
    GltfContainer.create(entity, {
        src: modelPath
    })
    
    VisibilityComponent.create(entity)
    
    Transform.create(entity, {
        position: pos
    })
    
    AudioSource.create(entity, {
        audioClipUrl: sfxPath,
        playing: false,
        loop: false
    })
    
    PickableItem.create(entity, {
        respawnSeconds: respawnSeconds,
        respawnTimer: -1,
        playerDetectionArea: Vector3.create(1.5, 3, 1.5)
    })
}

function isPositionInsidePickUpArea(targetPosition: Vector3, pickableItemEntity: Entity): boolean {
    const pickableItemComp = PickableItem.get(pickableItemEntity)
    const transformComp = Transform.get(pickableItemEntity)

    const detectionAreaCenter = transformComp.position
    const detectionAreaSize = pickableItemComp.playerDetectionArea

    const halfSize = Vector3.scale(detectionAreaSize, 0.5)
    const areaMinPosition = Vector3.create(
        detectionAreaCenter.x - halfSize.x,
        detectionAreaCenter.y - halfSize.y,
        detectionAreaCenter.z - halfSize.z
    )
    const areaMaxPosition = Vector3.create(
        detectionAreaCenter.x + halfSize.x,
        detectionAreaCenter.y + halfSize.y,
        detectionAreaCenter.z + halfSize.z
    )

    return targetPosition.x > areaMinPosition.x
        && targetPosition.y > areaMinPosition.y
        && targetPosition.z > areaMinPosition.z
        && targetPosition.x < areaMaxPosition.x
        && targetPosition.y < areaMaxPosition.y
        && targetPosition.z < areaMaxPosition.z
}

let lastPlayerPos: Vector3 | undefined = undefined
export function itemPickupSystem(deltaTime: number) {
    if (!Transform.has(engine.PlayerEntity)) return

    const playerPos = Transform.get(engine.PlayerEntity).position
    const moved = playerPos != lastPlayerPos

    for (const [entity] of engine.getEntitiesWith(PickableItem)) {
        const visibilityComp = VisibilityComponent.getMutable(entity)
        const pickableItemComp = PickableItem.getMutable(entity)

        if (visibilityComp.visible) {
            if (moved && isPositionInsidePickUpArea(playerPos, entity)) {
                // Pick item
                visibilityComp.visible = false
                pickableItemComp.respawnTimer = pickableItemComp.respawnSeconds
                AudioSource.getMutable(entity).playing = true
            }
        } else {
            pickableItemComp.respawnTimer -= deltaTime

            // Respawn item
            if (pickableItemComp.respawnTimer <= 0) {
                visibilityComp.visible = true
            }
        }
    }

    lastPlayerPos = playerPos
}"
/* Moving platform */,"import {
    engine,
    GltfContainer,
    Transform
} from ""@dcl/sdk/ecs""
import { Vector3 } from ""@dcl/sdk/math"";
import { engine, Schemas } from ""@dcl/sdk/ecs"";

enum CustomComponentIds {
    MovingPlatform = 2002,
    TriggerArea = 2003
}

export const MovingPlatform = engine.defineComponent(
    {
        waypoints: Schemas.Array(Schemas.Vector3),
        previousWaypointIndex: Schemas.Number,
        targetWaypointIndex: Schemas.Number,
        currentLerpTimeBetweenWaypoints: Schemas.Number,
        speed: Schemas.Number,
        pingPong: Schemas.Boolean,
        moving: Schemas.Boolean
    },
    CustomComponentIds.MovingPlatform
)
export const TriggerArea = engine.defineComponent(
    {
        size: Schemas.Vector3,
        centerOffset: Schemas.Vector3
    }, CustomComponentIds.TriggerArea
)
export function createMovingPlatform(modelPath: string, waypoints: Vector3[], travelDurationInSeconds: number, triggerAreaSize: Vector3 | undefined = undefined) {
    const entity = engine.addEntity()
    GltfContainer.create(entity, {
        src: modelPath
    })
    Transform.create(entity, {
        position: waypoints[0]
    })
    MovingPlatform.create(entity, {
        waypoints,
        previousWaypointIndex: 0,
        targetWaypointIndex: 1,
        currentLerpTimeBetweenWaypoints: 0,
        speed: calculateMovementSpeed(waypoints, travelDurationInSeconds),
        pingPong: true,
        moving: !triggerAreaSize
    })
    
    if (triggerAreaSize) {
        TriggerArea.create(entity, {
            size: triggerAreaSize,
            centerOffset: Vector3.create(0, triggerAreaSize.y/2, 0)
        })
    }
}

export function platformsMovementSystem(deltaTime: number) {
    for (const [entity] of engine.getEntitiesWith(MovingPlatform)) {
        const movingPlatformComp = MovingPlatform.getMutable(entity)
        
        if (!movingPlatformComp.moving) continue
        
        movingPlatformComp.currentLerpTimeBetweenWaypoints += movingPlatformComp.speed * deltaTime

        Transform.getMutable(entity).position = Vector3.lerp(
            movingPlatformComp.waypoints[movingPlatformComp.previousWaypointIndex],
            movingPlatformComp.waypoints[movingPlatformComp.targetWaypointIndex],
            movingPlatformComp.currentLerpTimeBetweenWaypoints
        )
        
        if (movingPlatformComp.currentLerpTimeBetweenWaypoints >= 1) {
            movingPlatformComp.currentLerpTimeBetweenWaypoints = 0
            const isMovingForward = movingPlatformComp.targetWaypointIndex > movingPlatformComp.previousWaypointIndex
            
            if (isLastWaypoint(movingPlatformComp.targetWaypointIndex, movingPlatformComp.waypoints, isMovingForward)) {
                if (movingPlatformComp.pingPong) {
                    const currentWaypointIndex = movingPlatformComp.targetWaypointIndex
                    movingPlatformComp.targetWaypointIndex = movingPlatformComp.previousWaypointIndex
                    movingPlatformComp.previousWaypointIndex = currentWaypointIndex 
                } else {
                    movingPlatformComp.moving = false
                }
            } else {
                if (isMovingForward) {
                    movingPlatformComp.targetWaypointIndex++
                    movingPlatformComp.previousWaypointIndex++
                } else {
                    movingPlatformComp.targetWaypointIndex--
                    movingPlatformComp.previousWaypointIndex--
                }
            }
        }
    }
}

function calculateMovementSpeed (waypoints: Vector3[], targetTimeInSeconds: number) {
    let totalPathMagnitude = 0
    for (let i = 0; i < waypoints.length-1; i++) {
        totalPathMagnitude += Vector3.length(Vector3.subtract(waypoints[i+1], waypoints[i]))
    }
    
    return totalPathMagnitude / targetTimeInSeconds
}

function isLastWaypoint(targetWaypointIndex: number, waypoints: Vector3[], isMovingForward: Boolean): Boolean {
    return isMovingForward ? targetWaypointIndex == waypoints.length-1 : targetWaypointIndex == 0
}"
/* pickable coin */,"import { Vector3 } from ""@dcl/sdk/math"";
import {engine, GltfContainer, Transform, VisibilityComponent} from ""@dcl/sdk/ecs"";
import { engine, Schemas } from ""@dcl/sdk/ecs"";

enum CustomComponentIds {
    MovingPlatform = 2002,
    TriggerArea = 2003
}

export const MovingPlatform = engine.defineComponent(
    {
        waypoints: Schemas.Array(Schemas.Vector3),
        previousWaypointIndex: Schemas.Number,
        targetWaypointIndex: Schemas.Number,
        currentLerpTimeBetweenWaypoints: Schemas.Number,
        speed: Schemas.Number,
        pingPong: Schemas.Boolean,
        moving: Schemas.Boolean
    },
    CustomComponentIds.MovingPlatform
)
export const TriggerArea = engine.defineComponent(
    {
        size: Schemas.Vector3,
        centerOffset: Schemas.Vector3
    }, CustomComponentIds.TriggerArea
)
export function createPickableCoin(position: Vector3, pickUpAreaSize: Vector3) {
    const entity = engine.addEntity()
    GltfContainer.create(entity, {
        src: ""models/starCoin.glb""
    })
    VisibilityComponent.create(entity, {
        visible: true
    })
    Transform.create(entity, {
        position 
    })
    TriggerArea.create(entity, {
        size: pickUpAreaSize
    })
}"
/* trigger area */,"import { engine, Entity, VisibilityComponent, Transform, AudioSource } from ""@dcl/sdk/ecs"";
import { engine, Schemas } from ""@dcl/sdk/ecs"";

enum CustomComponentIds {
    MovingPlatform = 2002,
    TriggerArea = 2003
}

export const MovingPlatform = engine.defineComponent(
    {
        waypoints: Schemas.Array(Schemas.Vector3),
        previousWaypointIndex: Schemas.Number,
        targetWaypointIndex: Schemas.Number,
        currentLerpTimeBetweenWaypoints: Schemas.Number,
        speed: Schemas.Number,
        pingPong: Schemas.Boolean,
        moving: Schemas.Boolean
    },
    CustomComponentIds.MovingPlatform
)
export const TriggerArea = engine.defineComponent(
    {
        size: Schemas.Vector3,
        centerOffset: Schemas.Vector3
    }, CustomComponentIds.TriggerArea
)

import { Vector3 } from ""@dcl/sdk/math"";

// Optimization: detections could be optimized by using ""sphere checks"" checking the ""area radius"" against he player distance to the trigger area.

function isPositionInsideTriggerArea(targetPosition: Vector3, areaEntity: Entity): boolean {
    const triggerAreaComp = TriggerArea.get(areaEntity)
    const transformComp = Transform.get(areaEntity)

    const detectionAreaCenter = Vector3.add(transformComp.position, triggerAreaComp.centerOffset)
    const detectionAreaSize = triggerAreaComp.size

    const halfSize = Vector3.scale(detectionAreaSize, 0.5)
    const areaMinPosition = Vector3.create(
        detectionAreaCenter.x - halfSize.x,
        detectionAreaCenter.y - halfSize.y,
        detectionAreaCenter.z - halfSize.z
    )
    const areaMaxPosition = Vector3.create(
        detectionAreaCenter.x + halfSize.x,
        detectionAreaCenter.y + halfSize.y,
        detectionAreaCenter.z + halfSize.z
    )

    return targetPosition.x > areaMinPosition.x
        && targetPosition.y > areaMinPosition.y
        && targetPosition.z > areaMinPosition.z
        && targetPosition.x < areaMaxPosition.x
        && targetPosition.y < areaMaxPosition.y
        && targetPosition.z < areaMaxPosition.z
}

let lastPlayerPos: Vector3 | undefined = undefined
export function triggerAreaDetectionSystem(deltaTime: number) {
    if (!Transform.has(engine.PlayerEntity)) return

    const playerPos = Transform.get(engine.PlayerEntity).position
    const moved = playerPos != lastPlayerPos
    if (!moved) return
    
    for (const [entity] of engine.getEntitiesWith(TriggerArea)) {
        const playerInsideArea = isPositionInsideTriggerArea(playerPos, entity)

        const movingPlatformComp = MovingPlatform.getMutableOrNull(entity)
        if (movingPlatformComp) {
            movingPlatformComp.moving = playerInsideArea
            continue
        }

        // the only other case with a trigger area is the pickable coin
        const coinVisibilityComp = VisibilityComponent.getMutable(entity)
        if (playerInsideArea && coinVisibilityComp.visible) {
            coinVisibilityComp.visible = false
            AudioSource.create(entity, {
                audioClipUrl: ""sounds/coinPickup.mp3"",
                playing: true,
                loop: false
            })
        }
    }

    lastPlayerPos = playerPos
}"
/* power cube */,"import {
  engine,
  GltfContainer,
  InputAction,
  PBPointerEvents,
  PointerEventType,
  PointerEvents,
  Schemas,
  Transform,
} from ""@dcl/sdk/ecs""
import { Vector3 } from ""@dcl/sdk/math""
import { engine, Entity, IEngine, Schemas, Transform } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'

function isPositionInsideTriggerArea(
  targetPosition: Vector3,
  areaPosition: Vector3,
  areaSize: Vector3,
  areaCenterOffset: Vector3
): boolean {
  const detectionAreaCenter = Vector3.add(areaPosition, areaCenterOffset)
  const detectionAreaSize = areaSize

  const halfSize = Vector3.scale(detectionAreaSize, 0.5)
  const areaMinPosition = Vector3.create(
    detectionAreaCenter.x - halfSize.x,
    detectionAreaCenter.y - halfSize.y,
    detectionAreaCenter.z - halfSize.z
  )
  const areaMaxPosition = Vector3.create(
    detectionAreaCenter.x + halfSize.x,
    detectionAreaCenter.y + halfSize.y,
    detectionAreaCenter.z + halfSize.z
  )

  return (
    targetPosition.x > areaMinPosition.x &&
    targetPosition.y > areaMinPosition.y &&
    targetPosition.z > areaMinPosition.z &&
    targetPosition.x < areaMaxPosition.x &&
    targetPosition.y < areaMaxPosition.y &&
    targetPosition.z < areaMaxPosition.z
  )
}

export function createTriggerArea(targetEngine: IEngine) {
  const TriggerBox = targetEngine.defineComponent({}, 2004)
  const TriggerArea = targetEngine.defineComponent(
    {
      size: Schemas.Vector3,
      centerOffset: Schemas.Vector3
    },
    2000
  )

  const TriggerState = targetEngine.defineComponent(
    {
      state: Schemas.Array(Schemas.Number)
    },
    2001
  )
  enum EventType {
    Enter,
    Exit
  }
  type EventMapType = Map<EventType, { cb: (entities: Entity[]) => void }>

  const eventsMap = new Map<Entity, EventMapType>()

  function checkTrigger(positionEntity: Entity, position: Vector3) {
    for (const [entity, area, state, transform] of targetEngine.getEntitiesWith(TriggerArea, TriggerState, Transform)) {
      const nextState = isPositionInsideTriggerArea(position, transform.position, area.size, area.centerOffset)
      const stateIndex = state.state.indexOf(positionEntity as number)
      const currentState = stateIndex !== -1

      if (currentState !== nextState) {
        const eventType = nextState ? EventType.Enter : EventType.Exit
        const data = eventsMap.get(entity)?.get(eventType)

        const triggerStateMutable = TriggerState.getMutable(entity)
        if (!currentState) {
          triggerStateMutable.state.push(positionEntity as number)
        } else {
          triggerStateMutable.state = triggerStateMutable.state.filter((item) => item !== positionEntity)
        }

        if (data) data.cb(triggerStateMutable.state)
      }
    }
  }

  function system() {
    const playerPosition = Transform.getOrNull(targetEngine.PlayerEntity)?.position || Vector3.Zero()
    checkTrigger(engine.PlayerEntity, playerPosition)
    for (const [entity, , transform] of targetEngine.getEntitiesWith(TriggerBox, Transform)) {
      checkTrigger(entity, transform.position)
    }
  }

  targetEngine.addSystem(system)

  return {
    setTriggerArea(entity: Entity, areaSize: Vector3, areaCenterOffset: Vector3) {
      TriggerArea.createOrReplace(entity, {
        size: areaSize,
        centerOffset: areaCenterOffset
      })
      TriggerState.createOrReplace(entity)
    },
    removeTriggerArea(entity: Entity) {
      TriggerArea.deleteFrom(entity)
      TriggerState.deleteFrom(entity)
    },
    onPlayerEnter(entity: Entity, cb: (entities: Entity[]) => void) {
      const event = eventsMap.get(entity) || eventsMap.set(entity, new Map()).get(entity)!
      event.set(EventType.Enter, { cb })
    },
    onPlayerExit(entity: Entity, cb: (entities: Entity[]) => void) {
      const event = eventsMap.get(entity) || eventsMap.set(entity, new Map()).get(entity)!
      event.set(EventType.Exit, { cb })
    },
    removeOnPlayerExit(entity: Entity) {
      eventsMap.get(entity)?.delete(EventType.Exit)
      if (eventsMap.get(entity)?.size === 0) {
        eventsMap.delete(entity)
      }
    },
    removeOnPlayerEnter(entity: Entity) {
      eventsMap.get(entity)?.delete(EventType.Enter)
      if (eventsMap.get(entity)?.size === 0) {
        eventsMap.delete(entity)
      }
    },
    addTriggerBox(entity: Entity) {
      TriggerBox.createOrReplace(entity)
    },
    removeTriggerBox(entity: Entity) {
      TriggerBox.deleteFrom(entity)
    }
  }
}

export const triggerAreaSystem = createTriggerArea(engine)


export const PowerCube = engine.defineComponent(
  {
    isGrabbed: Schemas.Boolean,
  },
  2003
)

export function createPowerCube(position: Vector3, gltfSrc: string) {
  const entity = engine.addEntity()

  const phf: PBPointerEvents = {
    pointerEvents: [
      {
        eventType: PointerEventType.PET_DOWN,
        eventInfo: {
          button: InputAction.IA_PRIMARY,
          hoverText: ""Pick Up / Put Down"",
          maxDistance: 5,
        },
      },
    ],
  }
  PointerEvents.create(entity, phf)

  triggerAreaSystem.addTriggerBox(entity)
  // const triggerBox = new utils.TriggerBoxShape(Vector3.One(), Vector3.Zero())
  // this.addComponent(new utils.TriggerComponent(triggerBox, { layer: 1 }))

  Transform.create(entity, { position })
  GltfContainer.create(entity, { src: gltfSrc })
  PowerCube.create(entity)
  return entity
}"
/* power base */ ,"import { AudioSource, engine, GltfContainer, Transform, VisibilityComponent } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'
import { engine, Material, MeshRenderer, PBMaterial_PbrMaterial, Schemas, Transform } from '@dcl/sdk/ecs'
import { Color3, Quaternion, Vector3 } from '@dcl/sdk/math'

// @Component('particle')
// export class Particle {
//   life = Math.random()
//   seed = Math.random() * this.width
//   constructor(public width: number, public height: number, public speed: number, public parentTransform: Entity) {}
// }

// Particles
export const Particle = engine.defineComponent(
  {
    life: Schemas.Float,
    seed: Schemas.Float,
    width: Schemas.Number,
    height: Schemas.Number,
    speed: Schemas.Number
  },
  3004
)

export function particleSystem(dt: number) {
  for (const [entity] of engine.getEntitiesWith(Particle, Transform)) {
    const particle = Particle.getMutable(entity)

    particle.life += dt * particle.speed // Particle speed
    particle.life %= 1 // Reset particle life

    const transform = Transform.getMutable(entity)
    transform.position = Vector3.create(0, particle.life * particle.height, 0 - particle.seed)
  }
}

// Setup particles
const material: PBMaterial_PbrMaterial = {
  metallic: 1,
  albedoColor: Color3.create(0.5, 1.5, 2),
  emissiveColor: Color3.create(0.5, 1.5, 2)
}

// Position particles with a
const particleParentEntity = engine.addEntity()
Transform.create(particleParentEntity, {
  position: Vector3.create(16, 0, 10),
  rotation: Quaternion.fromEulerDegrees(0, 90, 0)
})

// Initialise particles
const MAX_PARTICLES = 256

for (let i = 0; i < MAX_PARTICLES; i++) {
  const particleEntity = engine.addEntity()
  MeshRenderer.setPlane(particleEntity)
  Material.setPbrMaterial(particleEntity, material)
  Particle.create(particleEntity, {
    life: Math.random(),
    seed: 16 * Math.random(),
    height: 7,
    speed: 0.25
  })

  Transform.create(particleEntity, {
    rotation: Quaternion.fromEulerDegrees(0, 90, 0),
    scale: Vector3.create(0.01, 0.1, 1),
    parent: particleParentEntity
  })
}


import { AudioSource, AvatarAttach, engine, Transform } from '@dcl/sdk/ecs'

export function createSound(src: string) {
  const entity = engine.addEntity()
  Transform.create(entity)
  AudioSource.create(entity, { audioClipUrl: src, playing: false })
  return entity
}


import { engine, Entity, IEngine, Schemas, Transform } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'

function isPositionInsideTriggerArea(
  targetPosition: Vector3,
  areaPosition: Vector3,
  areaSize: Vector3,
  areaCenterOffset: Vector3
): boolean {
  const detectionAreaCenter = Vector3.add(areaPosition, areaCenterOffset)
  const detectionAreaSize = areaSize

  const halfSize = Vector3.scale(detectionAreaSize, 0.5)
  const areaMinPosition = Vector3.create(
    detectionAreaCenter.x - halfSize.x,
    detectionAreaCenter.y - halfSize.y,
    detectionAreaCenter.z - halfSize.z
  )
  const areaMaxPosition = Vector3.create(
    detectionAreaCenter.x + halfSize.x,
    detectionAreaCenter.y + halfSize.y,
    detectionAreaCenter.z + halfSize.z
  )

  return (
    targetPosition.x > areaMinPosition.x &&
    targetPosition.y > areaMinPosition.y &&
    targetPosition.z > areaMinPosition.z &&
    targetPosition.x < areaMaxPosition.x &&
    targetPosition.y < areaMaxPosition.y &&
    targetPosition.z < areaMaxPosition.z
  )
}

export function createTriggerArea(targetEngine: IEngine) {
  const TriggerBox = targetEngine.defineComponent({}, 2004)
  const TriggerArea = targetEngine.defineComponent(
    {
      size: Schemas.Vector3,
      centerOffset: Schemas.Vector3
    },
    2000
  )

  const TriggerState = targetEngine.defineComponent(
    {
      state: Schemas.Array(Schemas.Number)
    },
    2001
  )
  enum EventType {
    Enter,
    Exit
  }
  type EventMapType = Map<EventType, { cb: (entities: Entity[]) => void }>

  const eventsMap = new Map<Entity, EventMapType>()

  function checkTrigger(positionEntity: Entity, position: Vector3) {
    for (const [entity, area, state, transform] of targetEngine.getEntitiesWith(TriggerArea, TriggerState, Transform)) {
      const nextState = isPositionInsideTriggerArea(position, transform.position, area.size, area.centerOffset)
      const stateIndex = state.state.indexOf(positionEntity as number)
      const currentState = stateIndex !== -1

      if (currentState !== nextState) {
        const eventType = nextState ? EventType.Enter : EventType.Exit
        const data = eventsMap.get(entity)?.get(eventType)

        const triggerStateMutable = TriggerState.getMutable(entity)
        if (!currentState) {
          triggerStateMutable.state.push(positionEntity as number)
        } else {
          triggerStateMutable.state = triggerStateMutable.state.filter((item) => item !== positionEntity)
        }

        if (data) data.cb(triggerStateMutable.state)
      }
    }
  }

  function system() {
    const playerPosition = Transform.getOrNull(targetEngine.PlayerEntity)?.position || Vector3.Zero()
    checkTrigger(engine.PlayerEntity, playerPosition)
    for (const [entity, , transform] of targetEngine.getEntitiesWith(TriggerBox, Transform)) {
      checkTrigger(entity, transform.position)
    }
  }

  targetEngine.addSystem(system)

  return {
    setTriggerArea(entity: Entity, areaSize: Vector3, areaCenterOffset: Vector3) {
      TriggerArea.createOrReplace(entity, {
        size: areaSize,
        centerOffset: areaCenterOffset
      })
      TriggerState.createOrReplace(entity)
    },
    removeTriggerArea(entity: Entity) {
      TriggerArea.deleteFrom(entity)
      TriggerState.deleteFrom(entity)
    },
    onPlayerEnter(entity: Entity, cb: (entities: Entity[]) => void) {
      const event = eventsMap.get(entity) || eventsMap.set(entity, new Map()).get(entity)!
      event.set(EventType.Enter, { cb })
    },
    onPlayerExit(entity: Entity, cb: (entities: Entity[]) => void) {
      const event = eventsMap.get(entity) || eventsMap.set(entity, new Map()).get(entity)!
      event.set(EventType.Exit, { cb })
    },
    removeOnPlayerExit(entity: Entity) {
      eventsMap.get(entity)?.delete(EventType.Exit)
      if (eventsMap.get(entity)?.size === 0) {
        eventsMap.delete(entity)
      }
    },
    removeOnPlayerEnter(entity: Entity) {
      eventsMap.get(entity)?.delete(EventType.Enter)
      if (eventsMap.get(entity)?.size === 0) {
        eventsMap.delete(entity)
      }
    },
    addTriggerBox(entity: Entity) {
      TriggerBox.createOrReplace(entity)
    },
    removeTriggerBox(entity: Entity) {
      TriggerBox.deleteFrom(entity)
    }
  }
}

export const triggerAreaSystem = createTriggerArea(engine)
// Power glows
const powerBlueGlowEntity = engine.addEntity()
GltfContainer.create(powerBlueGlowEntity, { src: 'models/powerBlueGlow.glb' })
Transform.create(powerBlueGlowEntity)

const powerRedGlowEntity = engine.addEntity()
GltfContainer.create(powerRedGlowEntity, { src: 'models/powerRedGlow.glb' })
Transform.create(powerRedGlowEntity)

// Forcefield
const forcefieldEntity = engine.addEntity()
GltfContainer.create(forcefieldEntity, { src: 'models/forcefield.glb' })
Transform.create(forcefieldEntity)

// Sounds
const powerUp = createSound('sounds/powerUp.mp3')
const powerDown = createSound('sounds/powerDown.mp3')

export function createPowerBase(position: Vector3, gltfSrc: string) {
  const entity = engine.addEntity()

  Transform.create(entity, { position })
  GltfContainer.create(entity, { src: gltfSrc })

  function togglePower(isPowerOn: boolean) {
    if (isPowerOn) {
      // TODO: change this workaround until the DisableComponent is available
      Transform.getMutable(powerBlueGlowEntity).scale = Vector3.One()
      Transform.getMutable(forcefieldEntity).scale = Vector3.One()

      try {
        engine.addSystem(particleSystem)
      } catch (err) { }
      AudioSource.getMutable(powerUp).playing = true

      for (const [entity] of engine.getEntitiesWith(Particle)) {
        VisibilityComponent.deleteFrom(entity)
      }
    } else {
      // NOTE: particles have colliders so need to move them elsewhere
      for (const [entity] of engine.getEntitiesWith(Particle)) {
        VisibilityComponent.createOrReplace(entity, { visible: false })
      }

      // TODO: change this workaround until the DisableComponent is available
      // Hide the blue glow
      Transform.getMutable(powerBlueGlowEntity).scale = Vector3.Zero()
      Transform.getMutable(forcefieldEntity).scale = Vector3.Zero()

      engine.removeSystem(particleSystem)
      AudioSource.getMutable(powerDown).playing = true
    }
  }

  triggerAreaSystem.setTriggerArea(entity, Vector3.create(4, 4, 4), Vector3.create(0, 0.75, 0))
  triggerAreaSystem.onPlayerEnter(entity, (args) => {
    console.log('on enter', { args })
    if (args.length > 0) togglePower(true)
  })

  triggerAreaSystem.onPlayerExit(entity, (args) => {
    console.log('on exit', { args })
    if (args.length === 0) togglePower(false)
  })
}
"
/* card */ ,"mport { AudioSource, engine, GltfContainer, Transform } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'
import { AudioSource, AvatarAttach, engine, Transform } from '@dcl/sdk/ecs'

export function createSound(src: string) {
  const entity = engine.addEntity()
  Transform.create(entity)
  AudioSource.create(entity, { audioClipUrl: src, playing: false })
  return entity
}

import { engine, Entity, IEngine, Schemas, Transform } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'

function isPositionInsideTriggerArea(
  targetPosition: Vector3,
  areaPosition: Vector3,
  areaSize: Vector3,
  areaCenterOffset: Vector3
): boolean {
  const detectionAreaCenter = Vector3.add(areaPosition, areaCenterOffset)
  const detectionAreaSize = areaSize

  const halfSize = Vector3.scale(detectionAreaSize, 0.5)
  const areaMinPosition = Vector3.create(
    detectionAreaCenter.x - halfSize.x,
    detectionAreaCenter.y - halfSize.y,
    detectionAreaCenter.z - halfSize.z
  )
  const areaMaxPosition = Vector3.create(
    detectionAreaCenter.x + halfSize.x,
    detectionAreaCenter.y + halfSize.y,
    detectionAreaCenter.z + halfSize.z
  )

  return (
    targetPosition.x > areaMinPosition.x &&
    targetPosition.y > areaMinPosition.y &&
    targetPosition.z > areaMinPosition.z &&
    targetPosition.x < areaMaxPosition.x &&
    targetPosition.y < areaMaxPosition.y &&
    targetPosition.z < areaMaxPosition.z
  )
}

export function createTriggerArea(targetEngine: IEngine) {
  const TriggerBox = targetEngine.defineComponent({}, 2004)
  const TriggerArea = targetEngine.defineComponent(
    {
      size: Schemas.Vector3,
      centerOffset: Schemas.Vector3
    },
    2000
  )

  const TriggerState = targetEngine.defineComponent(
    {
      state: Schemas.Array(Schemas.Number)
    },
    2001
  )
  enum EventType {
    Enter,
    Exit
  }
  type EventMapType = Map<EventType, { cb: (entities: Entity[]) => void }>

  const eventsMap = new Map<Entity, EventMapType>()

  function checkTrigger(positionEntity: Entity, position: Vector3) {
    for (const [entity, area, state, transform] of targetEngine.getEntitiesWith(TriggerArea, TriggerState, Transform)) {
      const nextState = isPositionInsideTriggerArea(position, transform.position, area.size, area.centerOffset)
      const stateIndex = state.state.indexOf(positionEntity as number)
      const currentState = stateIndex !== -1

      if (currentState !== nextState) {
        const eventType = nextState ? EventType.Enter : EventType.Exit
        const data = eventsMap.get(entity)?.get(eventType)

        const triggerStateMutable = TriggerState.getMutable(entity)
        if (!currentState) {
          triggerStateMutable.state.push(positionEntity as number)
        } else {
          triggerStateMutable.state = triggerStateMutable.state.filter((item) => item !== positionEntity)
        }

        if (data) data.cb(triggerStateMutable.state)
      }
    }
  }

  function system() {
    const playerPosition = Transform.getOrNull(targetEngine.PlayerEntity)?.position || Vector3.Zero()
    checkTrigger(engine.PlayerEntity, playerPosition)
    for (const [entity, , transform] of targetEngine.getEntitiesWith(TriggerBox, Transform)) {
      checkTrigger(entity, transform.position)
    }
  }

  targetEngine.addSystem(system)

  return {
    setTriggerArea(entity: Entity, areaSize: Vector3, areaCenterOffset: Vector3) {
      TriggerArea.createOrReplace(entity, {
        size: areaSize,
        centerOffset: areaCenterOffset
      })
      TriggerState.createOrReplace(entity)
    },
    removeTriggerArea(entity: Entity) {
      TriggerArea.deleteFrom(entity)
      TriggerState.deleteFrom(entity)
    },
    onPlayerEnter(entity: Entity, cb: (entities: Entity[]) => void) {
      const event = eventsMap.get(entity) || eventsMap.set(entity, new Map()).get(entity)!
      event.set(EventType.Enter, { cb })
    },
    onPlayerExit(entity: Entity, cb: (entities: Entity[]) => void) {
      const event = eventsMap.get(entity) || eventsMap.set(entity, new Map()).get(entity)!
      event.set(EventType.Exit, { cb })
    },
    removeOnPlayerExit(entity: Entity) {
      eventsMap.get(entity)?.delete(EventType.Exit)
      if (eventsMap.get(entity)?.size === 0) {
        eventsMap.delete(entity)
      }
    },
    removeOnPlayerEnter(entity: Entity) {
      eventsMap.get(entity)?.delete(EventType.Enter)
      if (eventsMap.get(entity)?.size === 0) {
        eventsMap.delete(entity)
      }
    },
    addTriggerBox(entity: Entity) {
      TriggerBox.createOrReplace(entity)
    },
    removeTriggerBox(entity: Entity) {
      TriggerBox.deleteFrom(entity)
    }
  }
}

export const triggerAreaSystem = createTriggerArea(engine)
/**
 * Sound is a separated from the card entity so that you can
 * still hear it even when the card is removed from the engine.
 */
const cardPickupSound = createSound('sounds/cardPickup.mp3')

export function createCard(position: Vector3, gltfSrc: string) {
  const entity = engine.addEntity()

  Transform.create(entity, { position })
  GltfContainer.create(entity, { src: gltfSrc })

  triggerAreaSystem.setTriggerArea(entity, Vector3.add(position, Vector3.create(1, 1, 1)), Vector3.create(0, 0.75, 0))
  triggerAreaSystem.onPlayerEnter(entity, () => {
    Transform.getMutable(entity).scale = Vector3.Zero()
    AudioSource.getMutable(cardPickupSound).playing = true
  })

  triggerAreaSystem.onPlayerExit(entity, () => {
    triggerAreaSystem.removeTriggerArea(entity)
    engine.removeEntity(entity)
  })
}"
/* rotating platform */,"//import * as utils from '@dcl/ecs-scene-utils'
import { engine, Entity, GltfContainer, Transform, TransformType } from '@dcl/sdk/ecs'
import { Quaternion } from '@dcl/sdk/math'
import { engine, Entity, IEngine, Schemas, Transform } from ""@dcl/sdk/ecs""
import { Quaternion, Vector3 } from ""@dcl/sdk/math""


enum EventType {
  Finish
}
type EventMapType = Map<EventType, { cb: (entities: Entity[]) => void }>


const KeepRotating = engine.defineComponent({
  rotationVelocity: Schemas.Quaternion,
  rotation: Schemas.Quaternion,
  finished: Schemas.Boolean
}, 2008)
  

const KeepRotatingState = engine.defineComponent(
  {
      state: Schemas.Array(Schemas.Number)
  },
  2009
)

/**
 * OOP to create a system
 * Usage: KeepRotatingSystem.instance.addKeepRotating(entity,rotation);
 */
export class KeepRotatingSystem{
  private static _instance: KeepRotatingSystem | null = null
  static get instance(): KeepRotatingSystem {
    return this.createAndAddToEngine()
  }
  private systemFnCache!:(dt:number)=>void
  private eventsMap = new Map<Entity, EventMapType>()
    
  private constructor() {
    KeepRotatingSystem._instance = this
    
  }

  static createAndAddToEngine(): KeepRotatingSystem {
    if (this._instance == null) {
      this._instance = new KeepRotatingSystem()
      engine.addSystem(this._instance.system)
    }
    return this._instance
  }

  createUpdateFn(){
    if(this.systemFnCache === undefined){
      console.log(""createUpdateFn"",this)
      this.systemFnCache = (dt:number)=>{
        //log(""createUpdateFn called"",this)
        this.system(dt)
      }
    }
    return this.systemFnCache
  }

  system(dt:number) {
    //console.log(""class.system"")
    for (const [entity, keepRotating, keepRotatingState, transform] of engine.getEntitiesWith(KeepRotating, KeepRotatingState, Transform)) {
        const transform = Transform.getMutable(entity)//entity.getComponent(Transform)
        const keepRotating = KeepRotating.getMutable(entity)
        
        keepRotating.rotation = Quaternion.slerp(
            Quaternion.Identity(),
            keepRotating.rotationVelocity,
            dt
          )
        transform.rotation = Quaternion.multiply( transform.rotation,keepRotating.rotation)

    }
  }
  addKeepRotating(entity: Entity, rotationVelocity:Quaternion) {
    KeepRotating.createOrReplace(entity, {
          rotation: Quaternion.Identity(),
          rotationVelocity: rotationVelocity,
          finished: false
      })
      KeepRotatingState.createOrReplace(entity)
  }
  removeKeepRotating(entity: Entity) {
      KeepRotating.deleteFrom(entity)
      KeepRotatingState.deleteFrom(entity)
  }
  onFinish(entity: Entity, cb: (entities: Entity[]) => void) {
      const event = this.eventsMap.get(entity) || this.eventsMap.set(entity, new Map()).get(entity)!
      event.set(EventType.Finish, { cb })
  }
  removeOnFinish(entity: Entity) {
      this.eventsMap.get(entity)?.delete(EventType.Finish)
      if (this.eventsMap.get(entity)?.size === 0) {
          this.eventsMap.delete(entity)
      }
  }
}


/**
 * functional programming way to create a system
 * 
 * USAGE
 * export const keepRotatingSystem = createKeepRotatingSystem(engine)
 * keepRotatingSystem.addKeepRotating(entity,rotation);
 * 
 * @param targetEngine 
 * @returns 
 */
export function createKeepRotatingSystem(targetEngine: IEngine) {
    const KeepRotating = targetEngine.defineComponent({
        rotationVelocity: Schemas.Quaternion,
        rotation: Schemas.Quaternion,
        finished: Schemas.Boolean
    }, 2008)
  
    const KeepRotatingState = targetEngine.defineComponent(
        {
            state: Schemas.Array(Schemas.Number)
        },
        2009
    )

    enum EventType {
        Finish
    }
    type EventMapType = Map<EventType, { cb: (entities: Entity[]) => void }>

    const eventsMap = new Map<Entity, EventMapType>()
       
    function system(dt:number) {
        
        for (const [entity, keepRotating, keepRotatingState, transform] of targetEngine.getEntitiesWith(KeepRotating, KeepRotatingState, Transform)) {
            const transform = Transform.getMutable(entity)//entity.getComponent(Transform)
            const keepRotating = KeepRotating.getMutable(entity)
            
            keepRotating.rotation = Quaternion.slerp(
                Quaternion.Identity(),
                keepRotating.rotationVelocity,
                dt
              )
            transform.rotation = Quaternion.multiply( transform.rotation,keepRotating.rotation)

        }
    }

    targetEngine.addSystem(system)

    return {
        addKeepRotating(entity: Entity, rotationVelocity:Quaternion) {
            KeepRotating.createOrReplace(entity, {
                rotation: Quaternion.Identity(),
                rotationVelocity: rotationVelocity,
                finished: false
            })
            KeepRotatingState.createOrReplace(entity)
        },
        removeKeepRotating(entity: Entity) {
            KeepRotating.deleteFrom(entity)
            KeepRotatingState.deleteFrom(entity)
        },
        onFinish(entity: Entity, cb: (entities: Entity[]) => void) {
            const event = eventsMap.get(entity) || eventsMap.set(entity, new Map()).get(entity)!
            event.set(EventType.Finish, { cb })
        },
        removeOnFinish(entity: Entity) {
            eventsMap.get(entity)?.delete(EventType.Finish)
            if (eventsMap.get(entity)?.size === 0) {
                eventsMap.delete(entity)
            }
        }
    }
}   

export function createRotatingPlatform(
  model: string,
  transform:Partial<TransformType>,
  rotation:Quaternion
): Entity {
  const entity = engine.addEntity()
  GltfContainer.create(entity, { src: model })
  Transform.create(entity, transform)

  //TODO DECIDE PATTERN TO USE
  //TODO add keep rotating component
  //keepRotatingSystem.addKeepRotating(entity,rotation);
  KeepRotatingSystem.instance.addKeepRotating(entity,rotation);
  
  return entity
}"
/* crown */,"//import * as utils from '@dcl/ecs-scene-utils'
import { AudioSource, engine, Entity, GltfContainer, Transform,TransformType } from ""@dcl/sdk/ecs""
import { Vector3 } from ""@dcl/sdk/math""
import { engine, Entity, IEngine, Schemas, Transform } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'

function isPositionInsideTriggerArea(
    targetPosition: Vector3,
    areaPosition: Vector3,
    areaSize: Vector3,
    areaCenterOffset: Vector3
): boolean {
    const detectionAreaCenter = Vector3.add(areaPosition, areaCenterOffset)
    const detectionAreaSize = areaSize

    const halfSize = Vector3.scale(detectionAreaSize, 0.5)
    const areaMinPosition = Vector3.create(
        detectionAreaCenter.x - halfSize.x,
        detectionAreaCenter.y - halfSize.y,
        detectionAreaCenter.z - halfSize.z
    )
    const areaMaxPosition = Vector3.create(
        detectionAreaCenter.x + halfSize.x,
        detectionAreaCenter.y + halfSize.y,
        detectionAreaCenter.z + halfSize.z
    )

    return (
        targetPosition.x > areaMinPosition.x &&
        targetPosition.y > areaMinPosition.y &&
        targetPosition.z > areaMinPosition.z &&
        targetPosition.x < areaMaxPosition.x &&
        targetPosition.y < areaMaxPosition.y &&
        targetPosition.z < areaMaxPosition.z
    )
}

export function createTriggerArea(targetEngine: IEngine) {
    const TriggerBox = targetEngine.defineComponent({}, 2004)
    const TriggerArea = targetEngine.defineComponent(
        {
            size: Schemas.Vector3,
            centerOffset: Schemas.Vector3
        },
        2000
    )

    const TriggerState = targetEngine.defineComponent(
        {
            state: Schemas.Array(Schemas.Number)
        },
        2001
    )
    enum EventType {
        Enter,
        Exit
    }
    type EventMapType = Map<EventType, { cb: (entities: Entity[]) => void }>

    const eventsMap = new Map<Entity, EventMapType>()

    function checkTrigger(positionEntity: Entity, position: Vector3) {
        for (const [entity, area, state, transform] of targetEngine.getEntitiesWith(TriggerArea, TriggerState, Transform)) {
            const nextState = isPositionInsideTriggerArea(position, transform.position, area.size, area.centerOffset)
            const stateIndex = state.state.indexOf(positionEntity as number)
            const currentState = stateIndex !== -1

            if (currentState !== nextState) {
                const eventType = nextState ? EventType.Enter : EventType.Exit
                const data = eventsMap.get(entity)?.get(eventType)

                const triggerStateMutable = TriggerState.getMutable(entity)
                if (!currentState) {
                    triggerStateMutable.state.push(positionEntity as number)
                } else {
                    triggerStateMutable.state = triggerStateMutable.state.filter((item) => item !== positionEntity)
                }

                if (data) data.cb(triggerStateMutable.state)
            }
        }
    }

    function system() {
        //FIXME what if zero lines up with trigger location!?!?!
        const playerPosition = Transform.getOrNull(targetEngine.PlayerEntity)?.position
        if(playerPosition) checkTrigger(engine.PlayerEntity, playerPosition) //checks player with ...?
        //WHY need blank comma????
        //what is this loop doing?? checking if trigger areas collide with other trigger areas?
        for (const [entity, , transform] of targetEngine.getEntitiesWith(TriggerBox, Transform)) {
            checkTrigger(entity, transform.position)
        }
    }

    targetEngine.addSystem(system)

    return {
        setTriggerArea(entity: Entity, areaSize: Vector3, areaCenterOffset: Vector3) {
            TriggerArea.createOrReplace(entity, {
                size: areaSize,
                centerOffset: areaCenterOffset
            })
            TriggerState.createOrReplace(entity)
        },
        removeTriggerArea(entity: Entity) {
            TriggerArea.deleteFrom(entity)
            TriggerState.deleteFrom(entity)
        },
        onPlayerEnter(entity: Entity, cb: (entities: Entity[]) => void) {
            const event = eventsMap.get(entity) || eventsMap.set(entity, new Map()).get(entity)!
            event.set(EventType.Enter, { cb })
        },
        onPlayerExit(entity: Entity, cb: (entities: Entity[]) => void) {
            const event = eventsMap.get(entity) || eventsMap.set(entity, new Map()).get(entity)!
            event.set(EventType.Exit, { cb })
        },
        removeOnPlayerExit(entity: Entity) {
            eventsMap.get(entity)?.delete(EventType.Exit)
            if (eventsMap.get(entity)?.size === 0) {
                eventsMap.delete(entity)
            }
        },
        removeOnPlayerEnter(entity: Entity) {
            eventsMap.get(entity)?.delete(EventType.Enter)
            if (eventsMap.get(entity)?.size === 0) {
                eventsMap.delete(entity)
            }
        },
        addTriggerBox(entity: Entity) {
            TriggerBox.createOrReplace(entity)
        },
        removeTriggerBox(entity: Entity) {
            TriggerBox.deleteFrom(entity)
        }
    }
}

export const triggerAreaSystem = createTriggerArea(engine)/*
export class Crown {
  constructor(model: GLTFShape, transform: Transform) {
    super()
    //engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(transform)
    this.addComponent(new AudioSource(new AudioClip('sounds/win.mp3')))
    // Create trigger for crown
    this.addComponent(
      new utils.TriggerComponent(
        new utils.TriggerBoxShape(new Vector3(2.5, 2.5, 2.5)),
        {
          onCameraEnter: () => {
            // Hide the crown and play sound
            this.getComponent(Transform).scale.setAll(0)
            this.getComponent(AudioSource).playOnce()
          },
          onCameraExit: () => {
            this.getComponent(utils.TriggerComponent).enabled = false
          }
        }
      )
    )
  }
}*/

/**
 * Sound is a separated from the coin entity so that you can
 * still hear it even when the coin is removed from the engine.
 */
const crownPickupSound = engine.addEntity()
Transform.create(crownPickupSound)
AudioSource.create(crownPickupSound, { audioClipUrl: 'sounds/win.mp3' })

export function createCrown(
  model: string,
  transform:TransformType
): Entity {
  const entity = engine.addEntity()
  GltfContainer.create(entity, { src: model })
  Transform.create(entity, transform)

  const size = Vector3.create(2.5, 2.5, 2.5)
  const centerOffset = Vector3.Zero()
  
  triggerAreaSystem.setTriggerArea(entity, size, centerOffset)
 
  triggerAreaSystem.onPlayerEnter(entity, () => {
    //how can it detect player enter if is null
    triggerAreaSystem.removeTriggerArea(entity)
    AudioSource.getMutable(crownPickupSound).playing = true 
    const playerPosition = Transform.getOrNull(engine.PlayerEntity)?.position || Vector3.Zero()
    //console.log(""engine.PlayerEntity"",Transform.getOrNull(engine.PlayerEntity),playerPosition,AudioSource.get(crownPickupSound).playing) 
    Transform.getMutable(crownPickupSound).position = playerPosition//.position
    engine.removeEntity(entity)  
  })

  return entity
}"
/* Sprite */,"import { engine, MeshRenderer } from '@dcl/sdk/ecs'
import { engine, Schemas } from '@dcl/sdk/ecs'

enum CustomComponentIds {
  Sprite = 2002
}

export const Sprite = engine.defineComponent(
  {
    t: Schemas.Number,
    rows: Schemas.Number,
    columns: Schemas.Number,
    interval: Schemas.Number,

    faceMappingsX: Schemas.Number,
    faceMappingsY: Schemas.Number
  },
  CustomComponentIds.Sprite
)
export default function updateSpriteFrameSystem(dt: number) {
  for (const [entity] of engine.getEntitiesWith(Sprite, MeshRenderer)) {
    const sprite = Sprite.getMutable(entity)
    sprite.t += dt
    if (sprite.t > sprite.interval) {
      sprite.t -= sprite.interval

      const frameSizeX = 1 / sprite.rows
      const frameSizeY = 1 / sprite.columns
      sprite.faceMappingsX += frameSizeX
      if (sprite.faceMappingsX >= 1) {
        sprite.faceMappingsX = 0
        sprite.faceMappingsY += frameSizeY
        if (sprite.faceMappingsY >= 1) {
          sprite.faceMappingsY = 0
        }
      }

      const mutableMesh = MeshRenderer.getMutable(entity)
      if (mutableMesh.mesh?.$case === 'plane') {
        // Set plane mesh UVs clock-wise starting from the top-left
        mutableMesh.mesh.plane.uvs = [
          sprite.faceMappingsX,
          sprite.faceMappingsY + frameSizeY,
          sprite.faceMappingsX + frameSizeX,
          sprite.faceMappingsY + frameSizeY,
          sprite.faceMappingsX + frameSizeX,
          sprite.faceMappingsY,
          sprite.faceMappingsX,
          sprite.faceMappingsY,
          sprite.faceMappingsX,
          sprite.faceMappingsY + frameSizeY,
          sprite.faceMappingsX + frameSizeX,
          sprite.faceMappingsY + frameSizeY,
          sprite.faceMappingsX + frameSizeX,
          sprite.faceMappingsY,
          sprite.faceMappingsX,
          sprite.faceMappingsY
        ]
      }
    }
  }
}"
/* zombie attack */,"import { Vector3, Quaternion } from ""@dcl/sdk/math"";
import { engine, GltfContainer, Transform, Animator } from ""@dcl/sdk/ecs""
import { engine, Schemas } from ""@dcl/sdk/ecs"";

enum CustomComponentIds {
    Zombie = 2002,
}
export const Zombie = engine.defineComponent(
    {
        movementSpeed: Schemas.Number,
        rotationSpeed: Schemas.Number
    }, CustomComponentIds.Zombie
)
const ZOMBIE_MODEL_PATH = ""models/zombie.glb""
const ATTACK_DISTANCE = 2
const MOVEMENT_SPEED = 1
const ROTATION_SPEED = 1

export function createZombie(position: Vector3) {
    const zombieEntity = engine.addEntity()
    Transform.create(zombieEntity, {
        position
    })
    GltfContainer.create(zombieEntity, {
        src: ZOMBIE_MODEL_PATH
    })
    Animator.create(zombieEntity, {
        states: [{
            name: ""Walking"",
            clip: ""Walking"",
            playing: true,
            loop: true
        }, {
            name: ""Attacking"",
            clip: ""Attacking"",
            loop: true
        }]
    })
    Zombie.create(zombieEntity, {
        movementSpeed: MOVEMENT_SPEED,
        rotationSpeed: ROTATION_SPEED
    })
}

function zombieMovementSystem(deltaTime: number) {
    if (!Transform.has(engine.PlayerEntity)) return
    const playerPos = Transform.get(engine.PlayerEntity).position
    
    for (const [entity] of engine.getEntitiesWith(Zombie)) {
        const transform = Transform.getMutable(entity)
        
        // Rotate to face player
        const lookAtTarget = Vector3.create(
            playerPos.x,
            transform.position.y,
            playerPos.z
        )
        const lookAtDirection = Vector3.subtract(lookAtTarget, transform.position)
        transform.rotation = Quaternion.slerp(
            transform.rotation,
            Quaternion.lookRotation(lookAtDirection),
            ROTATION_SPEED + deltaTime
        )
        
        // Move towards player until it's at attack distance
        const distance = Vector3.distanceSquared(
            transform.position,
            playerPos
        ) // Check distance squared as it's more optimized

        const isInAttackDistance = distance < ATTACK_DISTANCE
        if (!isInAttackDistance) {
            const forwardVector = Vector3.rotate(Vector3.Forward(), transform.rotation)
            const positionDelta = Vector3.scale(forwardVector, MOVEMENT_SPEED * deltaTime)
            transform.position = Vector3.add(transform.position, positionDelta)
        }
        
        Animator.getClip(entity, ""Walking"").playing = !isInAttackDistance
        Animator.getClip(entity, ""Attacking"").playing = isInAttackDistance
    }
}
engine.addSystem(zombieMovementSystem)"
/* world */ ,"
import { engine, GltfContainer, Material, Transform } from '@dcl/sdk/ecs'
import { Vector3, Color3, Quaternion } from '@dcl/sdk/math'

declare module ""cannon/build/cannon"" {
  export interface IAABBOptions {
    upperBound?: Vec3
    lowerBound?: Vec3
  }

  export class AABB {
    lowerBound: Vec3
    upperBound: Vec3

    constructor(options?: IAABBOptions)

    clone(): AABB
    copy(aabb: AABB): void
    extend(aabb: AABB): void
    getCorners(a: Vec3, b: Vec3, c: Vec3, d: Vec3, e: Vec3, f: Vec3, g: Vec3, h: Vec3): void
    overlaps(aabb: AABB): boolean
    setFromPoints(points: Vec3[], position?: Vec3, quaternion?: Quaternion, skinSize?: number): AABB
    toLocalFrame(frame: Transform, target: AABB): AABB
    toWorldFrame(frame: Transform, target: AABB): AABB
  }

  export class ArrayCollisionMatrix {
    matrix: Mat3[]

    get(i: number, j: number): number
    set(i: number, j: number, value: number): void
    reset(): void
    setNumObjects(n: number): void
  }

  export class BroadPhase {
    world: World
    useBoundingBoxes: boolean
    dirty: boolean

    collisionPairs(world: World, p1: Body[], p2: Body[]): void
    needBroadphaseCollision(bodyA: Body, bodyB: Body): boolean
    intersectionTest(bodyA: Body, bodyB: Body, pairs1: Body[], pairs2: Body[]): void
    doBoundingSphereBroadphase(bodyA: Body, bodyB: Body, pairs1: Body[], pairs2: Body[]): void
    doBoundingBoxBroadphase(bodyA: Body, bodyB: Body, pairs1: Body[], pairs2: Body[]): void
    makePairsUnique(pairs1: Body[], pairs2: Body[]): void
    setWorld(world: World): void
    boundingSphereCheck(bodyA: Body, bodyB: Body): boolean
    aabbQuery(world: World, aabb: AABB, result: Body[]): Body[]
  }

  export class GridBroadphase extends BroadPhase {
    nx: number
    ny: number
    nz: number
    aabbMin: Vec3
    aabbMax: Vec3
    bins: any[]

    constructor(aabbMin?: Vec3, aabbMax?: Vec3, nx?: number, ny?: number, nz?: number)
  }

  export class NaiveBroadphase extends BroadPhase {}

  export class ObjectCollisionMatrix {
    matrix: number[]

    get(i: number, j: number): number
    set(i: number, j: number, value: number): void
    reset(): void
    setNumObjects(n: number): void
  }

  export class Ray {
    from: Vec3
    to: Vec3
    precision: number
    checkCollisionResponse: boolean

    constructor(from?: Vec3, to?: Vec3)

    getAABB(result: RaycastResult): void
  }

  export class RaycastResult {
    rayFromWorld: Vec3
    rayToWorld: Vec3
    hitNormalWorld: Vec3
    hitPointWorld: Vec3
    hasHit: boolean
    shape: Shape
    body: Body
    distance: number

    reset(): void
    set(
      rayFromWorld: Vec3,
      rayToWorld: Vec3,
      hitNormalWorld: Vec3,
      hitPointWorld: Vec3,
      shape: Shape,
      body: Body,
      distance: number
    ): void
  }

  export class SAPBroadphase extends BroadPhase {
    static insertionSortX(a: any[]): any[]
    static insertionSortY(a: any[]): any[]
    static insertionSortZ(a: any[]): any[]
    static checkBounds(bi: Body, bj: Body, axisIndex?: number): boolean

    axisList: any[]
    world: World
    axisIndex: number

    constructor(world?: World)

    autoDetectAxis(): void
    aabbQuery(world: World, aabb: AABB, result?: Body[]): Body[]
  }

  export interface IConstraintOptions {
    collideConnected?: boolean
    wakeUpBodies?: boolean
  }

  export class Constraint {
    equations: any[]
    bodyA: Body
    bodyB: Body
    id: number
    collideConnected: boolean

    constructor(bodyA: Body, bodyB: Body, options?: IConstraintOptions)

    update(): void
    disable(): void
    enable(): void
  }

  export class DistanceConstraint extends Constraint {
    constructor(bodyA: Body, bodyB: Body, distance: number, maxForce?: number)
  }

  export interface IHingeConstraintOptions {
    pivotA?: Vec3
    axisA?: Vec3
    pivotB?: Vec3
    axisB?: Vec3
    maxForce?: number
  }

  export class HingeConstraint extends Constraint {
    motorEnabled: boolean
    motorTargetVelocity: number
    motorMinForce: number
    motorMaxForce: number
    motorEquation: RotationalMotorEquation

    constructor(bodyA: Body, bodyB: Body, options?: IHingeConstraintOptions)

    enableMotor(): void
    disableMotor(): void
  }

  export class PointToPointConstraint extends Constraint {
    constructor(bodyA: Body, pivotA: Vec3, bodyB: Body, pivotB: Vec3, maxForce?: number)
  }

  export interface ILockConstraintOptions {
    maxForce?: number
  }

  export class LockConstraint extends Constraint {
    constructor(bodyA: Body, bodyB: Body, options?: ILockConstraintOptions)
  }

  export interface IConeTwistConstraintOptions {
    pivotA?: Vec3
    pivotB?: Vec3
    axisA?: Vec3
    axisB?: Vec3
    maxForce?: number
  }

  export class ConeTwistConstraint extends Constraint {
    constructor(bodyA: Body, bodyB: Body, options?: IConeTwistConstraintOptions)
  }

  export class Equation {
    id: number
    minForce: number
    maxForce: number
    bi: Body
    bj: Body
    a: number
    b: number
    eps: number
    jacobianElementA: JacobianElement
    jacobianElementB: JacobianElement
    enabled: boolean

    constructor(bi: Body, bj: Body, minForce?: number, maxForce?: number)

    setSpookParams(stiffness: number, relaxation: number, timeStep: number): void
    computeB(a: number, b: number, h: number): number
    computeGq(): number
    computeGW(): number
    computeGWlamda(): number
    computeGiMf(): number
    computeGiMGt(): number
    addToWlamda(deltalambda: number): number
    computeC(): number
  }

  export class FrictionEquation extends Equation {
    constructor(bi: Body, bj: Body, slipForce: number)
  }

  export class RotationalEquation extends Equation {
    ni: Vec3
    nj: Vec3
    nixnj: Vec3
    njxni: Vec3
    invIi: Mat3
    invIj: Mat3
    relVel: Vec3
    relForce: Vec3

    constructor(bodyA: Body, bodyB: Body)
  }

  export class RotationalMotorEquation extends Equation {
    axisA: Vec3
    axisB: Vec3
    invLi: Mat3
    invIj: Mat3
    targetVelocity: number

    constructor(bodyA: Body, bodyB: Body, maxForce?: number)
  }

  export class ContactEquation extends Equation {
    restitution: number
    ri: Vec3
    rj: Vec3
    penetrationVec: Vec3
    ni: Vec3
    rixn: Vec3
    rjxn: Vec3
    invIi: Mat3
    invIj: Mat3
    biInvInertiaTimesRixn: Vec3
    bjInvInertiaTimesRjxn: Vec3

    constructor(bi: Body, bj: Body)
  }

  export interface IContactMaterialOptions {
    friction?: number
    restitution?: number
    contactEquationStiffness?: number
    contactEquationRelaxation?: number
    frictionEquationStiffness?: number
    frictionEquationRelaxation?: number
  }

  export class ContactMaterial {
    id: number
    materials: Material[]
    friction: number
    restitution: number
    contactEquationStiffness: number
    contactEquationRelaxation: number
    frictionEquationStiffness: number
    frictionEquationRelaxation: number

    constructor(m1: Material, m2: Material, options?: IContactMaterialOptions)
  }

  export class Material {
    name: string
    id: number
    friction: number
    restitution: number

    constructor(name: string)
  }

  export class JacobianElement {
    spatial: Vec3
    rotational: Vec3

    multiplyElement(element: JacobianElement): number
    multiplyVectors(spacial: Vec3, rotational: Vec3): number
  }

  export class Mat3 {
    constructor(elements?: number[])

    identity(): void
    setZero(): void
    setTrace(vec3: Vec3): void
    getTrace(target: Vec3): void
    vmult(v: Vec3, target?: Vec3): Vec3
    smult(s: number): void
    mmult(m: Mat3): Mat3
    scale(v: Vec3, target?: Mat3): Mat3
    solve(b: Vec3, target?: Vec3): Vec3
    e(row: number, column: number, value?: number): number
    copy(source: Mat3): Mat3
    toString(): string
    reverse(target?: Mat3): Mat3
    setRotationFromQuaternion(q: Quaternion): Mat3
    transpose(target?: Mat3): Mat3
  }

  export class Quaternion {
    x: number
    y: number
    z: number
    w: number

    constructor(x?: number, y?: number, z?: number, w?: number)

    set(x: number, y: number, z: number, w: number): void
    toString(): string
    toArray(): number[]
    setFromAxisAngle(axis: Vec3, angle: number): void
    toAxisAngle(targetAxis?: Vec3): any[]
    setFromVectors(u: Vec3, v: Vec3): void
    mult(q: Quaternion, target?: Quaternion): Quaternion
    inverse(target?: Quaternion): Quaternion
    conjugate(target?: Quaternion): Quaternion
    normalize(): void
    normalizeFast(): void
    vmult(v: Vec3, target?: Vec3): Vec3
    copy(source: Quaternion): Quaternion
    toEuler(target: Vec3, order?: string): void
    setFromEuler(x: number, y: number, z: number, order?: string): Quaternion
    clone(): Quaternion
  }

  export class Transform {
    static pointToLocalFrame(position: Vec3, quaternion: Quaternion, worldPoint: Vec3, result?: Vec3): Vec3
    static pointToWorldFrame(position: Vec3, quaternion: Quaternion, localPoint: Vec3, result?: Vec3): Vec3

    position: Vec3
    quaternion: Quaternion

    vectorToWorldFrame(localVector: Vec3, result?: Vec3): Vec3
    vectorToLocalFrame(position: Vec3, quaternion: Quaternion, worldVector: Vec3, result?: Vec3): Vec3
  }

  export class Vec3 {
    static ZERO: Vec3

    x: number
    y: number
    z: number

    constructor(x?: number, y?: number, z?: number)

    cross(v: Vec3, target?: Vec3): Vec3
    set(x: number, y: number, z: number): Vec3
    setZero(): void
    vadd(v: Vec3, target?: Vec3): Vec3
    vsub(v: Vec3, target?: Vec3): Vec3
    crossmat(): Mat3
    normalize(): number
    unit(target?: Vec3): Vec3
    norm(): number
    norm2(): number
    distanceTo(p: Vec3): number
    mult(scalar: number, target?: Vec3): Vec3
    scale(scalar: number, target?: Vec3): Vec3
    dot(v: Vec3): number
    isZero(): boolean
    negate(target?: Vec3): Vec3
    tangents(t1: Vec3, t2: Vec3): void
    toString(): string
    toArray(): number[]
    copy(source: Vec3): Vec3
    lerp(v: Vec3, t: number, target?: Vec3): void
    almostEquals(v: Vec3, precision?: number): boolean
    almostZero(precision?: number): boolean
    isAntiparallelTo(v: Vec3, prescision?: number): boolean
    clone(): Vec3
  }

  export interface IBodyOptions {
    position?: Vec3
    velocity?: Vec3
    angularVelocity?: Vec3
    quaternion?: Quaternion
    mass?: number
    material?: Material
    type?: number
    linearDamping?: number
    angularDamping?: number
    allowSleep?: boolean
    sleepSpeedLimit?: number
    sleepTimeLimit?: number
    collisionFilterGroup?: number
    collisionFilterMask?: number
    fixedRotation?: boolean
    shape?: Shape
  }

  export class Body extends EventTarget {
    static DYNAMIC: number
    static STATIC: number
    static KINEMATIC: number
    static AWAKE: number
    static SLEEPY: number
    static SLEEPING: number
    static sleepyEvent: IEvent
    static sleepEvent: IEvent

    id: number
    world: World
    preStep: Function
    postStep: Function
    vlambda: Vec3
    collisionFilterGroup: number
    collisionFilterMask: number
    collisionResponse: boolean
    position: Vec3
    previousPosition: Vec3
    initPosition: Vec3
    velocity: Vec3
    initVelocity: Vec3
    force: Vec3
    mass: number
    invMass: number
    material: Material
    linearDamping: number
    type: number
    allowSleep: boolean
    sleepState: number
    sleepSpeedLimit: number
    sleepTimeLimit: number
    timeLastSleepy: number
    torque: Vec3
    quaternion: Quaternion
    initQuaternion: Quaternion
    angularVelocity: Vec3
    initAngularVelocity: Vec3
    interpolatedPosition: Vec3
    interpolatedQuaternion: Quaternion
    shapes: Shape[]
    shapeOffsets: any[]
    shapeOrientations: any[]
    inertia: Vec3
    invInertia: Vec3
    invInertiaWorld: Mat3
    invMassSolve: number
    invInertiaSolve: Vec3
    invInteriaWorldSolve: Mat3
    fixedRotation: boolean
    angularDamping: number
    aabb: AABB
    aabbNeedsUpdate: boolean
    wlambda: Vec3

    constructor(options?: IBodyOptions)

    wakeUp(): void
    sleep(): void
    sleepTick(time: number): void
    updateSolveMassProperties(): void
    pointToLocalFrame(worldPoint: Vec3, result?: Vec3): Vec3
    pointToWorldFrame(localPoint: Vec3, result?: Vec3): Vec3
    vectorToWorldFrame(localVector: Vec3, result?: Vec3): Vec3
    addShape(shape: Shape, offset?: Vec3, orientation?: Quaternion): void
    updateBoundingRadius(): void
    computeAABB(): void
    updateInertiaWorld(force: Vec3): void
    applyForce(force: Vec3, worldPoint: Vec3): void
    applyImpulse(impulse: Vec3, worldPoint: Vec3): void
    applyLocalForce(force: Vec3, localPoint: Vec3): void
    applyLocalImpulse(impulse: Vec3, localPoint: Vec3): void
    updateMassProperties(): void
    getVelocityAtWorldPoint(worldPoint: Vec3, result: Vec3): Vec3
  }

  export interface IRaycastVehicleOptions {
    chassisBody?: Body
    indexRightAxis?: number
    indexLeftAxis?: number
    indexUpAxis?: number
  }

  export interface IWheelInfoOptions {
    chassisConnectionPointLocal?: Vec3
    chassisConnectionPointWorld?: Vec3
    directionLocal?: Vec3
    directionWorld?: Vec3
    axleLocal?: Vec3
    axleWorld?: Vec3
    suspensionRestLength?: number
    suspensionMaxLength?: number
    radius?: number
    suspensionStiffness?: number
    dampingCompression?: number
    dampingRelaxation?: number
    frictionSlip?: number
    steering?: number
    rotation?: number
    deltaRotation?: number
    rollInfluence?: number
    maxSuspensionForce?: number
    isFronmtWheel?: boolean
    clippedInvContactDotSuspension?: number
    suspensionRelativeVelocity?: number
    suspensionForce?: number
    skidInfo?: number
    suspensionLength?: number
    maxSuspensionTravel?: number
    useCustomSlidingRotationalSpeed?: boolean
    customSlidingRotationalSpeed?: number

    position?: Vec3
    direction?: Vec3
    axis?: Vec3
    body?: Body
  }

  export class WheelInfo {
    maxSuspensionTravbel: number
    customSlidingRotationalSpeed: number
    useCustomSlidingRotationalSpeed: boolean
    sliding: boolean
    chassisConnectionPointLocal: Vec3
    chassisConnectionPointWorld: Vec3
    directionLocal: Vec3
    directionWorld: Vec3
    axleLocal: Vec3
    axleWorld: Vec3
    suspensionRestLength: number
    suspensionMaxLength: number
    radius: number
    suspensionStiffness: number
    dampingCompression: number
    dampingRelaxation: number
    frictionSlip: number
    steering: number
    rotation: number
    deltaRotation: number
    rollInfluence: number
    maxSuspensionForce: number
    engineForce: number
    brake: number
    isFrontWheel: boolean
    clippedInvContactDotSuspension: number
    suspensionRelativeVelocity: number
    suspensionForce: number
    skidInfo: number
    suspensionLength: number
    sideImpulse: number
    forwardImpulse: number
    raycastResult: RaycastResult
    worldTransform: Transform
    isInContact: boolean

    constructor(options?: IWheelInfoOptions)
  }

  export class RaycastVehicle {
    chassisBody: Body
    wheelInfos: IWheelInfoOptions[]
    sliding: boolean
    world: World
    iindexRightAxis: number
    indexForwardAxis: number
    indexUpAxis: number

    constructor(options?: IRaycastVehicleOptions)

    addWheel(options?: IWheelInfoOptions): void
    setSteeringValue(value: number, wheelIndex: number): void
    applyEngineForce(value: number, wheelIndex: number): void
    setBrake(brake: number, wheelIndex: number): void
    addToWorld(world: World): void
    getVehicleAxisWorld(axisIndex: number, result: Vec3): Vec3
    updateVehicle(timeStep: number): void
    updateSuspension(deltaTime: number): void
    removeFromWorld(world: World): void
    getWheelTransformWorld(wheelIndex: number): Transform
  }

  export interface IRigidVehicleOptions {
    chassisBody: Body
  }

  export class RigidVehicle {
    wheelBodies: Body[]
    coordinateSystem: Vec3
    chassisBody: Body
    constraints: Constraint[]
    wheelAxes: Vec3[]
    wheelForces: Vec3[]

    constructor(options?: IRigidVehicleOptions)

    addWheel(options?: IWheelInfoOptions): Body
    setSteeringValue(value: number, wheelIndex: number): void
    setMotorSpeed(value: number, wheelIndex: number): void
    disableMotor(wheelIndex: number): void
    setWheelForce(value: number, wheelIndex: number): void
    applyWheelForce(value: number, wheelIndex: number): void
    addToWorld(world: World): void
    removeFromWorld(world: World): void
    getWheelSpeed(wheelIndex: number): number
  }

  export class SPHSystem {
    particles: Particle[]
    density: number
    smoothingRadius: number
    speedOfSound: number
    viscosity: number
    eps: number
    pressures: number[]
    densities: number[]
    neighbors: number[]

    add(particle: Particle): void
    remove(particle: Particle): void
    getNeighbors(particle: Particle, neighbors: Particle[]): void
    update(): void
    w(r: number): number
    gradw(rVec: Vec3, resultVec: Vec3): void
    nablaw(r: number): number
  }

  export interface ISpringOptions {
    restLength?: number
    stiffness?: number
    damping?: number
    worldAnchorA?: Vec3
    worldAnchorB?: Vec3
    localAnchorA?: Vec3
    localAnchorB?: Vec3
  }

  export class Spring {
    restLength: number
    stffness: number
    damping: number
    bodyA: Body
    bodyB: Body
    localAnchorA: Vec3
    localAnchorB: Vec3

    constructor(options?: ISpringOptions)

    setWorldAnchorA(worldAnchorA: Vec3): void
    setWorldAnchorB(worldAnchorB: Vec3): void
    getWorldAnchorA(result: Vec3): void
    getWorldAnchorB(result: Vec3): void
    applyForce(): void
  }

  export class Box extends Shape {
    static calculateIntertia(halfExtents: Vec3, mass: number, target: Vec3): void

    boundingSphereRadius: number
    collisionResponse: boolean
    halfExtents: Vec3
    convexPolyhedronRepresentation: ConvexPolyhedron

    constructor(halfExtents: Vec3)

    updateConvexPolyhedronRepresentation(): void
    calculateLocalInertia(mass: number, target?: Vec3): Vec3
    getSideNormals(sixTargetVectors: boolean, quat?: Quaternion): Vec3[]
    updateBoundingSphereRadius(): number
    volume(): number
    forEachWorldCorner(pos: Vec3, quat: Quaternion, callback: Function): void
  }

  export class ConvexPolyhedron extends Shape {
    static computeNormal(va: Vec3, vb: Vec3, vc: Vec3, target: Vec3): void
    static project(hull: ConvexPolyhedron, axis: Vec3, pos: Vec3, quat: Quaternion, result: number[]): void

    vertices: Vec3[]
    worldVertices: Vec3[]
    worldVerticesNeedsUpdate: boolean
    faces: number[][]
    faceNormals: Vec3[]
    uniqueEdges: Vec3[]

    constructor(points?: Vec3[], faces?: number[])

    computeEdges(): void
    computeNormals(): void
    getFaceNormal(i: number, target: Vec3): Vec3
    clipAgainstHull(
      posA: Vec3,
      quatA: Quaternion,
      hullB: Vec3,
      quatB: Quaternion,
      separatingNormal: Vec3,
      minDist: number,
      maxDist: number,
      result: any[]
    ): void
    findSaparatingAxis(
      hullB: ConvexPolyhedron,
      posA: Vec3,
      quatA: Quaternion,
      posB: Vec3,
      quatB: Quaternion,
      target: Vec3,
      faceListA: any[],
      faceListB: any[]
    ): boolean
    testSepAxis(
      axis: Vec3,
      hullB: ConvexPolyhedron,
      posA: Vec3,
      quatA: Quaternion,
      posB: Vec3,
      quatB: Quaternion
    ): number
    getPlaneConstantOfFace(face_i: number): number
    clipFaceAgainstHull(
      separatingNormal: Vec3,
      posA: Vec3,
      quatA: Quaternion,
      worldVertsB1: Vec3[],
      minDist: number,
      maxDist: number,
      result: any[]
    ): void
    clipFaceAgainstPlane(inVertices: Vec3[], outVertices: Vec3[], planeNormal: Vec3, planeConstant: number): Vec3
    computeWorldVertices(position: Vec3, quat: Quaternion): void
    computeLocalAABB(aabbmin: Vec3, aabbmax: Vec3): void
    computeWorldFaceNormals(quat: Quaternion): void
    calculateWorldAABB(pos: Vec3, quat: Quaternion, min: Vec3, max: Vec3): void
    getAveragePointLocal(target: Vec3): Vec3
    transformAllPoints(offset: Vec3, quat: Quaternion): void
    pointIsInside(p: Vec3): boolean
  }

  export class Cylinder extends Shape {
    constructor(radiusTop: number, radiusBottom: number, height: number, numSegments: number)
  }

  export interface IHightfield {
    minValue?: number
    maxValue?: number
    elementSize: number
  }

  export class Heightfield extends Shape {
    data: number[][]
    maxValue: number
    minValue: number
    elementSize: number
    cacheEnabled: boolean
    pillarConvex: ConvexPolyhedron
    pillarOffset: Vec3
    type: number

    constructor(data: number[], options?: IHightfield)

    update(): void
    updateMinValue(): void
    updateMaxValue(): void
    setHeightValueAtIndex(xi: number, yi: number, value: number): void
    getRectMinMax(iMinX: number, iMinY: number, iMaxX: number, iMaxY: number, result: any[]): void
    getIndexOfPosition(x: number, y: number, result: any[], clamp: boolean): boolean
    getConvexTrianglePillar(xi: number, yi: number, getUpperTriangle: boolean): void
  }

  export class Particle extends Shape {}

  export class Plane extends Shape {
    worldNormal: Vec3
    worldNormalNeedsUpdate: boolean
    boundingSphereRadius: number

    computeWorldNormal(quat: Quaternion): void
    calculateWorldAABB(pos: Vec3, quat: Quaternion, min: number, max: number): void
  }

  export class Shape {
    static types: {
      SPHERE: number
      PLANE: number
      BOX: number
      COMPOUND: number
      CONVEXPOLYHEDRON: number
      HEIGHTFIELD: number
      PARTICLE: number
      CYLINDER: number
    }

    type: number
    boundingSphereRadius: number
    collisionResponse: boolean

    updateBoundingSphereRadius(): number
    volume(): number
    calculateLocalInertia(mass: number, target: Vec3): Vec3
  }

  export class Sphere extends Shape {
    radius: number

    constructor(radius: number)
  }

  export class GSSolver extends Solver {
    iterations: number
    tolerance: number

    solve(dy: number, world: World): number
  }

  export class Solver {
    iterations: number
    equations: Equation[]

    solve(dy: number, world: World): number
    addEquation(eq: Equation): void
    removeEquation(eq: Equation): void
    removeAllEquations(): void
  }

  export class SplitSolver extends Solver {
    subsolver: Solver

    constructor(subsolver: Solver)

    solve(dy: number, world: World): number
  }

  export class EventTarget {
    addEventListener(type: string, listener: Function): EventTarget
    hasEventListener(type: string, listener: Function): boolean
    removeEventListener(type: string, listener: Function): EventTarget
    dispatchEvent(event: IEvent): IEvent
  }

  export class Pool {
    objects: any[]
    type: any[]

    release(): any
    get(): any
    constructObject(): any
  }

  export class TupleDictionary {
    data: {
      keys: any[]
    }

    get(i: number, j: number): number
    set(i: number, j: number, value: number): void
    reset(): void
  }

  export class Utils {
    static defaults(options?: any, defaults?: any): any
  }

  export class Vec3Pool extends Pool {
    type: any

    constructObject(): Vec3
  }

  export class NarrowPhase {
    contactPointPool: Pool[]
    v3pool: Vec3Pool
  }

  export class World extends EventTarget {
    iterations: number
    dt: number
    allowSleep: boolean
    contacts: ContactEquation[]
    frictionEquations: FrictionEquation[]
    quatNormalizeSkip: number
    quatNormalizeFast: boolean
    time: number
    stepnumber: number
    default_dt: number
    nextId: number
    gravity: Vec3
    broadphase: NaiveBroadphase
    bodies: Body[]
    solver: Solver
    constraints: Constraint[]
    narrowPhase: NarrowPhase
    collisionMatrix: ArrayCollisionMatrix
    collisionMatrixPrevious: ArrayCollisionMatrix
    materials: Material[]
    contactmaterials: ContactMaterial[]
    contactMaterialTable: TupleDictionary
    defaultMaterial: Material
    defaultContactMaterial: ContactMaterial
    doProfiling: boolean
    profile: {
      solve: number
      makeContactConstraints: number
      broadphaser: number
      integrate: number
      narrowphase: number
    }
    subsystems: any[]
    addBodyEvent: IBodyEvent
    removeBodyEvent: IBodyEvent

    getContactMaterial(m1: Material, m2: Material): ContactMaterial
    numObjects(): number
    collisionMatrixTick(): void
    addBody(body: Body): void
    addConstraint(c: Constraint): void
    removeConstraint(c: Constraint): void
    rayTest(from: Vec3, to: Vec3, result: RaycastResult): void
    remove(body: Body): void
    addMaterial(m: Material): void
    addContactMaterial(cmat: ContactMaterial): void
    step(dy: number, timeSinceLastCalled?: number, maxSubSteps?: number): void
  }

  export interface IEvent {
    type: string
  }

  export interface IBodyEvent extends IEvent {
    body: Body
  }

  export interface ICollisionEvent extends IBodyEvent {
    contact: any
  }
}

declare module 'cannon' {
  export = CANNON
}

import { engine, Schemas, PBMaterial_PbrMaterial } from ""@dcl/sdk/ecs""
import { Color3 } from ""@dcl/sdk/math""

enum CustomComponentIds {
  BoxBody = 2022,
  Marker = 2023
}

export const BoxBody = engine.defineComponent(
  {
    boxBodyId: Schemas.Number
  },
  CustomComponentIds.BoxBody
)

export const Marker = engine.defineComponent(
  {
    mouseConstraintId: Schemas.Number,
    isPointerPressed: Schemas.Boolean,
    isEKeyPressed: Schemas.Boolean,
    markerDistance: Schemas.Number
  },
  CustomComponentIds.Marker
)

export const JointBodyID = 1

// Marker
export const markerMaterial: PBMaterial_PbrMaterial = {
  albedoColor: Color3.create(5, 2.5, 1)
}

export const markerPullMaterial: PBMaterial_PbrMaterial = {
  albedoColor: Color3.create(5, 1, 3.5)
}


let world: CANNON.World

export function setupCannon() {
  // // Setup our CANNON world
  world = new CANNON.World()
  world.quatNormalizeSkip = 0
  world.quatNormalizeFast = false

  world.gravity.set(0, -9.82, 0) // m/sÂ²
  world.broadphase = new CANNON.NaiveBroadphase()

  // // Create a ground plane
  const planeShape = new CANNON.Plane()
  const groundBody = new CANNON.Body({
    mass: 0 // mass == 0 makes the body static
  })
  groundBody.addShape(planeShape)
  groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2) // Reorient ground plane to be in the y-axis
  groundBody.position.y = 0.1 // Thickness of ground base model
  world.addBody(groundBody)

  // Invisible walls
  //#region
  const wallShape = new CANNON.Box(new CANNON.Vec3(32, 50, 1))
  const wallNorth = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(16, 25, 32)
  })
  world.addBody(wallNorth)

  const wallSouth = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(16, 25, 0)
  })
  world.addBody(wallSouth)

  const wallEast = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(0, 25, 16)
  })
  wallEast.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2)
  world.addBody(wallEast)

  const wallWest = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(32, 25, 16)
  })
  wallWest.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2)
  world.addBody(wallWest)
}

let boxBodyCounter = 1e3
export function createBoxBody(position: Vector3) {
  const entity = engine.addEntity()
  const bb = BoxBody.create(entity, { boxBodyId: boxBodyCounter++ })
  Transform.create(entity, { position })

  // // Box
  Material.setPbrMaterial(entity, { albedoColor: Color3.Red() })
  GltfContainer.create(entity, { src: 'models/crate.glb' })
  // Create box body
  const boxShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5))
  const boxBody = new CANNON.Body({ mass: 5 })
  boxBody.addShape(boxShape)
  boxBody.id = bb.boxBodyId
  boxBody.position.set(position.x, position.y, position.z)
  boxBody.linearDamping = 0.4 // Round will keep translating even with friction so you need linearDamping
  boxBody.angularDamping = 0.4 // Round bodies will keep rotating even with friction so you need angularDamping
  world.addBody(boxBody) // Add body to the world
}

export function updatePhysicsSystem(dt: number) {
  world.step(dt)

  for (const [entity, body] of engine.getEntitiesWith(BoxBody)) {
    const boxBody = world.bodies.find((item) => item.id === body.boxBodyId)

    if (boxBody) {
      const tranform = Transform.getMutable(entity)
      tranform.position = Vector3.create(boxBody.position.x, boxBody.position.y, boxBody.position.z)
      tranform.rotation = Quaternion.create(
        boxBody.quaternion.x,
        boxBody.quaternion.y,
        boxBody.quaternion.z,
        boxBody.quaternion.w
      )
    }
  }
}

export function addBody(body: CANNON.Body) {
  world.addBody(body)
}

export function addConstraint(constraint: CANNON.Constraint) {
  world.addConstraint(constraint)
}

export function removeConstraint(constraint: CANNON.Constraint) {
  world.removeConstraint(constraint)
}

export function getBoxBodyOrNull(id: number) {
  return world.bodies.find((item) => item.id === id)
}

export function getConstraintOrNull(id: number) {
  return world.constraints.find((item) => item.id === id)
}"
/* marker */ ,"import { Entity, engine, MeshRenderer, Transform, Material, InputAction, PointerEventType, inputSystem } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'


import { engine, Schemas, PBMaterial_PbrMaterial } from ""@dcl/sdk/ecs""
import { Color3 } from ""@dcl/sdk/math""

enum CustomComponentIds {
  BoxBody = 2022,
  Marker = 2023
}

export const BoxBody = engine.defineComponent(
  {
    boxBodyId: Schemas.Number
  },
  CustomComponentIds.BoxBody
)

export const Marker = engine.defineComponent(
  {
    mouseConstraintId: Schemas.Number,
    isPointerPressed: Schemas.Boolean,
    isEKeyPressed: Schemas.Boolean,
    markerDistance: Schemas.Number
  },
  CustomComponentIds.Marker
)

export const JointBodyID = 1

// Marker
export const markerMaterial: PBMaterial_PbrMaterial = {
  albedoColor: Color3.create(5, 2.5, 1)
}

export const markerPullMaterial: PBMaterial_PbrMaterial = {
  albedoColor: Color3.create(5, 1, 3.5)
}

import { engine, GltfContainer, Material, Transform } from '@dcl/sdk/ecs'
import { Vector3, Color3, Quaternion } from '@dcl/sdk/math'

let world: CANNON.World

export function setupCannon() {
  // // Setup our CANNON world
  world = new CANNON.World()
  world.quatNormalizeSkip = 0
  world.quatNormalizeFast = false

  world.gravity.set(0, -9.82, 0) // m/sÂ²
  world.broadphase = new CANNON.NaiveBroadphase()

  // // Create a ground plane
  const planeShape = new CANNON.Plane()
  const groundBody = new CANNON.Body({
    mass: 0 // mass == 0 makes the body static
  })
  groundBody.addShape(planeShape)
  groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2) // Reorient ground plane to be in the y-axis
  groundBody.position.y = 0.1 // Thickness of ground base model
  world.addBody(groundBody)

  // Invisible walls
  //#region
  const wallShape = new CANNON.Box(new CANNON.Vec3(32, 50, 1))
  const wallNorth = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(16, 25, 32)
  })
  world.addBody(wallNorth)

  const wallSouth = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(16, 25, 0)
  })
  world.addBody(wallSouth)

  const wallEast = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(0, 25, 16)
  })
  wallEast.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2)
  world.addBody(wallEast)

  const wallWest = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(32, 25, 16)
  })
  wallWest.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2)
  world.addBody(wallWest)
}

let boxBodyCounter = 1e3
export function createBoxBody(position: Vector3) {
  const entity = engine.addEntity()
  const bb = BoxBody.create(entity, { boxBodyId: boxBodyCounter++ })
  Transform.create(entity, { position })

  // // Box
  Material.setPbrMaterial(entity, { albedoColor: Color3.Red() })
  GltfContainer.create(entity, { src: 'models/crate.glb' })
  // Create box body
  const boxShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5))
  const boxBody = new CANNON.Body({ mass: 5 })
  boxBody.addShape(boxShape)
  boxBody.id = bb.boxBodyId
  boxBody.position.set(position.x, position.y, position.z)
  boxBody.linearDamping = 0.4 // Round will keep translating even with friction so you need linearDamping
  boxBody.angularDamping = 0.4 // Round bodies will keep rotating even with friction so you need angularDamping
  world.addBody(boxBody) // Add body to the world
}

export function updatePhysicsSystem(dt: number) {
  world.step(dt)

  for (const [entity, body] of engine.getEntitiesWith(BoxBody)) {
    const boxBody = world.bodies.find((item) => item.id === body.boxBodyId)

    if (boxBody) {
      const tranform = Transform.getMutable(entity)
      tranform.position = Vector3.create(boxBody.position.x, boxBody.position.y, boxBody.position.z)
      tranform.rotation = Quaternion.create(
        boxBody.quaternion.x,
        boxBody.quaternion.y,
        boxBody.quaternion.z,
        boxBody.quaternion.w
      )
    }
  }
}

export function addBody(body: CANNON.Body) {
  world.addBody(body)
}

export function addConstraint(constraint: CANNON.Constraint) {
  world.addConstraint(constraint)
}

export function removeConstraint(constraint: CANNON.Constraint) {
  world.removeConstraint(constraint)
}

export function getBoxBodyOrNull(id: number) {
  return world.bodies.find((item) => item.id === id)
}

export function getConstraintOrNull(id: number) {
  return world.constraints.find((item) => item.id === id)
}

declare module ""cannon/build/cannon"" {
  export interface IAABBOptions {
    upperBound?: Vec3
    lowerBound?: Vec3
  }

  export class AABB {
    lowerBound: Vec3
    upperBound: Vec3

    constructor(options?: IAABBOptions)

    clone(): AABB
    copy(aabb: AABB): void
    extend(aabb: AABB): void
    getCorners(a: Vec3, b: Vec3, c: Vec3, d: Vec3, e: Vec3, f: Vec3, g: Vec3, h: Vec3): void
    overlaps(aabb: AABB): boolean
    setFromPoints(points: Vec3[], position?: Vec3, quaternion?: Quaternion, skinSize?: number): AABB
    toLocalFrame(frame: Transform, target: AABB): AABB
    toWorldFrame(frame: Transform, target: AABB): AABB
  }

  export class ArrayCollisionMatrix {
    matrix: Mat3[]

    get(i: number, j: number): number
    set(i: number, j: number, value: number): void
    reset(): void
    setNumObjects(n: number): void
  }

  export class BroadPhase {
    world: World
    useBoundingBoxes: boolean
    dirty: boolean

    collisionPairs(world: World, p1: Body[], p2: Body[]): void
    needBroadphaseCollision(bodyA: Body, bodyB: Body): boolean
    intersectionTest(bodyA: Body, bodyB: Body, pairs1: Body[], pairs2: Body[]): void
    doBoundingSphereBroadphase(bodyA: Body, bodyB: Body, pairs1: Body[], pairs2: Body[]): void
    doBoundingBoxBroadphase(bodyA: Body, bodyB: Body, pairs1: Body[], pairs2: Body[]): void
    makePairsUnique(pairs1: Body[], pairs2: Body[]): void
    setWorld(world: World): void
    boundingSphereCheck(bodyA: Body, bodyB: Body): boolean
    aabbQuery(world: World, aabb: AABB, result: Body[]): Body[]
  }

  export class GridBroadphase extends BroadPhase {
    nx: number
    ny: number
    nz: number
    aabbMin: Vec3
    aabbMax: Vec3
    bins: any[]

    constructor(aabbMin?: Vec3, aabbMax?: Vec3, nx?: number, ny?: number, nz?: number)
  }

  export class NaiveBroadphase extends BroadPhase {}

  export class ObjectCollisionMatrix {
    matrix: number[]

    get(i: number, j: number): number
    set(i: number, j: number, value: number): void
    reset(): void
    setNumObjects(n: number): void
  }

  export class Ray {
    from: Vec3
    to: Vec3
    precision: number
    checkCollisionResponse: boolean

    constructor(from?: Vec3, to?: Vec3)

    getAABB(result: RaycastResult): void
  }

  export class RaycastResult {
    rayFromWorld: Vec3
    rayToWorld: Vec3
    hitNormalWorld: Vec3
    hitPointWorld: Vec3
    hasHit: boolean
    shape: Shape
    body: Body
    distance: number

    reset(): void
    set(
      rayFromWorld: Vec3,
      rayToWorld: Vec3,
      hitNormalWorld: Vec3,
      hitPointWorld: Vec3,
      shape: Shape,
      body: Body,
      distance: number
    ): void
  }

  export class SAPBroadphase extends BroadPhase {
    static insertionSortX(a: any[]): any[]
    static insertionSortY(a: any[]): any[]
    static insertionSortZ(a: any[]): any[]
    static checkBounds(bi: Body, bj: Body, axisIndex?: number): boolean

    axisList: any[]
    world: World
    axisIndex: number

    constructor(world?: World)

    autoDetectAxis(): void
    aabbQuery(world: World, aabb: AABB, result?: Body[]): Body[]
  }

  export interface IConstraintOptions {
    collideConnected?: boolean
    wakeUpBodies?: boolean
  }

  export class Constraint {
    equations: any[]
    bodyA: Body
    bodyB: Body
    id: number
    collideConnected: boolean

    constructor(bodyA: Body, bodyB: Body, options?: IConstraintOptions)

    update(): void
    disable(): void
    enable(): void
  }

  export class DistanceConstraint extends Constraint {
    constructor(bodyA: Body, bodyB: Body, distance: number, maxForce?: number)
  }

  export interface IHingeConstraintOptions {
    pivotA?: Vec3
    axisA?: Vec3
    pivotB?: Vec3
    axisB?: Vec3
    maxForce?: number
  }

  export class HingeConstraint extends Constraint {
    motorEnabled: boolean
    motorTargetVelocity: number
    motorMinForce: number
    motorMaxForce: number
    motorEquation: RotationalMotorEquation

    constructor(bodyA: Body, bodyB: Body, options?: IHingeConstraintOptions)

    enableMotor(): void
    disableMotor(): void
  }

  export class PointToPointConstraint extends Constraint {
    constructor(bodyA: Body, pivotA: Vec3, bodyB: Body, pivotB: Vec3, maxForce?: number)
  }

  export interface ILockConstraintOptions {
    maxForce?: number
  }

  export class LockConstraint extends Constraint {
    constructor(bodyA: Body, bodyB: Body, options?: ILockConstraintOptions)
  }

  export interface IConeTwistConstraintOptions {
    pivotA?: Vec3
    pivotB?: Vec3
    axisA?: Vec3
    axisB?: Vec3
    maxForce?: number
  }

  export class ConeTwistConstraint extends Constraint {
    constructor(bodyA: Body, bodyB: Body, options?: IConeTwistConstraintOptions)
  }

  export class Equation {
    id: number
    minForce: number
    maxForce: number
    bi: Body
    bj: Body
    a: number
    b: number
    eps: number
    jacobianElementA: JacobianElement
    jacobianElementB: JacobianElement
    enabled: boolean

    constructor(bi: Body, bj: Body, minForce?: number, maxForce?: number)

    setSpookParams(stiffness: number, relaxation: number, timeStep: number): void
    computeB(a: number, b: number, h: number): number
    computeGq(): number
    computeGW(): number
    computeGWlamda(): number
    computeGiMf(): number
    computeGiMGt(): number
    addToWlamda(deltalambda: number): number
    computeC(): number
  }

  export class FrictionEquation extends Equation {
    constructor(bi: Body, bj: Body, slipForce: number)
  }

  export class RotationalEquation extends Equation {
    ni: Vec3
    nj: Vec3
    nixnj: Vec3
    njxni: Vec3
    invIi: Mat3
    invIj: Mat3
    relVel: Vec3
    relForce: Vec3

    constructor(bodyA: Body, bodyB: Body)
  }

  export class RotationalMotorEquation extends Equation {
    axisA: Vec3
    axisB: Vec3
    invLi: Mat3
    invIj: Mat3
    targetVelocity: number

    constructor(bodyA: Body, bodyB: Body, maxForce?: number)
  }

  export class ContactEquation extends Equation {
    restitution: number
    ri: Vec3
    rj: Vec3
    penetrationVec: Vec3
    ni: Vec3
    rixn: Vec3
    rjxn: Vec3
    invIi: Mat3
    invIj: Mat3
    biInvInertiaTimesRixn: Vec3
    bjInvInertiaTimesRjxn: Vec3

    constructor(bi: Body, bj: Body)
  }

  export interface IContactMaterialOptions {
    friction?: number
    restitution?: number
    contactEquationStiffness?: number
    contactEquationRelaxation?: number
    frictionEquationStiffness?: number
    frictionEquationRelaxation?: number
  }

  export class ContactMaterial {
    id: number
    materials: Material[]
    friction: number
    restitution: number
    contactEquationStiffness: number
    contactEquationRelaxation: number
    frictionEquationStiffness: number
    frictionEquationRelaxation: number

    constructor(m1: Material, m2: Material, options?: IContactMaterialOptions)
  }

  export class Material {
    name: string
    id: number
    friction: number
    restitution: number

    constructor(name: string)
  }

  export class JacobianElement {
    spatial: Vec3
    rotational: Vec3

    multiplyElement(element: JacobianElement): number
    multiplyVectors(spacial: Vec3, rotational: Vec3): number
  }

  export class Mat3 {
    constructor(elements?: number[])

    identity(): void
    setZero(): void
    setTrace(vec3: Vec3): void
    getTrace(target: Vec3): void
    vmult(v: Vec3, target?: Vec3): Vec3
    smult(s: number): void
    mmult(m: Mat3): Mat3
    scale(v: Vec3, target?: Mat3): Mat3
    solve(b: Vec3, target?: Vec3): Vec3
    e(row: number, column: number, value?: number): number
    copy(source: Mat3): Mat3
    toString(): string
    reverse(target?: Mat3): Mat3
    setRotationFromQuaternion(q: Quaternion): Mat3
    transpose(target?: Mat3): Mat3
  }

  export class Quaternion {
    x: number
    y: number
    z: number
    w: number

    constructor(x?: number, y?: number, z?: number, w?: number)

    set(x: number, y: number, z: number, w: number): void
    toString(): string
    toArray(): number[]
    setFromAxisAngle(axis: Vec3, angle: number): void
    toAxisAngle(targetAxis?: Vec3): any[]
    setFromVectors(u: Vec3, v: Vec3): void
    mult(q: Quaternion, target?: Quaternion): Quaternion
    inverse(target?: Quaternion): Quaternion
    conjugate(target?: Quaternion): Quaternion
    normalize(): void
    normalizeFast(): void
    vmult(v: Vec3, target?: Vec3): Vec3
    copy(source: Quaternion): Quaternion
    toEuler(target: Vec3, order?: string): void
    setFromEuler(x: number, y: number, z: number, order?: string): Quaternion
    clone(): Quaternion
  }

  export class Transform {
    static pointToLocalFrame(position: Vec3, quaternion: Quaternion, worldPoint: Vec3, result?: Vec3): Vec3
    static pointToWorldFrame(position: Vec3, quaternion: Quaternion, localPoint: Vec3, result?: Vec3): Vec3

    position: Vec3
    quaternion: Quaternion

    vectorToWorldFrame(localVector: Vec3, result?: Vec3): Vec3
    vectorToLocalFrame(position: Vec3, quaternion: Quaternion, worldVector: Vec3, result?: Vec3): Vec3
  }

  export class Vec3 {
    static ZERO: Vec3

    x: number
    y: number
    z: number

    constructor(x?: number, y?: number, z?: number)

    cross(v: Vec3, target?: Vec3): Vec3
    set(x: number, y: number, z: number): Vec3
    setZero(): void
    vadd(v: Vec3, target?: Vec3): Vec3
    vsub(v: Vec3, target?: Vec3): Vec3
    crossmat(): Mat3
    normalize(): number
    unit(target?: Vec3): Vec3
    norm(): number
    norm2(): number
    distanceTo(p: Vec3): number
    mult(scalar: number, target?: Vec3): Vec3
    scale(scalar: number, target?: Vec3): Vec3
    dot(v: Vec3): number
    isZero(): boolean
    negate(target?: Vec3): Vec3
    tangents(t1: Vec3, t2: Vec3): void
    toString(): string
    toArray(): number[]
    copy(source: Vec3): Vec3
    lerp(v: Vec3, t: number, target?: Vec3): void
    almostEquals(v: Vec3, precision?: number): boolean
    almostZero(precision?: number): boolean
    isAntiparallelTo(v: Vec3, prescision?: number): boolean
    clone(): Vec3
  }

  export interface IBodyOptions {
    position?: Vec3
    velocity?: Vec3
    angularVelocity?: Vec3
    quaternion?: Quaternion
    mass?: number
    material?: Material
    type?: number
    linearDamping?: number
    angularDamping?: number
    allowSleep?: boolean
    sleepSpeedLimit?: number
    sleepTimeLimit?: number
    collisionFilterGroup?: number
    collisionFilterMask?: number
    fixedRotation?: boolean
    shape?: Shape
  }

  export class Body extends EventTarget {
    static DYNAMIC: number
    static STATIC: number
    static KINEMATIC: number
    static AWAKE: number
    static SLEEPY: number
    static SLEEPING: number
    static sleepyEvent: IEvent
    static sleepEvent: IEvent

    id: number
    world: World
    preStep: Function
    postStep: Function
    vlambda: Vec3
    collisionFilterGroup: number
    collisionFilterMask: number
    collisionResponse: boolean
    position: Vec3
    previousPosition: Vec3
    initPosition: Vec3
    velocity: Vec3
    initVelocity: Vec3
    force: Vec3
    mass: number
    invMass: number
    material: Material
    linearDamping: number
    type: number
    allowSleep: boolean
    sleepState: number
    sleepSpeedLimit: number
    sleepTimeLimit: number
    timeLastSleepy: number
    torque: Vec3
    quaternion: Quaternion
    initQuaternion: Quaternion
    angularVelocity: Vec3
    initAngularVelocity: Vec3
    interpolatedPosition: Vec3
    interpolatedQuaternion: Quaternion
    shapes: Shape[]
    shapeOffsets: any[]
    shapeOrientations: any[]
    inertia: Vec3
    invInertia: Vec3
    invInertiaWorld: Mat3
    invMassSolve: number
    invInertiaSolve: Vec3
    invInteriaWorldSolve: Mat3
    fixedRotation: boolean
    angularDamping: number
    aabb: AABB
    aabbNeedsUpdate: boolean
    wlambda: Vec3

    constructor(options?: IBodyOptions)

    wakeUp(): void
    sleep(): void
    sleepTick(time: number): void
    updateSolveMassProperties(): void
    pointToLocalFrame(worldPoint: Vec3, result?: Vec3): Vec3
    pointToWorldFrame(localPoint: Vec3, result?: Vec3): Vec3
    vectorToWorldFrame(localVector: Vec3, result?: Vec3): Vec3
    addShape(shape: Shape, offset?: Vec3, orientation?: Quaternion): void
    updateBoundingRadius(): void
    computeAABB(): void
    updateInertiaWorld(force: Vec3): void
    applyForce(force: Vec3, worldPoint: Vec3): void
    applyImpulse(impulse: Vec3, worldPoint: Vec3): void
    applyLocalForce(force: Vec3, localPoint: Vec3): void
    applyLocalImpulse(impulse: Vec3, localPoint: Vec3): void
    updateMassProperties(): void
    getVelocityAtWorldPoint(worldPoint: Vec3, result: Vec3): Vec3
  }

  export interface IRaycastVehicleOptions {
    chassisBody?: Body
    indexRightAxis?: number
    indexLeftAxis?: number
    indexUpAxis?: number
  }

  export interface IWheelInfoOptions {
    chassisConnectionPointLocal?: Vec3
    chassisConnectionPointWorld?: Vec3
    directionLocal?: Vec3
    directionWorld?: Vec3
    axleLocal?: Vec3
    axleWorld?: Vec3
    suspensionRestLength?: number
    suspensionMaxLength?: number
    radius?: number
    suspensionStiffness?: number
    dampingCompression?: number
    dampingRelaxation?: number
    frictionSlip?: number
    steering?: number
    rotation?: number
    deltaRotation?: number
    rollInfluence?: number
    maxSuspensionForce?: number
    isFronmtWheel?: boolean
    clippedInvContactDotSuspension?: number
    suspensionRelativeVelocity?: number
    suspensionForce?: number
    skidInfo?: number
    suspensionLength?: number
    maxSuspensionTravel?: number
    useCustomSlidingRotationalSpeed?: boolean
    customSlidingRotationalSpeed?: number

    position?: Vec3
    direction?: Vec3
    axis?: Vec3
    body?: Body
  }

  export class WheelInfo {
    maxSuspensionTravbel: number
    customSlidingRotationalSpeed: number
    useCustomSlidingRotationalSpeed: boolean
    sliding: boolean
    chassisConnectionPointLocal: Vec3
    chassisConnectionPointWorld: Vec3
    directionLocal: Vec3
    directionWorld: Vec3
    axleLocal: Vec3
    axleWorld: Vec3
    suspensionRestLength: number
    suspensionMaxLength: number
    radius: number
    suspensionStiffness: number
    dampingCompression: number
    dampingRelaxation: number
    frictionSlip: number
    steering: number
    rotation: number
    deltaRotation: number
    rollInfluence: number
    maxSuspensionForce: number
    engineForce: number
    brake: number
    isFrontWheel: boolean
    clippedInvContactDotSuspension: number
    suspensionRelativeVelocity: number
    suspensionForce: number
    skidInfo: number
    suspensionLength: number
    sideImpulse: number
    forwardImpulse: number
    raycastResult: RaycastResult
    worldTransform: Transform
    isInContact: boolean

    constructor(options?: IWheelInfoOptions)
  }

  export class RaycastVehicle {
    chassisBody: Body
    wheelInfos: IWheelInfoOptions[]
    sliding: boolean
    world: World
    iindexRightAxis: number
    indexForwardAxis: number
    indexUpAxis: number

    constructor(options?: IRaycastVehicleOptions)

    addWheel(options?: IWheelInfoOptions): void
    setSteeringValue(value: number, wheelIndex: number): void
    applyEngineForce(value: number, wheelIndex: number): void
    setBrake(brake: number, wheelIndex: number): void
    addToWorld(world: World): void
    getVehicleAxisWorld(axisIndex: number, result: Vec3): Vec3
    updateVehicle(timeStep: number): void
    updateSuspension(deltaTime: number): void
    removeFromWorld(world: World): void
    getWheelTransformWorld(wheelIndex: number): Transform
  }

  export interface IRigidVehicleOptions {
    chassisBody: Body
  }

  export class RigidVehicle {
    wheelBodies: Body[]
    coordinateSystem: Vec3
    chassisBody: Body
    constraints: Constraint[]
    wheelAxes: Vec3[]
    wheelForces: Vec3[]

    constructor(options?: IRigidVehicleOptions)

    addWheel(options?: IWheelInfoOptions): Body
    setSteeringValue(value: number, wheelIndex: number): void
    setMotorSpeed(value: number, wheelIndex: number): void
    disableMotor(wheelIndex: number): void
    setWheelForce(value: number, wheelIndex: number): void
    applyWheelForce(value: number, wheelIndex: number): void
    addToWorld(world: World): void
    removeFromWorld(world: World): void
    getWheelSpeed(wheelIndex: number): number
  }

  export class SPHSystem {
    particles: Particle[]
    density: number
    smoothingRadius: number
    speedOfSound: number
    viscosity: number
    eps: number
    pressures: number[]
    densities: number[]
    neighbors: number[]

    add(particle: Particle): void
    remove(particle: Particle): void
    getNeighbors(particle: Particle, neighbors: Particle[]): void
    update(): void
    w(r: number): number
    gradw(rVec: Vec3, resultVec: Vec3): void
    nablaw(r: number): number
  }

  export interface ISpringOptions {
    restLength?: number
    stiffness?: number
    damping?: number
    worldAnchorA?: Vec3
    worldAnchorB?: Vec3
    localAnchorA?: Vec3
    localAnchorB?: Vec3
  }

  export class Spring {
    restLength: number
    stffness: number
    damping: number
    bodyA: Body
    bodyB: Body
    localAnchorA: Vec3
    localAnchorB: Vec3

    constructor(options?: ISpringOptions)

    setWorldAnchorA(worldAnchorA: Vec3): void
    setWorldAnchorB(worldAnchorB: Vec3): void
    getWorldAnchorA(result: Vec3): void
    getWorldAnchorB(result: Vec3): void
    applyForce(): void
  }

  export class Box extends Shape {
    static calculateIntertia(halfExtents: Vec3, mass: number, target: Vec3): void

    boundingSphereRadius: number
    collisionResponse: boolean
    halfExtents: Vec3
    convexPolyhedronRepresentation: ConvexPolyhedron

    constructor(halfExtents: Vec3)

    updateConvexPolyhedronRepresentation(): void
    calculateLocalInertia(mass: number, target?: Vec3): Vec3
    getSideNormals(sixTargetVectors: boolean, quat?: Quaternion): Vec3[]
    updateBoundingSphereRadius(): number
    volume(): number
    forEachWorldCorner(pos: Vec3, quat: Quaternion, callback: Function): void
  }

  export class ConvexPolyhedron extends Shape {
    static computeNormal(va: Vec3, vb: Vec3, vc: Vec3, target: Vec3): void
    static project(hull: ConvexPolyhedron, axis: Vec3, pos: Vec3, quat: Quaternion, result: number[]): void

    vertices: Vec3[]
    worldVertices: Vec3[]
    worldVerticesNeedsUpdate: boolean
    faces: number[][]
    faceNormals: Vec3[]
    uniqueEdges: Vec3[]

    constructor(points?: Vec3[], faces?: number[])

    computeEdges(): void
    computeNormals(): void
    getFaceNormal(i: number, target: Vec3): Vec3
    clipAgainstHull(
      posA: Vec3,
      quatA: Quaternion,
      hullB: Vec3,
      quatB: Quaternion,
      separatingNormal: Vec3,
      minDist: number,
      maxDist: number,
      result: any[]
    ): void
    findSaparatingAxis(
      hullB: ConvexPolyhedron,
      posA: Vec3,
      quatA: Quaternion,
      posB: Vec3,
      quatB: Quaternion,
      target: Vec3,
      faceListA: any[],
      faceListB: any[]
    ): boolean
    testSepAxis(
      axis: Vec3,
      hullB: ConvexPolyhedron,
      posA: Vec3,
      quatA: Quaternion,
      posB: Vec3,
      quatB: Quaternion
    ): number
    getPlaneConstantOfFace(face_i: number): number
    clipFaceAgainstHull(
      separatingNormal: Vec3,
      posA: Vec3,
      quatA: Quaternion,
      worldVertsB1: Vec3[],
      minDist: number,
      maxDist: number,
      result: any[]
    ): void
    clipFaceAgainstPlane(inVertices: Vec3[], outVertices: Vec3[], planeNormal: Vec3, planeConstant: number): Vec3
    computeWorldVertices(position: Vec3, quat: Quaternion): void
    computeLocalAABB(aabbmin: Vec3, aabbmax: Vec3): void
    computeWorldFaceNormals(quat: Quaternion): void
    calculateWorldAABB(pos: Vec3, quat: Quaternion, min: Vec3, max: Vec3): void
    getAveragePointLocal(target: Vec3): Vec3
    transformAllPoints(offset: Vec3, quat: Quaternion): void
    pointIsInside(p: Vec3): boolean
  }

  export class Cylinder extends Shape {
    constructor(radiusTop: number, radiusBottom: number, height: number, numSegments: number)
  }

  export interface IHightfield {
    minValue?: number
    maxValue?: number
    elementSize: number
  }

  export class Heightfield extends Shape {
    data: number[][]
    maxValue: number
    minValue: number
    elementSize: number
    cacheEnabled: boolean
    pillarConvex: ConvexPolyhedron
    pillarOffset: Vec3
    type: number

    constructor(data: number[], options?: IHightfield)

    update(): void
    updateMinValue(): void
    updateMaxValue(): void
    setHeightValueAtIndex(xi: number, yi: number, value: number): void
    getRectMinMax(iMinX: number, iMinY: number, iMaxX: number, iMaxY: number, result: any[]): void
    getIndexOfPosition(x: number, y: number, result: any[], clamp: boolean): boolean
    getConvexTrianglePillar(xi: number, yi: number, getUpperTriangle: boolean): void
  }

  export class Particle extends Shape {}

  export class Plane extends Shape {
    worldNormal: Vec3
    worldNormalNeedsUpdate: boolean
    boundingSphereRadius: number

    computeWorldNormal(quat: Quaternion): void
    calculateWorldAABB(pos: Vec3, quat: Quaternion, min: number, max: number): void
  }

  export class Shape {
    static types: {
      SPHERE: number
      PLANE: number
      BOX: number
      COMPOUND: number
      CONVEXPOLYHEDRON: number
      HEIGHTFIELD: number
      PARTICLE: number
      CYLINDER: number
    }

    type: number
    boundingSphereRadius: number
    collisionResponse: boolean

    updateBoundingSphereRadius(): number
    volume(): number
    calculateLocalInertia(mass: number, target: Vec3): Vec3
  }

  export class Sphere extends Shape {
    radius: number

    constructor(radius: number)
  }

  export class GSSolver extends Solver {
    iterations: number
    tolerance: number

    solve(dy: number, world: World): number
  }

  export class Solver {
    iterations: number
    equations: Equation[]

    solve(dy: number, world: World): number
    addEquation(eq: Equation): void
    removeEquation(eq: Equation): void
    removeAllEquations(): void
  }

  export class SplitSolver extends Solver {
    subsolver: Solver

    constructor(subsolver: Solver)

    solve(dy: number, world: World): number
  }

  export class EventTarget {
    addEventListener(type: string, listener: Function): EventTarget
    hasEventListener(type: string, listener: Function): boolean
    removeEventListener(type: string, listener: Function): EventTarget
    dispatchEvent(event: IEvent): IEvent
  }

  export class Pool {
    objects: any[]
    type: any[]

    release(): any
    get(): any
    constructObject(): any
  }

  export class TupleDictionary {
    data: {
      keys: any[]
    }

    get(i: number, j: number): number
    set(i: number, j: number, value: number): void
    reset(): void
  }

  export class Utils {
    static defaults(options?: any, defaults?: any): any
  }

  export class Vec3Pool extends Pool {
    type: any

    constructObject(): Vec3
  }

  export class NarrowPhase {
    contactPointPool: Pool[]
    v3pool: Vec3Pool
  }

  export class World extends EventTarget {
    iterations: number
    dt: number
    allowSleep: boolean
    contacts: ContactEquation[]
    frictionEquations: FrictionEquation[]
    quatNormalizeSkip: number
    quatNormalizeFast: boolean
    time: number
    stepnumber: number
    default_dt: number
    nextId: number
    gravity: Vec3
    broadphase: NaiveBroadphase
    bodies: Body[]
    solver: Solver
    constraints: Constraint[]
    narrowPhase: NarrowPhase
    collisionMatrix: ArrayCollisionMatrix
    collisionMatrixPrevious: ArrayCollisionMatrix
    materials: Material[]
    contactmaterials: ContactMaterial[]
    contactMaterialTable: TupleDictionary
    defaultMaterial: Material
    defaultContactMaterial: ContactMaterial
    doProfiling: boolean
    profile: {
      solve: number
      makeContactConstraints: number
      broadphaser: number
      integrate: number
      narrowphase: number
    }
    subsystems: any[]
    addBodyEvent: IBodyEvent
    removeBodyEvent: IBodyEvent

    getContactMaterial(m1: Material, m2: Material): ContactMaterial
    numObjects(): number
    collisionMatrixTick(): void
    addBody(body: Body): void
    addConstraint(c: Constraint): void
    removeConstraint(c: Constraint): void
    rayTest(from: Vec3, to: Vec3, result: RaycastResult): void
    remove(body: Body): void
    addMaterial(m: Material): void
    addContactMaterial(cmat: ContactMaterial): void
    step(dy: number, timeSinceLastCalled?: number, maxSubSteps?: number): void
  }

  export interface IEvent {
    type: string
  }

  export interface IBodyEvent extends IEvent {
    body: Body
  }

  export interface ICollisionEvent extends IBodyEvent {
    contact: any
  }
}

declare module 'cannon' {
  export = CANNON
}

function getMarkerEntity(): Entity {
  const markers = Array.from(engine.getEntitiesWith(Marker))
  if (markers.length > 0) {
    return markers[0][0]
  }
  throw new Error('No marker found')
}

export function setupMarker() {
  const marker = engine.addEntity()
  MeshRenderer.setSphere(marker)
  Transform.create(marker, { scale: Vector3.Zero() })
  Material.setPbrMaterial(marker, markerMaterial)
  Marker.create(marker)

  // Joint body
  const shape = new CANNON.Sphere(0.1)
  const jointBody = new CANNON.Body({ mass: 0 })
  jointBody.addShape(shape)
  jointBody.collisionFilterGroup = 0
  jointBody.collisionFilterMask = 0
  jointBody.id = JointBodyID
  addBody(jointBody)
}

function addMouseConstraint(x: number, y: number, z: number, bodyId: number) {
  const constrainedBody = getBoxBodyOrNull(bodyId)
  if (!constrainedBody) return

  // Vector to the clicked point, relative to the body
  const v1 = new CANNON.Vec3(x, y, z).vsub(constrainedBody.position)

  // Apply anti-quaternion to vector to tranform it into the local body coordinate system
  const antiRot = constrainedBody.quaternion.inverse()
  const pivot = antiRot.vmult(v1) // pivot is not in local body coordinates

  // Move the cannon click marker particle to the click position
  const body = getBoxBodyOrNull(JointBodyID)
  if (!body) return

  body.position.set(x, y, z)

  // Create a new constraint
  // The pivot for the jointBody is zero
  const mouseConstraint = new CANNON.PointToPointConstraint(constrainedBody, pivot, body, new CANNON.Vec3(0, 0, 0))

  mouseConstraint.id = Marker.getMutable(getMarkerEntity()).mouseConstraintId++

  // Add the constriant to world
  addConstraint(mouseConstraint)
}

// This functions moves the transparent joint body to a new postion in space
function moveJointToPoint(x: number, y: number, z: number) {
  // Move the joint body to a new position
  getBoxBodyOrNull(JointBodyID)?.position.set(x, y, z)
  getConstraintOrNull(Marker.getMutable(getMarkerEntity()).mouseConstraintId)?.update()
}

function removeJointConstraint() {
  // Remove constraint from world
  const mouseConstraint = getConstraintOrNull(Marker.getMutable(getMarkerEntity()).mouseConstraintId)
  if (mouseConstraint) removeConstraint(mouseConstraint)
}

export function _inputSystem() {
  const markerEntity = getMarkerEntity()
  const marker = Marker.get(markerEntity)
  const eventPointerDown = inputSystem.getInputCommand(InputAction.IA_POINTER, PointerEventType.PET_DOWN)

  if (eventPointerDown && !marker.isPointerPressed) {
    const marker = Marker.getMutable(markerEntity)
    marker.isPointerPressed = true

    // Only show marker when raycast hits an entity
    if (eventPointerDown.hit && eventPointerDown.hit.length !== 0 && eventPointerDown.hit.entityId) {
      const boxBody = BoxBody.getOrNull(eventPointerDown.hit.entityId as Entity)
      if (boxBody) {
        Transform.getMutable(markerEntity).scale = Vector3.create(0.1, 0.1, 0.1)
        marker.markerDistance = eventPointerDown.hit.length

        const position = eventPointerDown.hit?.position
        if (position) addMouseConstraint(position.x, position.y, position.z, boxBody.boxBodyId)
      }
    }
  }

  if (inputSystem.isTriggered(InputAction.IA_POINTER, PointerEventType.PET_UP) && marker.isPointerPressed) {
    const marker = Marker.getMutable(markerEntity)

    // Remove marker
    Transform.getMutable(markerEntity).scale = Vector3.Zero()

    marker.isPointerPressed = false
    marker.markerDistance = 0
    removeJointConstraint()
  }

  if (inputSystem.isTriggered(InputAction.IA_PRIMARY, PointerEventType.PET_DOWN)) {
    Marker.getMutable(markerEntity).isEKeyPressed = true
    Material.setPbrMaterial(markerEntity, markerPullMaterial)
  }

  if (inputSystem.isTriggered(InputAction.IA_PRIMARY, PointerEventType.PET_UP)) {
    Marker.getMutable(markerEntity).isEKeyPressed = false
    Material.setPbrMaterial(markerEntity, markerMaterial)
  }
}

export function updateMarkerSystem(dt: number) {
  const marker = Marker.get(getMarkerEntity())
  // Grab the object
  if (marker.isPointerPressed && marker.markerDistance !== 0) {
    const marker = getMarkerEntity()
    const camera = Transform.get(engine.CameraEntity)
    const forwardVector = Vector3.rotate(
      Vector3.scale(Vector3.Forward(), Marker.getMutable(marker).markerDistance),
      camera.rotation
    )

    const forwardVectorTransformed = Vector3.add(camera.position, forwardVector)
    Transform.getMutable(marker).position = forwardVectorTransformed

    const position = Transform.get(marker).position
    moveJointToPoint(position.x, position.y, position.z)
  }

  // Pull in the object
  if (marker.isEKeyPressed && marker.markerDistance !== 0 && marker.markerDistance > 1) {
    Marker.getMutable(getMarkerEntity()).markerDistance -= 5 * dt
  }
}"
/* piano key */,"import * as utils from '@dcl/ecs-scene-utils'
import { TriggerBoxShape } from '@dcl/npc-scene-utils'
export const sceneMessageBus = new MessageBus()

export let keys: PianoKey[] = []

export class PianoKey extends Entity {
  material: Material = new Material()
  onColor: Color3 = new Color3(1.75, 1.25, 0.0) // Orange glow
  offColor: Color3 = Color3.Black() // To zero out emissive
  note: number

  constructor(
    shape: PlaneShape,
    transform: Transform,
    color: Color3,
    sound: AudioClip,
    trigger: TriggerBoxShape,
    note: number
  ) {
    super()
    engine.addEntity(this)
    this.addComponent(shape)
    this.addComponent(transform)
    this.material.albedoColor = color
    this.material.metallic = 0.0
    this.material.roughness = 1.0
    this.addComponent(this.material)

    // note ID
    this.note = note

    // Sound
    this.addComponent(new AudioSource(sound))

    // Create trigger
    this.addComponent(
      new utils.TriggerComponent(
        trigger, //shape
        {
          onCameraEnter: () => {
            sceneMessageBus.emit('noteOn', { note: this.note })
          },
          onCameraExit: () => {
            sceneMessageBus.emit('noteOff', { note: this.note })
          }
        }
      )
    )
  }
  public play(): void {
    this.getComponent(AudioSource).playOnce()
    this.material.emissiveColor = this.onColor
  }
  public end(): void {
    this.material.emissiveColor = this.offColor
  }
}

export function addKeyListeners() {
  sceneMessageBus.on('noteOn', (e) => {
    keys[e.note].play()
  })

  sceneMessageBus.on('noteOff', (e) => {
    keys[e.note].end()
  })
}"
/* piano builder */ ,"import * as utils from '@dcl/ecs-scene-utils'
import resources from '../resources'
import * as utils from '@dcl/ecs-scene-utils'
import { TriggerBoxShape } from '@dcl/npc-scene-utils'
export const sceneMessageBus = new MessageBus()

export let keys: PianoKey[] = []

export class PianoKey extends Entity {
  material: Material = new Material()
  onColor: Color3 = new Color3(1.75, 1.25, 0.0) // Orange glow
  offColor: Color3 = Color3.Black() // To zero out emissive
  note: number

  constructor(
    shape: PlaneShape,
    transform: Transform,
    color: Color3,
    sound: AudioClip,
    trigger: TriggerBoxShape,
    note: number
  ) {
    super()
    engine.addEntity(this)
    this.addComponent(shape)
    this.addComponent(transform)
    this.material.albedoColor = color
    this.material.metallic = 0.0
    this.material.roughness = 1.0
    this.addComponent(this.material)

    // note ID
    this.note = note

    // Sound
    this.addComponent(new AudioSource(sound))

    // Create trigger
    this.addComponent(
      new utils.TriggerComponent(
        trigger, //shape
        {
          onCameraEnter: () => {
            sceneMessageBus.emit('noteOn', { note: this.note })
          },
          onCameraExit: () => {
            sceneMessageBus.emit('noteOff', { note: this.note })
          }
        }
      )
    )
  }
  public play(): void {
    this.getComponent(AudioSource).playOnce()
    this.material.emissiveColor = this.onColor
  }
  public end(): void {
    this.material.emissiveColor = this.offColor
  }
}

export function addKeyListeners() {
  sceneMessageBus.on('noteOn', (e) => {
    keys[e.note].play()
  })

  sceneMessageBus.on('noteOff', (e) => {
    keys[e.note].end()
  })
}
export function addPiano(): void {
  // For piano for transforming the piano
  const pianoBase = new Entity()
  pianoBase.addComponent(resources.models.standard.pianoBase)
  pianoBase.addComponent(
    new Transform({
      position: new Vector3(162.0, 0.0, 291.312),
    })
  )
  engine.addEntity(pianoBase)

  // Key shape
  const keyShape = new PlaneShape()

  // White keys
  const whiteKeySounds: AudioClip[] = [
    resources.sounds.piano.whiteKeys.c3,
    resources.sounds.piano.whiteKeys.d3,
    resources.sounds.piano.whiteKeys.e3,
    resources.sounds.piano.whiteKeys.f3,
    resources.sounds.piano.whiteKeys.g3,
    resources.sounds.piano.whiteKeys.a3,
    resources.sounds.piano.whiteKeys.b3,
    resources.sounds.piano.whiteKeys.c4,
    resources.sounds.piano.whiteKeys.d4,
    resources.sounds.piano.whiteKeys.e4,
    resources.sounds.piano.whiteKeys.f4,
    resources.sounds.piano.whiteKeys.g4,
    resources.sounds.piano.whiteKeys.a4,
    resources.sounds.piano.whiteKeys.b4,
    resources.sounds.piano.whiteKeys.c5,
    resources.sounds.piano.whiteKeys.d5,
    resources.sounds.piano.whiteKeys.e5,
    resources.sounds.piano.whiteKeys.f5,
    resources.sounds.piano.whiteKeys.g5,
    resources.sounds.piano.whiteKeys.a5,
    resources.sounds.piano.whiteKeys.b5,
  ]

  let whiteKeyXPos = -8.0001 // Workaround: Issue with setting this to -8

  for (let i = 0; i < whiteKeySounds.length; i++) {
    const key = new PianoKey(
      keyShape,
      new Transform({
        position: new Vector3(whiteKeyXPos, 0.11, 0),
        scale: new Vector3(0.7, 4, 1),
        rotation: new Quaternion(0.70711, 0, 0, 0.70711),
      }),
      Color3.White(),
      whiteKeySounds[i],
      resources.trigger.triggerWhitePianoKey,
      i
    )
    key.setParent(pianoBase)
    keys.push(key)
    whiteKeyXPos += 0.8
  }

  // Black keys
  const blackKeySounds: AudioClip[] = [
    resources.sounds.piano.blackKeys.cSharp3,
    resources.sounds.piano.blackKeys.dSharp3,
    resources.sounds.piano.blackKeys.fSharp3,
    resources.sounds.piano.blackKeys.gSharp3,
    resources.sounds.piano.blackKeys.aSharp3,
    resources.sounds.piano.blackKeys.cSharp4,
    resources.sounds.piano.blackKeys.dSharp4,
    resources.sounds.piano.blackKeys.fSharp4,
    resources.sounds.piano.blackKeys.gSharp4,
    resources.sounds.piano.blackKeys.aSharp4,
    resources.sounds.piano.blackKeys.cSharp5,
    resources.sounds.piano.blackKeys.dSharp5,
    resources.sounds.piano.blackKeys.fSharp5,
    resources.sounds.piano.blackKeys.gSharp5,
    resources.sounds.piano.blackKeys.aSharp5,
  ]

  let blackKeyXPos = -7.6001 // Workaround: Issue with setting this to -7.6
  let skipKey = 1

  for (let i = 0; i < blackKeySounds.length; i++) {
    const key = new PianoKey(
      keyShape,
      new Transform({
        position: new Vector3(blackKeyXPos, 0.12, 1),
        scale: new Vector3(0.45, 2, 1),
        rotation: new Quaternion(0.70711, 0, 0, 0.70711),
      }),
      Color3.Black(),
      blackKeySounds[i],
      resources.trigger.triggerBlackPianoKey,
      i + whiteKeySounds.length
    )
    key.setParent(pianoBase)
    keys.push(key)

    // Skip key
    skipKey++
    skipKey % 3 != 0 ? (blackKeyXPos += 0.8) : (blackKeyXPos += 1.6)
    if (skipKey === 6) skipKey = 1
  }
  addKeyListeners()
}"
/* resources */ ,"// import { TriggerBoxShape, TriggerSphereShape } from '@dcl/npc-scene-utils'
import * as utils from ""@dcl/ecs-scene-utils""

export default {
  sounds: {
    robots: {
      alice: new AudioClip(""sounds/alice.mp3""),
      bela: new AudioClip(""sounds/bela.mp3""),
      betty: new AudioClip(""sounds/betty.mp3""),
      bob: new AudioClip(""sounds/bob.mp3""),
      charlie: new AudioClip(""sounds/charlie.mp3""),
      marsha: new AudioClip(""sounds/marsha.mp3""),
      ron: new AudioClip(""sounds/ron.mp3""),
    },
    ui: {
      navigationForward: new AudioClip(""sounds/navigationForward.mp3""),
      navigationBackward: new AudioClip(""sounds/navigationBackward.mp3""),
    },
    piano: {
      whiteKeys: {
        c3: new AudioClip(""sounds/piano/c3.mp3""),
        d3: new AudioClip(""sounds/piano/d3.mp3""),
        e3: new AudioClip(""sounds/piano/e3.mp3""),
        f3: new AudioClip(""sounds/piano/f3.mp3""),
        g3: new AudioClip(""sounds/piano/g3.mp3""),
        a3: new AudioClip(""sounds/piano/a3.mp3""),
        b3: new AudioClip(""sounds/piano/b3.mp3""),
        c4: new AudioClip(""sounds/piano/c4.mp3""),
        d4: new AudioClip(""sounds/piano/d4.mp3""),
        e4: new AudioClip(""sounds/piano/e4.mp3""),
        f4: new AudioClip(""sounds/piano/f4.mp3""),
        g4: new AudioClip(""sounds/piano/g4.mp3""),
        a4: new AudioClip(""sounds/piano/a4.mp3""),
        b4: new AudioClip(""sounds/piano/b4.mp3""),
        c5: new AudioClip(""sounds/piano/c5.mp3""),
        d5: new AudioClip(""sounds/piano/d5.mp3""),
        e5: new AudioClip(""sounds/piano/e5.mp3""),
        f5: new AudioClip(""sounds/piano/f5.mp3""),
        g5: new AudioClip(""sounds/piano/g5.mp3""),
        a5: new AudioClip(""sounds/piano/a5.mp3""),
        b5: new AudioClip(""sounds/piano/b5.mp3""),
      },
      blackKeys: {
        cSharp3: new AudioClip(""sounds/piano/cSharp3.mp3""),
        dSharp3: new AudioClip(""sounds/piano/dSharp3.mp3""),
        fSharp3: new AudioClip(""sounds/piano/fSharp3.mp3""),
        gSharp3: new AudioClip(""sounds/piano/gSharp3.mp3""),
        aSharp3: new AudioClip(""sounds/piano/aSharp3.mp3""),
        cSharp4: new AudioClip(""sounds/piano/cSharp4.mp3""),
        dSharp4: new AudioClip(""sounds/piano/dSharp4.mp3""),
        fSharp4: new AudioClip(""sounds/piano/fSharp4.mp3""),
        gSharp4: new AudioClip(""sounds/piano/gSharp4.mp3""),
        aSharp4: new AudioClip(""sounds/piano/aSharp4.mp3""),
        cSharp5: new AudioClip(""sounds/piano/cSharp5.mp3""),
        dSharp5: new AudioClip(""sounds/piano/dSharp5.mp3""),
        fSharp5: new AudioClip(""sounds/piano/fSharp5.mp3""),
        gSharp5: new AudioClip(""sounds/piano/gSharp5.mp3""),
        aSharp5: new AudioClip(""sounds/piano/aSharp5.mp3""),
      },
    },
  },
  models: {
    standard: {
      pianoBase: new GLTFShape(""models/piano/pianoBase.glb""),
      muralWall: new GLTFShape(""models/mural/muralWall.glb""),
    },
    robots: {
      alice: ""models/robots/alice.glb"",
      bela: ""models/robots/bela.glb"",
      betty: ""models/robots/betty.glb"",
      bob: ""models/robots/bob.glb"",
      charlie: ""models/robots/charlie.glb"",
      marsha: ""models/robots/marsha.glb"",
      ron: ""models/robots/ron.glb"",
      rings: new GLTFShape(""models/robots/rings.glb""),
    },
  },
  textures: {
    blank: new Texture(""images/ui/blank.png""),
    buttonE: new Texture(""images/ui/buttonE.png""),
    buttonF: new Texture(""images/ui/buttonF.png""),
    leftClickIcon: new Texture(""images/ui/leftClickIcon.png""),
    textPanel: new Texture(""images/ui/textPanel.png""),
    nftPanel: new Texture(""images/ui/nftPanel.png""),
    closeButton: new Texture(""images/ui/closeButton.png""),
    placeholder: new Texture(""images/ui/placeholder.png""),
  },
  trigger: {
    triggerShape: new utils.TriggerSphereShape(8, Vector3.Zero()), // Trigger sphere with a radius of 8m
    triggerWhitePianoKey: new utils.TriggerBoxShape(new Vector3(0.35, 3.6, 2), new Vector3(0, 0, -1)),
    triggerBlackPianoKey: new utils.TriggerBoxShape(new Vector3(0.35, 3.6, 2), Vector3.Zero()),
  },
}"
/* hypno wheels */,"import { engine, Transform } from '@dcl/sdk/ecs'
import { Quaternion } from '@dcl/sdk/math'
import { engine, Schemas } from ""@dcl/sdk/ecs"";

enum CustomComponentIds {
  WheelSpin = 2002
}

export const WheelSpin = engine.defineComponent(
  {
    active: Schemas.Boolean,
    speed: Schemas.Number,
    direction: Schemas.Vector3
  },
  CustomComponentIds.WheelSpin
)
export default function rotatorSystem(dt: number) {
  for (const [entity, readonlySpin] of engine.getEntitiesWith(WheelSpin, Transform)) {
    // check state
    if (readonlySpin.active) {
      const spin = WheelSpin.getMutable(entity)
      const transform = Transform.getMutable(entity)

      // spin the wheel
      transform.rotation = Quaternion.multiply(
        transform.rotation,
        Quaternion.fromAngleAxis(spin.speed * dt, spin.direction)
      )

      spin.speed -= 6 * dt
      if (spin.speed <= 0) {
        spin.speed = 0
        spin.active = false
      }
    }
  }
}"
/* painter */ ,"import { engine, Material, PBMaterial_PbrMaterial, Schemas } from ""@dcl/sdk/ecs""
import { Color3 } from ""@dcl/sdk/math""

export const PainterComponent = engine.defineComponent(
  {
    t: Schemas.Number
  },
  2022
)

const greenMaterial: PBMaterial_PbrMaterial = {
  albedoColor: { r: 0, g: 1, b: 0 }
}

const lightGreenMaterial: PBMaterial_PbrMaterial = {
  albedoColor: { r: 0, g: 1, b: 1 }
}

function equalColor(a?: Color3, b?: Color3) {
  if (a && b) {
    return a.r === b.r && a.g === b.g && a.b === b.b
  } else if (a || b) {
    return false
  }
  return true
}

engine.addSystem((dt: number) => {
  for (const [entity] of engine.getEntitiesWith(PainterComponent)) {
    const value = PainterComponent.getMutable(entity)
    value.t += dt

    const materialReadonly = Material.getOrNull(entity)
    if (materialReadonly?.material?.$case === 'pbr') {
      if (
        materialReadonly === null ||
        !equalColor(materialReadonly.material.pbr.albedoColor, greenMaterial.albedoColor)
      ) {
        Material.setPbrMaterial(entity, { ...greenMaterial })
      }
    }

    if (value.t > 1) {
      Material.setPbrMaterial(entity, { ...lightGreenMaterial })
      PainterComponent.deleteFrom(entity)
    }
  }
})"
/* query meshes */ ,"mport { engine, Transform, GltfContainer, PointerEventsResult, inputSystem, InputAction, PointerEventType } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'



import { Entity, engine, Transform, MeshRenderer, MeshCollider, Billboard, TextShape, Font } from ""@dcl/sdk/ecs""
import { Vector3 } from ""@dcl/sdk/math""

export function createMesh(
  position: Vector3.ReadonlyVector3,
  text: string = '',
  scale: number = 1.0,
  sphere = false
): Entity {
  const meshEntity = engine.addEntity()
  Transform.create(meshEntity, { position, scale: Vector3.scale(Vector3.One(), scale) })

  if (sphere) {
    MeshRenderer.setSphere(meshEntity)
    MeshCollider.setSphere(meshEntity)
  } else {
    MeshRenderer.setBox(meshEntity)
    MeshCollider.setBox(meshEntity)
  }

  if (text) {
    addLabel(text, meshEntity)
  }

  return meshEntity
}

export function addLabel(text: string, parent: Entity) {
  const label = engine.addEntity()
  Transform.create(label, {
    position: Vector3.create(0, 1.5, 0),
    parent
  })
  Billboard.create(label, { oppositeDirection: true })

  TextShape.create(label, {
    text,
    fontSize: 2,
    font: Font.F_SANS_SERIF
  })
}

import { engine, Material, PBMaterial_PbrMaterial, Schemas } from ""@dcl/sdk/ecs""
import { Color3 } from ""@dcl/sdk/math""

export const PainterComponent = engine.defineComponent(
  {
    t: Schemas.Number
  },
  2022
)

const greenMaterial: PBMaterial_PbrMaterial = {
  albedoColor: { r: 0, g: 1, b: 0 }
}

const lightGreenMaterial: PBMaterial_PbrMaterial = {
  albedoColor: { r: 0, g: 1, b: 1 }
}

function equalColor(a?: Color3, b?: Color3) {
  if (a && b) {
    return a.r === b.r && a.g === b.g && a.b === b.b
  } else if (a || b) {
    return false
  }
  return true
}

engine.addSystem((dt: number) => {
  for (const [entity] of engine.getEntitiesWith(PainterComponent)) {
    const value = PainterComponent.getMutable(entity)
    value.t += dt

    const materialReadonly = Material.getOrNull(entity)
    if (materialReadonly?.material?.$case === 'pbr') {
      if (
        materialReadonly === null ||
        !equalColor(materialReadonly.material.pbr.albedoColor, greenMaterial.albedoColor)
      ) {
        Material.setPbrMaterial(entity, { ...greenMaterial })
      }
    }

    if (value.t > 1) {
      Material.setPbrMaterial(entity, { ...lightGreenMaterial })
      PainterComponent.deleteFrom(entity)
    }
  }
})


// robots base
export function setupQueryMeshes() {
  const robots = engine.addEntity()

  Transform.create(robots, { position: Vector3.create(12, 0, 2) })
  GltfContainer.create(robots, { src: 'models/Robots.glb' })

  // // Robot feedback cube 1
  createMesh(Vector3.create(13, 1, 1.5), 'Click robot 1', 0.5, false)

  // // Robot feedback cube 2
  const r2 = createMesh(Vector3.create(10.5, 1, 1.5), 'Click robot 2', 0.5, false)

  // TODO: we can not distinguish btween mesh inside gltf yet
  engine.addSystem(() => {
    const results = PointerEventsResult.getOrNull(engine.RootEntity)
    if (results) {
      //   log({ results })
    }

    if (inputSystem.isTriggered(InputAction.IA_POINTER, PointerEventType.PET_DOWN, r2)) {
      PainterComponent.createOrReplace(r2)
    }
  })"
/* proximity */ ,"import { engine, Transform, GltfContainer } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'


import { Entity, engine, Transform, MeshRenderer, MeshCollider, Billboard, TextShape, Font } from ""@dcl/sdk/ecs""
import { Vector3 } from ""@dcl/sdk/math""

export function createMesh(
  position: Vector3.ReadonlyVector3,
  text: string = '',
  scale: number = 1.0,
  sphere = false
): Entity {
  const meshEntity = engine.addEntity()
  Transform.create(meshEntity, { position, scale: Vector3.scale(Vector3.One(), scale) })

  if (sphere) {
    MeshRenderer.setSphere(meshEntity)
    MeshCollider.setSphere(meshEntity)
  } else {
    MeshRenderer.setBox(meshEntity)
    MeshCollider.setBox(meshEntity)
  }

  if (text) {
    addLabel(text, meshEntity)
  }

  return meshEntity
}

export function addLabel(text: string, parent: Entity) {
  const label = engine.addEntity()
  Transform.create(label, {
    position: Vector3.create(0, 1.5, 0),
    parent
  })
  Billboard.create(label, { oppositeDirection: true })

  TextShape.create(label, {
    text,
    fontSize: 2,
    font: Font.F_SANS_SERIF
  })
}

import { engine, Material, PBMaterial_PbrMaterial, Schemas } from ""@dcl/sdk/ecs""
import { Color3 } from ""@dcl/sdk/math""

export const PainterComponent = engine.defineComponent(
  {
    t: Schemas.Number
  },
  2022
)

const greenMaterial: PBMaterial_PbrMaterial = {
  albedoColor: { r: 0, g: 1, b: 0 }
}

const lightGreenMaterial: PBMaterial_PbrMaterial = {
  albedoColor: { r: 0, g: 1, b: 1 }
}

function equalColor(a?: Color3, b?: Color3) {
  if (a && b) {
    return a.r === b.r && a.g === b.g && a.b === b.b
  } else if (a || b) {
    return false
  }
  return true
}

engine.addSystem((dt: number) => {
  for (const [entity] of engine.getEntitiesWith(PainterComponent)) {
    const value = PainterComponent.getMutable(entity)
    value.t += dt

    const materialReadonly = Material.getOrNull(entity)
    if (materialReadonly?.material?.$case === 'pbr') {
      if (
        materialReadonly === null ||
        !equalColor(materialReadonly.material.pbr.albedoColor, greenMaterial.albedoColor)
      ) {
        Material.setPbrMaterial(entity, { ...greenMaterial })
      }
    }

    if (value.t > 1) {
      Material.setPbrMaterial(entity, { ...lightGreenMaterial })
      PainterComponent.deleteFrom(entity)
    }
  }
})

export function setupProximity() {
  const closeCube = createMesh(Vector3.create(2, 1, 9), 'Walk near')

  // check distance for closeCube
  engine.addSystem(() => {
    const transform = Transform.get(closeCube)
    const playerPosition = Transform.getOrNull(engine.PlayerEntity)
    if (playerPosition) {
      const dist = Vector3.distanceSquared(transform.position, playerPosition.position)
      if (dist < 8) {
        PainterComponent.createOrReplace(closeCube)
      }
    }
  })

  // ground
  const floor = engine.addEntity()
  GltfContainer.create(floor, { src: 'models/FloorBaseGrass.glb' })
  Transform.create(floor, {
    position: Vector3.create(8, 0, 8),
    scale: Vector3.create(1.6, 0.1, 1.6)
  })
}"
/* global events */ ,"import { Vector3 } from '@dcl/sdk/math'
import { engine, Entity, InputAction, inputSystem, PointerEventType } from '@dcl/sdk/ecs'


import { Entity, engine, Transform, MeshRenderer, MeshCollider, Billboard, TextShape, Font } from ""@dcl/sdk/ecs""
import { Vector3 } from ""@dcl/sdk/math""

export function createMesh(
  position: Vector3.ReadonlyVector3,
  text: string = '',
  scale: number = 1.0,
  sphere = false
): Entity {
  const meshEntity = engine.addEntity()
  Transform.create(meshEntity, { position, scale: Vector3.scale(Vector3.One(), scale) })

  if (sphere) {
    MeshRenderer.setSphere(meshEntity)
    MeshCollider.setSphere(meshEntity)
  } else {
    MeshRenderer.setBox(meshEntity)
    MeshCollider.setBox(meshEntity)
  }

  if (text) {
    addLabel(text, meshEntity)
  }

  return meshEntity
}

export function addLabel(text: string, parent: Entity) {
  const label = engine.addEntity()
  Transform.create(label, {
    position: Vector3.create(0, 1.5, 0),
    parent
  })
  Billboard.create(label, { oppositeDirection: true })

  TextShape.create(label, {
    text,
    fontSize: 2,
    font: Font.F_SANS_SERIF
  })
}

import { engine, Material, PBMaterial_PbrMaterial, Schemas } from ""@dcl/sdk/ecs""
import { Color3 } from ""@dcl/sdk/math""

export const PainterComponent = engine.defineComponent(
  {
    t: Schemas.Number
  },
  2022
)

const greenMaterial: PBMaterial_PbrMaterial = {
  albedoColor: { r: 0, g: 1, b: 0 }
}

const lightGreenMaterial: PBMaterial_PbrMaterial = {
  albedoColor: { r: 0, g: 1, b: 1 }
}

function equalColor(a?: Color3, b?: Color3) {
  if (a && b) {
    return a.r === b.r && a.g === b.g && a.b === b.b
  } else if (a || b) {
    return false
  }
  return true
}

engine.addSystem((dt: number) => {
  for (const [entity] of engine.getEntitiesWith(PainterComponent)) {
    const value = PainterComponent.getMutable(entity)
    value.t += dt

    const materialReadonly = Material.getOrNull(entity)
    if (materialReadonly?.material?.$case === 'pbr') {
      if (
        materialReadonly === null ||
        !equalColor(materialReadonly.material.pbr.albedoColor, greenMaterial.albedoColor)
      ) {
        Material.setPbrMaterial(entity, { ...greenMaterial })
      }
    }

    if (value.t > 1) {
      Material.setPbrMaterial(entity, { ...lightGreenMaterial })
      PainterComponent.deleteFrom(entity)
    }
  }
})


export function setupGlobalEvents() {
  // Global Pointer Down Sphere
  const globalPointerDownCube = createMesh(Vector3.create(2, 1, 10), 'Global pointer down', 0.5, true)

  // Global Pointer Up Sphere
  const globalPointerUpCube = createMesh(Vector3.create(2, 1, 12), 'Global pointer up', 0.5, true)

  // Global Primary Down Sphere
  const globalPrimaryDownCube = createMesh(Vector3.create(4, 1, 10), 'Global primary down', 0.5, true)

  // Global Primary Up Sphere
  const globalPrimaryUpCube = createMesh(Vector3.create(4, 1, 12), 'Global primary up', 0.5, true)

  // Global Secondary Down Sphere
  const globalSecondaryDownCube = createMesh(Vector3.create(6, 1, 10), 'Global secondary down', 0.5, true)

  // Global Secondary Up Sphere
  const globalSecondaryUpCube = createMesh(Vector3.create(6, 1, 12), 'Global secondary up', 0.5, true)

  /////// GLOBAL EVENT LISTENERS

  const MagicGlobalEntity = undefined as any as Entity

  engine.addSystem(() => {
    if (inputSystem.isTriggered(InputAction.IA_POINTER, PointerEventType.PET_DOWN, MagicGlobalEntity)) {
      PainterComponent.createOrReplace(globalPointerDownCube)
    }
    if (inputSystem.isTriggered(InputAction.IA_POINTER, PointerEventType.PET_UP, MagicGlobalEntity)) {
      PainterComponent.createOrReplace(globalPointerUpCube)
    }
    if (inputSystem.isTriggered(InputAction.IA_PRIMARY, PointerEventType.PET_DOWN, MagicGlobalEntity)) {
      PainterComponent.createOrReplace(globalPrimaryDownCube)
    }
    if (inputSystem.isTriggered(InputAction.IA_PRIMARY, PointerEventType.PET_UP, MagicGlobalEntity)) {
      PainterComponent.createOrReplace(globalPrimaryUpCube)
    }
    if (inputSystem.isTriggered(InputAction.IA_SECONDARY, PointerEventType.PET_DOWN, MagicGlobalEntity)) {
      PainterComponent.createOrReplace(globalSecondaryDownCube)
    }
    if (inputSystem.isTriggered(InputAction.IA_SECONDARY, PointerEventType.PET_UP, MagicGlobalEntity)) {
      PainterComponent.createOrReplace(globalSecondaryUpCube)
    }
  })
}"
/* events on entities */,"// Pointer Down Cube

import { PointerHoverFeedback, PointerEventType, InputAction, engine, inputSystem } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'


import { Entity, engine, Transform, MeshRenderer, MeshCollider, Billboard, TextShape, Font } from ""@dcl/sdk/ecs""
import { Vector3 } from ""@dcl/sdk/math""

export function createMesh(
  position: Vector3.ReadonlyVector3,
  text: string = '',
  scale: number = 1.0,
  sphere = false
): Entity {
  const meshEntity = engine.addEntity()
  Transform.create(meshEntity, { position, scale: Vector3.scale(Vector3.One(), scale) })

  if (sphere) {
    MeshRenderer.setSphere(meshEntity)
    MeshCollider.setSphere(meshEntity)
  } else {
    MeshRenderer.setBox(meshEntity)
    MeshCollider.setBox(meshEntity)
  }

  if (text) {
    addLabel(text, meshEntity)
  }

  return meshEntity
}

export function addLabel(text: string, parent: Entity) {
  const label = engine.addEntity()
  Transform.create(label, {
    position: Vector3.create(0, 1.5, 0),
    parent
  })
  Billboard.create(label, { oppositeDirection: true })

  TextShape.create(label, {
    text,
    fontSize: 2,
    font: Font.F_SANS_SERIF
  })
}

import { engine, Material, PBMaterial_PbrMaterial, Schemas } from ""@dcl/sdk/ecs""
import { Color3 } from ""@dcl/sdk/math""

export const PainterComponent = engine.defineComponent(
  {
    t: Schemas.Number
  },
  2022
)

const greenMaterial: PBMaterial_PbrMaterial = {
  albedoColor: { r: 0, g: 1, b: 0 }
}

const lightGreenMaterial: PBMaterial_PbrMaterial = {
  albedoColor: { r: 0, g: 1, b: 1 }
}

function equalColor(a?: Color3, b?: Color3) {
  if (a && b) {
    return a.r === b.r && a.g === b.g && a.b === b.b
  } else if (a || b) {
    return false
  }
  return true
}

engine.addSystem((dt: number) => {
  for (const [entity] of engine.getEntitiesWith(PainterComponent)) {
    const value = PainterComponent.getMutable(entity)
    value.t += dt

    const materialReadonly = Material.getOrNull(entity)
    if (materialReadonly?.material?.$case === 'pbr') {
      if (
        materialReadonly === null ||
        !equalColor(materialReadonly.material.pbr.albedoColor, greenMaterial.albedoColor)
      ) {
        Material.setPbrMaterial(entity, { ...greenMaterial })
      }
    }

    if (value.t > 1) {
      Material.setPbrMaterial(entity, { ...lightGreenMaterial })
      PainterComponent.deleteFrom(entity)
    }
  }
})


export function setupEventOnEntities() {
  const pointerDownCube = createMesh(Vector3.create(2, 1, 4), 'Pointer down', 1, false)
  PointerHoverFeedback.create(pointerDownCube, {
    pointerEvents: [
      {
        eventType: PointerEventType.PET_DOWN,
        eventInfo: {
          button: InputAction.IA_POINTER,
          hoverText: 'Activate'
        }
      }
    ]
  })

  // Pointer Up Cube

  const pointerUpCube = createMesh(Vector3.create(2, 1, 6), 'Pointer up', 1, false)
  PointerHoverFeedback.create(pointerUpCube, {
    pointerEvents: [
      {
        eventType: PointerEventType.PET_UP,
        eventInfo: {
          button: InputAction.IA_PRIMARY,
          hoverText: 'Activate'
        }
      }
    ]
  })

  //  Primary Down Cube (while pointing)
  const primaryDownCube = createMesh(Vector3.create(8, 1, 12), 'Primary down', 1, false)
  PointerHoverFeedback.create(primaryDownCube, {
    pointerEvents: [
      {
        eventType: PointerEventType.PET_DOWN,
        eventInfo: {
          button: InputAction.IA_PRIMARY,
          hoverText: 'Activate'
        }
      }
    ]
  })
  // Primary Up Cube
  const primaryUpCube = createMesh(Vector3.create(10, 1, 12), 'Primary up', 1, false)
  PointerHoverFeedback.create(primaryUpCube, {
    pointerEvents: [
      {
        eventType: PointerEventType.PET_UP,
        eventInfo: {
          button: InputAction.IA_PRIMARY,
          hoverText: 'Activate'
        }
      }
    ]
  })

  // Secondary Down Cube
  const secondaryDownCube = createMesh(Vector3.create(12, 1, 12), 'Secondary down', 1, false)
  PointerHoverFeedback.create(secondaryDownCube, {
    pointerEvents: [
      {
        eventType: PointerEventType.PET_DOWN,
        eventInfo: {
          button: InputAction.IA_SECONDARY,
          hoverText: 'Activate'
        }
      }
    ]
  })

  // Secondary Up Cube
  const secondaryUpCube = createMesh(Vector3.create(14, 1, 12), 'Secondary up', 1, false)
  PointerHoverFeedback.create(secondaryUpCube, {
    pointerEvents: [
      {
        eventType: PointerEventType.PET_UP,
        eventInfo: {
          button: InputAction.IA_SECONDARY,
          hoverText: 'Activate'
        }
      }
    ]
  })

  engine.addSystem(() => {
    if (inputSystem.isTriggered(InputAction.IA_POINTER, PointerEventType.PET_DOWN, pointerDownCube)) {
      PainterComponent.createOrReplace(pointerDownCube)
    }
    if (inputSystem.isTriggered(InputAction.IA_POINTER, PointerEventType.PET_UP, pointerUpCube)) {
      PainterComponent.createOrReplace(pointerUpCube)
    }
    if (inputSystem.isTriggered(InputAction.IA_PRIMARY, PointerEventType.PET_DOWN, primaryDownCube)) {
      PainterComponent.createOrReplace(primaryDownCube)
    }
    if (inputSystem.isTriggered(InputAction.IA_PRIMARY, PointerEventType.PET_UP, primaryUpCube)) {
      PainterComponent.createOrReplace(primaryUpCube)
    }
    if (inputSystem.isTriggered(InputAction.IA_SECONDARY, PointerEventType.PET_DOWN, secondaryDownCube)) {
      PainterComponent.createOrReplace(secondaryDownCube)
    }
    if (inputSystem.isTriggered(InputAction.IA_SECONDARY, PointerEventType.PET_UP, secondaryUpCube)) {
      PainterComponent.createOrReplace(secondaryUpCube)
    }
  })
}"
/* dog */ ,"
import { Entity, engine, Transform, GltfContainer, Animator, PointerHoverFeedback, PointerEventType, InputAction } from '@dcl/sdk/ecs'
import { Schemas, engine } from '@dcl/sdk/ecs'
/**
 * @public
 */
export enum InterpolationType {
  LINEAR,

  EASEINQUAD,
  EASEOUTQUAD,
  EASEQUAD,

  EASEINSINE,
  EASEOUTSINE,
  EASESINE,

  EASEINEXPO,
  EASEOUTEXPO,
  EASEEXPO,

  EASEINELASTIC,
  EASEOUTELASTIC,
  EASEELASTIC,

  EASEINBOUNCE,
  EASEOUTEBOUNCE,
  EASEBOUNCE
}

/**
 * @public
 */
export function Interpolate(type: InterpolationType, t: number): number {
  switch (type) {
    case InterpolationType.LINEAR:
      return InterpolateLinear(t)
      break
    case InterpolationType.EASEINQUAD:
      return InterpolateEaseInQuad(t)
      break
    case InterpolationType.EASEOUTQUAD:
      return InterpolateEaseOutQuad(t)
      break
    case InterpolationType.EASEQUAD:
      return InterpolateEaseQuad(t)
      break
    case InterpolationType.EASEINSINE:
      return InterpolateEaseInSine(t)
      break
    case InterpolationType.EASEOUTSINE:
      return InterpolateEaseOutSine(t)
      break
    case InterpolationType.EASESINE:
      return InterpolateEaseInOutSine(t)
      break
    case InterpolationType.EASEINEXPO:
      return InterpolateEaseInExpo(t)
      break
    case InterpolationType.EASEOUTEXPO:
      return InterpolateEaseOutExpo(t)
      break
    case InterpolationType.EASEEXPO:
      return InterpolateEaseInOutExpo(t)
      break
    case InterpolationType.EASEINELASTIC:
      return InterpolateEaseInElastic(t)
      break
    case InterpolationType.EASEOUTELASTIC:
      return InterpolateEaseOutElastic(t)
      break
    case InterpolationType.EASEELASTIC:
      return InterpolateEaseInOutElastic(t)
      break
    case InterpolationType.EASEINBOUNCE:
      return InterpolateEaseInBounce(t)
      break
    case InterpolationType.EASEOUTEBOUNCE:
      return InterpolateEaseOutBounce(t)
      break
    case InterpolationType.EASEBOUNCE:
      return InterpolateEaseInOutBounce(t)
      break
    default:
      return InterpolateLinear(t)
  }
}
function InterpolateLinear(t: number): number {
  return t
}
function InterpolateEaseInQuad(t: number): number {
  return t * t
}
function InterpolateEaseOutQuad(t: number): number {
  return t * (2 - t)
}
function InterpolateEaseQuad(t: number): number {
  return (t * t) / (2.0 * (t * t - t) + 1.0)
}

function InterpolateEaseInSine(t: number): number {
  return 1 - Math.cos((t * Math.PI) / 2)
}

function InterpolateEaseOutSine(t: number): number {
  return Math.sin((t * Math.PI) / 2)
}

function InterpolateEaseInOutSine(t: number): number {
  return -(Math.cos(Math.PI * t) - 1) / 2
}

function InterpolateEaseInExpo(t: number): number {
  return t === 0 ? 0 : Math.pow(2, 10 * t - 10)
}

function InterpolateEaseOutExpo(t: number): number {
  return t === 1 ? 1 : 1 - Math.pow(2, -10 * t)
}

function InterpolateEaseInOutExpo(t: number): number {
  return t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2
}

function InterpolateEaseInElastic(t: number): number {
  const c4 = (2 * Math.PI) / 3

  return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4)
}

function InterpolateEaseOutElastic(t: number): number {
  const c5 = (2 * Math.PI) / 3

  return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c5) + 1
}

function InterpolateEaseInOutElastic(t: number): number {
  const c6 = (2 * Math.PI) / 4.5

  return t === 0
    ? 0
    : t === 1
    ? 1
    : t < 0.5
    ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c6)) / 2
    : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c6)) / 2 + 1
}

function InterpolateEaseInBounce(t: number): number {
  return 1 - bounce(1 - t)
}

function InterpolateEaseOutBounce(t: number): number {
  return bounce(t)
}

function InterpolateEaseInOutBounce(t: number): number {
  return t < 0.5 ? (1 - bounce(1 - 2 * t)) / 2 : (1 + bounce(2 * t - 1)) / 2
}

function bounce(x: number) {
  const n1 = 7.5625
  const d1 = 2.75

  if (x < 1 / d1) {
    return n1 * x * x
  } else if (x < 2 / d1) {
    return n1 * (x -= 1.5 / d1) * x + 0.75
  } else if (x < 2.5 / d1) {
    return n1 * (x -= 2.25 / d1) * x + 0.9375
  } else {
    return n1 * (x -= 2.625 / d1) * x + 0.984375
  }
}
export enum dogStates {
  Idle,
  Sit,
  Follow,
  GoDrink,
  Drinking
}

// TODO: use higher number so we dont have conflicts (i.e. > 2000)
export enum CustomComponentIds {
  MoveTransform = 2046,
  NPC = 2066,
  TimeOut = 2048
}

/**
 * Schemas and component definitions
 */

const MoveTransformSchema = {
  hasFinished: Schemas.Boolean,
  start: Schemas.Vector3,
  end: Schemas.Vector3,
  normalizedTime: Schemas.Float,
  lerpTime: Schemas.Float,
  speed: Schemas.Float,
  interpolationType: Schemas.Enum<InterpolationType>(Schemas.Int)
}

const MoveTransformComponent = engine.defineComponent(MoveTransformSchema, CustomComponentIds.MoveTransform)

const NPCSchema = {
  state: Schemas.Enum<dogStates>(Schemas.Int),
  previousState: Schemas.Enum<dogStates>(Schemas.Int)
}

const NPCComponent = engine.defineComponent(NPCSchema, CustomComponentIds.NPC)

const TimeOutSchema = {
  timeLeft: Schemas.Float,
  hasFinished: Schemas.Boolean,
  paused: Schemas.Boolean
}

const TimeOutComponent = engine.defineComponent(TimeOutSchema, CustomComponentIds.TimeOut)

/**
 * Export components
 */

export namespace CustomComponents {
  export const TimeOut = TimeOutComponent
  export const NPC = NPCComponent
  export const MoveTransform = MoveTransformComponent
}
const point1 = { x: 8, y: 0, z: 8 }
const point2 = { x: 8, y: 0, z: 24 }
// const point3 = { x: 24, y: 0, z: 24 }
// const point4 = { x: 24, y: 0, z: 8 }
// const pathArray = [point1, point2, point3, point4]
// const TURN_TIME = 0.9

export function createDog(): Entity {
  const dog = engine.addEntity()

  Transform.create(dog, {
    position: point1,
    scale: { x: 1, y: 1, z: 1 },
    rotation: { x: 0, y: 0, z: 0, w: 1 }
  })

  GltfContainer.create(dog, {
    src: 'models/BlockDog.glb'
  })

  Animator.create(dog, {
    states: [
      {
        name: 'Walking',
        clip: 'Walking',
        playing: false,
        weight: 1,
        speed: 1,
        loop: true,
        shouldReset: false
      },
      {
        name: 'Sitting',
        clip: 'Sitting',
        playing: false,
        weight: 1,
        speed: 1,
        loop: false,
        shouldReset: true
      },
      {
        name: 'Standing',
        clip: 'Standing',
        playing: false,
        weight: 1,
        speed: 1,
        loop: false,
        shouldReset: true
      },
      {
        name: 'Drinking',
        clip: 'Drinking',
        playing: false,
        weight: 1,
        speed: 1,
        loop: true,
        shouldReset: true
      },
      {
        name: 'Idle',
        clip: 'Idle',
        playing: false,
        weight: 1,
        speed: 1,
        loop: true,
        shouldReset: true
      }
    ]
  })

  CustomComponents.NPC.create(dog, { state: dogStates.Idle, previousState: dogStates.Idle })

  // const randomPathStart = Math.floor(Math.random() * 3)

  CustomComponents.MoveTransform.create(dog, {
    start: point1,
    end: point2,
    normalizedTime: 0,
    lerpTime: 0,
    speed: 0.1,
    hasFinished: false,
    interpolationType: 1
  })

  CustomComponents.TimeOut.create(dog, {
    timeLeft: 0.9,
    hasFinished: false,
    paused: false
  })

  PointerHoverFeedback.create(dog, {
    pointerEvents: [
      {
        eventType: PointerEventType.PET_DOWN,
        eventInfo: {
          button: InputAction.IA_PRIMARY,
          hoverText: 'Sit'
        }
      }
    ]
  })

  return dog
}"
/* dogAI */,"import { engine, Entity, Animator, PointerHoverFeedback, Transform } from '@dcl/sdk/ecs'
import { Vector3, Quaternion } from '@dcl/sdk/math'
mport { Schemas, engine } from '@dcl/sdk/ecs'
/**
 * @public
 */
export enum InterpolationType {
  LINEAR,

  EASEINQUAD,
  EASEOUTQUAD,
  EASEQUAD,

  EASEINSINE,
  EASEOUTSINE,
  EASESINE,

  EASEINEXPO,
  EASEOUTEXPO,
  EASEEXPO,

  EASEINELASTIC,
  EASEOUTELASTIC,
  EASEELASTIC,

  EASEINBOUNCE,
  EASEOUTEBOUNCE,
  EASEBOUNCE
}

/**
 * @public
 */
export function Interpolate(type: InterpolationType, t: number): number {
  switch (type) {
    case InterpolationType.LINEAR:
      return InterpolateLinear(t)
      break
    case InterpolationType.EASEINQUAD:
      return InterpolateEaseInQuad(t)
      break
    case InterpolationType.EASEOUTQUAD:
      return InterpolateEaseOutQuad(t)
      break
    case InterpolationType.EASEQUAD:
      return InterpolateEaseQuad(t)
      break
    case InterpolationType.EASEINSINE:
      return InterpolateEaseInSine(t)
      break
    case InterpolationType.EASEOUTSINE:
      return InterpolateEaseOutSine(t)
      break
    case InterpolationType.EASESINE:
      return InterpolateEaseInOutSine(t)
      break
    case InterpolationType.EASEINEXPO:
      return InterpolateEaseInExpo(t)
      break
    case InterpolationType.EASEOUTEXPO:
      return InterpolateEaseOutExpo(t)
      break
    case InterpolationType.EASEEXPO:
      return InterpolateEaseInOutExpo(t)
      break
    case InterpolationType.EASEINELASTIC:
      return InterpolateEaseInElastic(t)
      break
    case InterpolationType.EASEOUTELASTIC:
      return InterpolateEaseOutElastic(t)
      break
    case InterpolationType.EASEELASTIC:
      return InterpolateEaseInOutElastic(t)
      break
    case InterpolationType.EASEINBOUNCE:
      return InterpolateEaseInBounce(t)
      break
    case InterpolationType.EASEOUTEBOUNCE:
      return InterpolateEaseOutBounce(t)
      break
    case InterpolationType.EASEBOUNCE:
      return InterpolateEaseInOutBounce(t)
      break
    default:
      return InterpolateLinear(t)
  }
}
function InterpolateLinear(t: number): number {
  return t
}
function InterpolateEaseInQuad(t: number): number {
  return t * t
}
function InterpolateEaseOutQuad(t: number): number {
  return t * (2 - t)
}
function InterpolateEaseQuad(t: number): number {
  return (t * t) / (2.0 * (t * t - t) + 1.0)
}

function InterpolateEaseInSine(t: number): number {
  return 1 - Math.cos((t * Math.PI) / 2)
}

function InterpolateEaseOutSine(t: number): number {
  return Math.sin((t * Math.PI) / 2)
}

function InterpolateEaseInOutSine(t: number): number {
  return -(Math.cos(Math.PI * t) - 1) / 2
}

function InterpolateEaseInExpo(t: number): number {
  return t === 0 ? 0 : Math.pow(2, 10 * t - 10)
}

function InterpolateEaseOutExpo(t: number): number {
  return t === 1 ? 1 : 1 - Math.pow(2, -10 * t)
}

function InterpolateEaseInOutExpo(t: number): number {
  return t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2
}

function InterpolateEaseInElastic(t: number): number {
  const c4 = (2 * Math.PI) / 3

  return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4)
}

function InterpolateEaseOutElastic(t: number): number {
  const c5 = (2 * Math.PI) / 3

  return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c5) + 1
}

function InterpolateEaseInOutElastic(t: number): number {
  const c6 = (2 * Math.PI) / 4.5

  return t === 0
    ? 0
    : t === 1
    ? 1
    : t < 0.5
    ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c6)) / 2
    : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c6)) / 2 + 1
}

function InterpolateEaseInBounce(t: number): number {
  return 1 - bounce(1 - t)
}

function InterpolateEaseOutBounce(t: number): number {
  return bounce(t)
}

function InterpolateEaseInOutBounce(t: number): number {
  return t < 0.5 ? (1 - bounce(1 - 2 * t)) / 2 : (1 + bounce(2 * t - 1)) / 2
}

function bounce(x: number) {
  const n1 = 7.5625
  const d1 = 2.75

  if (x < 1 / d1) {
    return n1 * x * x
  } else if (x < 2 / d1) {
    return n1 * (x -= 1.5 / d1) * x + 0.75
  } else if (x < 2.5 / d1) {
    return n1 * (x -= 2.25 / d1) * x + 0.9375
  } else {
    return n1 * (x -= 2.625 / d1) * x + 0.984375
  }
}
export enum dogStates {
  Idle,
  Sit,
  Follow,
  GoDrink,
  Drinking
}

// TODO: use higher number so we dont have conflicts (i.e. > 2000)
export enum CustomComponentIds {
  MoveTransform = 2046,
  NPC = 2066,
  TimeOut = 2048
}

/**
 * Schemas and component definitions
 */

const MoveTransformSchema = {
  hasFinished: Schemas.Boolean,
  start: Schemas.Vector3,
  end: Schemas.Vector3,
  normalizedTime: Schemas.Float,
  lerpTime: Schemas.Float,
  speed: Schemas.Float,
  interpolationType: Schemas.Enum<InterpolationType>(Schemas.Int)
}

const MoveTransformComponent = engine.defineComponent(MoveTransformSchema, CustomComponentIds.MoveTransform)

const NPCSchema = {
  state: Schemas.Enum<dogStates>(Schemas.Int),
  previousState: Schemas.Enum<dogStates>(Schemas.Int)
}

const NPCComponent = engine.defineComponent(NPCSchema, CustomComponentIds.NPC)

const TimeOutSchema = {
  timeLeft: Schemas.Float,
  hasFinished: Schemas.Boolean,
  paused: Schemas.Boolean
}

const TimeOutComponent = engine.defineComponent(TimeOutSchema, CustomComponentIds.TimeOut)

/**
 * Export components
 */

export namespace CustomComponents {
  export const TimeOut = TimeOutComponent
  export const NPC = NPCComponent
  export const MoveTransform = MoveTransformComponent
}
export function dogBehavior() {
  for (const [entity] of engine.getEntitiesWith(CustomComponents.NPC)) {
    const npcData = CustomComponents.NPC.getMutable(entity)

    switch (npcData.state) {
      case dogStates.Idle:
        break

      case dogStates.Sit:
        break

      case dogStates.Follow:
        break

      case dogStates.GoDrink:
        break

      case dogStates.Drinking:
        break

      //         const move = MoveTransform.getMutable(entity)
      //         const transform = Transform.getMutable(entity)

      //         move.normalizedTime = Math.min(Math.max(move.normalizedTime + dt * move.speed, 0), 1)
      //         move.lerpTime = Interpolate(move.interpolationType, move.normalizedTime)

      //         // assign value to transform
      //         transform.position = Vector3.lerp(move.start, move.end, move.lerpTime)

      //         // has finished
      //         move.hasFinished = move.normalizedTime >= 1

      //         if (move.hasFinished) {
      //                 changeState(entity, dogStates.TURNING)
      //         }
      // break
      // case dogStates.TURNING:

      //         const timer = TimeOut.getMutable(entity)

      //         timer.timeLeft = timer.timeLeft - dt

      //         // has finished
      //         timer.hasFinished = timer.timeLeft >= 0

      //         if (timer.hasFinished) {
      //                 changeState(entity, dogStates.WALKING)
      //         }
      // break
    }
  }
}

export function changeState(entity: Entity, newState: dogStates) {
  const npcDataMutable = CustomComponents.NPC.getMutable(entity)

  leaveState(entity, npcDataMutable.state)
  npcDataMutable.previousState = npcDataMutable.state
  npcDataMutable.state = newState

  enterState(entity, npcDataMutable.state)
}

// export function previousState(entity:Entity){

//         const npcDataMutable = NPC.getMutable(entity)

//         leaveState(entity, npcDataMutable.state)
//         npcDataMutable.state = npcDataMutable.previousState

//         enterState(entity, npcDataMutable.state)

// }

export function enterState(entity: Entity, newState: dogStates) {
  switch (newState) {
    case dogStates.Idle:
      const IdleAnim = Animator.getClipOrNull(entity, 'Idle')
      if (IdleAnim) IdleAnim.playing = true
      break

    case dogStates.Sit:
      const SitAnim = Animator.getClipOrNull(entity, 'Sitting')
      if (SitAnim) SitAnim.playing = true
      const MutablePointerEvent = PointerHoverFeedback.getMutable(entity).pointerEvents[0]
      if (MutablePointerEvent.eventInfo) {
        MutablePointerEvent.eventInfo.hoverText = 'Stand'
      }

      break

    case dogStates.Follow:
      const walkAnim = Animator.getClipOrNull(entity, 'Walking')
      if (walkAnim) walkAnim.playing = true
      break

    case dogStates.GoDrink:
      const walkAnim2 = Animator.getClipOrNull(entity, 'Walking')
      if (walkAnim2) walkAnim2.playing = true
      break

    case dogStates.Drinking:
      const drinkAnim = Animator.getClipOrNull(entity, 'Drinking')
      if (drinkAnim) drinkAnim.playing = true
      break

    //                 case dogStates.WALKING:
    //                         const walkAnim = animator.states.find( (anim) =>{return anim.name==""walk""})
    //                         if(!walkAnim) return
    //                         walkAnim.playing = true

    //                         const move = MoveTransform.getFrom(entity)
    //                         if(move.hasFinished){
    //                                 nextSegment(entity)
    //                         }
    //                         break
    //                 case dogStates.TURNING:
    //                         const turnAnim = animator.states.find( (anim) =>{return anim.name==""turnRight""})
    //                         if(!turnAnim) return
    //                         turnAnim.playing = true

    //                         const timer = TimeOut.getMutable(entity)
    //                         if(timer.hasFinished){
    //                                 timer.timeLeft = 0.9
    //                                 timer.hasFinished = false
    //                         }

    //                         break
    //                 case dogStates.YELLING:
    //                         const raiseDeadAnim = animator.states.find( (anim) =>{return anim.name==""raiseDead""})
    //                         if(!raiseDeadAnim) return
    //                         raiseDeadAnim.playing = true
    //                         break
  }
}

export function leaveState(entity: Entity, oldState: dogStates) {
  switch (oldState) {
    case dogStates.Idle:
      const IdleAnim = Animator.getClipOrNull(entity, 'Idle')
      if (IdleAnim) IdleAnim.playing = false
      break

    case dogStates.Sit:
      const SitAnim = Animator.getClipOrNull(entity, 'Sitting')
      if (SitAnim) SitAnim.playing = false

      const MutablePointerEvent = PointerHoverFeedback.getMutable(entity).pointerEvents[0]
      if (MutablePointerEvent.eventInfo) {
        MutablePointerEvent.eventInfo.hoverText = 'Sit'
      }
      break

    case dogStates.Follow:
      const walkAnim = Animator.getClipOrNull(entity, 'Walking')
      if (walkAnim) walkAnim.playing = false
      break

    case dogStates.GoDrink:
      const walkAnim2 = Animator.getClipOrNull(entity, 'Walking')
      if (walkAnim2) walkAnim2.playing = false
      break

    case dogStates.Drinking:
      const drinkAnim = Animator.getClipOrNull(entity, 'Drinking')
      if (drinkAnim) drinkAnim.playing = false
      break

    //                 case dogStates.WALKING:
    //                         const walkAnim = animator.states.find( (anim) =>{return anim.name==""walk""})
    //                         if(!walkAnim) return
    //                         walkAnim.playing = false

    //                         break
    //                 case dogStates.TURNING:
    //                         const turnAnim = animator.states.find( (anim) =>{return anim.name==""turnRight""})
    //                         if(!turnAnim) return
    //                         turnAnim.playing = false

    //                         break
    //                 case dogStates.YELLING:
    //                         const raiseDeadAnim = animator.states.find( (anim) =>{return anim.name==""raiseDead""})
    //                         if(!raiseDeadAnim) return
    //                         raiseDeadAnim.playing = false
    //                         break
  }
}

export function turn(entity: Entity, target: Vector3) {
  const transform = Transform.getMutable(entity)
  const difference = Vector3.subtract(transform.position, target)
  const normalizedDifference = Vector3.normalize(difference)

  Transform.getMutable(entity).rotation = Quaternion.lookRotation(normalizedDifference)
}

// check if the target is inside the scene's bounds
export function isInBounds(position: Vector3): boolean {
  return position.x > 0.5 && position.x < 9.5 && position.z > 0.5 && position.z < 9.5
}"
/* handle clicks */,"import { engine, PointerHoverFeedback, InputAction, PointerEventType, inputSystem } from '@dcl/sdk/ecs'
import { CustomComponents, dogStates } from '../components'
import { changeState } from './dogAI'

export function handleClicks() {
  const clickedEntities = engine.getEntitiesWith(PointerHoverFeedback)
  for (const [entity] of clickedEntities) {
    if (inputSystem.isTriggered(InputAction.IA_PRIMARY, PointerEventType.PET_DOWN, entity)) {
      if (CustomComponents.NPC.has(entity)) {
        const currentState = CustomComponents.NPC.getMutable(entity)
        if (currentState.state === dogStates.Sit) {
          changeState(entity, dogStates.Idle)
        } else {
          changeState(entity, dogStates.Sit)
        }
      }
    }
  }
}

engine.addSystem(handleClicks)"
/* gltf */,"import { engine, Entity, GltfContainer, Transform } from ""@dcl/sdk/ecs"";

export function createGLTF(
  transform: {
    position: { x: number; y: number; z: number }
    scale: { x: number; y: number; z: number }
    rotation: { x: number; y: number; z: number; w: number }
  },
  model: string
): Entity {
  const gltf = engine.addEntity()

  Transform.create(gltf, transform)

  GltfContainer.create(gltf, {
    src: model
  })

  return gltf
}"
/* factory */,"import {
  Entity,
  engine,
  Transform,
  GltfContainer,
  Animator
} from '@dcl/sdk/ecs'
import { Vector3, Quaternion } from '@dcl/sdk/math'


export function createBlob(pos:Vector3, rot:Vector3, spawner = true): Entity {
  const meshEntity = engine.addEntity()
  Transform.create(meshEntity, { position: pos, rotation: Quaternion.fromLookAt(Vector3.Zero(), rot) }) 

  GltfContainer.create(meshEntity, { 
    src: ""models/blob.glb""  
  })

  Animator.create(meshEntity, {
    states:[{
        name: ""in"",
        clip: ""in"",
        playing: true,
        loop: false
      }
    ]
  })

  return meshEntity
}"
/* pirateshower system */,"import {
  engine,
  MeshRenderer,
  Transform,
  PointerHoverFeedback,
  InputAction,
  PointerEventType,
  Schemas,
  inputSystem
} from '@dcl/sdk/ecs'
import { Quaternion, Vector3 } from '@dcl/sdk/math'
import { createCube } from './factory'

/**
 * BounceScaling is the flag-component with the time elapsed since creation.
 */
const BounceScalingComponentID = 2000
export const BounceScaling = engine.defineComponent({ t: Schemas.Number }, BounceScalingComponentID)

/**
 * All cubes rotating behavior
 */
export function circularSystem(dt: number) {
  const entitiesWithMeshRenderer = engine.getEntitiesWith(MeshRenderer, Transform)
  for (const [entity, _meshRenderer, _transform] of entitiesWithMeshRenderer) {
    const mutableTransform = Transform.getMutable(entity)

    mutableTransform.rotation = Quaternion.multiply(
      mutableTransform.rotation,
      Quaternion.fromAngleAxis(dt * 10, Vector3.Up())
    )
  }
}

/**
 * The spawner system is listening for entities with hover feedback, when a input is emitted
 * just spawn a new cube randomly and animate the spawner with a bounce.
 */
export function spawnerSystem() {
  const clickedCubes = engine.getEntitiesWith(PointerHoverFeedback)
  for (const [entity] of clickedCubes) {
    if (inputSystem.isTriggered(InputAction.IA_PRIMARY, PointerEventType.PET_DOWN, entity)) {
      createCube(1 + Math.random() * 8, Math.random() * 8, 1 + Math.random() * 8, false)
      BounceScaling.createOrReplace(entity)
    }
  }
}

/**
 * Add this system and every entity with BounceScaling will bounce for 5 seconds
 * @param dt - detal time in seconds
 */
export function bounceScalingSystem(dt: number) {
  const clickedCubes = engine.getEntitiesWith(BounceScaling, Transform)
  for (const [entity] of clickedCubes) {
    const m = BounceScaling.getMutable(entity)
    m.t += dt

    if (m.t > 5) {
      Transform.getMutable(entity).scale = Vector3.One()
      BounceScaling.deleteFrom(entity)
    } else {
      const factor = 0.9 + 0.2 * Math.exp(-1.5 * m.t) * Math.sin(10 * m.t)
      Transform.getMutable(entity).scale = Vector3.scale(Vector3.One(), factor)
    }
  }
}"
/* ui */,"import {
    engine, Transform, YGAlign,
    YGDisplay,
    YGJustify
} from '@dcl/sdk/ecs'
import { Color4 } from '@dcl/sdk/math'
import ReactEcs, { ReactEcsRenderer, UiEntity } from '@dcl/sdk/react-ecs'

const uiComponent = () => (
    <UiEntity
        uiTransform={{
            width: 300,
            margin: { top: '70px', left: '245px' },
            padding: { top: 10, bottom: 10, left: 10, right: 10 }
        }}
        uiBackground={{ backgroundColor: Color4.create(0.5, 0.8, 0.1, 0.6) }}
    >
        <UiEntity
            uiTransform={
                {
                    width: '100%',
                    justifyContent: YGJustify.YGJ_CENTER,
                    alignItems: YGAlign.YGA_CENTER,
                    display: YGDisplay.YGD_FLEX
                }
            }
        >
            <UiEntity
                uiText={{ value: 'SDK 7', fontSize: 32 }}
                uiBackground={{ backgroundColor: Color4.fromHexString('#fbf0f0') }}
            />
        </UiEntity>
        <UiEntity
            uiTransform={{
                width: '100%',
                justifyContent: YGJustify.YGJ_CENTER,
                alignItems: YGAlign.YGA_CENTER,
                display: YGDisplay.YGD_FLEX
            }}
        >
            <UiEntity
                uiText={{ value: `Player: ${getPlayerPosition()}`, fontSize: 18 }}
                uiBackground={{ backgroundColor: Color4.fromHexString('#fbf0f0') }}
            />
        </UiEntity>
    </UiEntity>
)

function getPlayerPosition() {
    const playerPosition = Transform.getOrNull(engine.PlayerEntity)
    if (!playerPosition) return ' no data yet'
    const { x, y, z } = playerPosition.position
    return `{X: ${x.toFixed(2)}, Y: ${y.toFixed(2)}, z: ${z.toFixed(2)} }`
}

export function setupUi() {
    ReactEcsRenderer.setUiRenderer(uiComponent)
}"
/* atari arcade game */,"import * as utils from ""@dcl/ecs-scene-utils""
import { Arcade } from ""./gameObjects/arcade""
import { loadPlayer, unloadPlayer } from ""./player""
import { loadAtariLevel, loadAtariBricks, unloadAtariBricks } from ""./gameLogic/atariLevel""
import { loadBitcoinLevel, loadBitcoinBricks, unloadBitcoinBricks } from ""./gameLogic/bitcoinLevel""
import { loadEthereumLevel, loadEthereumBricks, unloadEthereumBricks } from ""./gameLogic/ethereumLevel""
import { loadDecentralandLevel, loadDecentralandBricks, unloadDecentralandBricks } from ""./gameLogic/decentralandLevel""
import { GameManager } from ""./gameManager""

// Base
const base = new Entity()
base.addComponent(new GLTFShape(""models/baseLight.glb""))
base.addComponent(new Transform({ scale: new Vector3(2, 1, 2) }))
engine.addEntity(base)

// Atari arcade cabinet
const arcadeCabinetAtari = new Arcade(new GLTFShape(""models/arcadeCabinetAtari.glb""), new Transform({ position: new Vector3(16, 0.01, 16) }))

// Breakout atari
const atariGameTransform = new Entity()
atariGameTransform.addComponent(new Transform({ position: new Vector3(-0.48, 1.38, -0.155) }))
atariGameTransform.getComponent(Transform).scale.setAll(0.03)
atariGameTransform.getComponent(Transform).rotate(Vector3.Left(), 75)
atariGameTransform.setParent(arcadeCabinetAtari)
let arcadeCabinetAtariTrigger = new utils.TriggerBoxShape(new Vector3(4, 4, 4), new Vector3(0, 2, -2))
loadAtariLevel(atariGameTransform)

arcadeCabinetAtari.addComponent(
  new utils.TriggerComponent(arcadeCabinetAtariTrigger, {
    onCameraEnter: () => {
      if (!GameManager.hasGameLoaded) {
        loadAtariBricks(atariGameTransform)
        loadPlayer(atariGameTransform, arcadeCabinetAtari)
      }
    },
    onCameraExit: () => {
      if (GameManager.hasGameLoaded) {
        unloadAtariBricks()
        unloadPlayer()
      }
    },
    enableDebug: false,
  })
)

// Bitcoin arcade cabinet
const arcadeCabinetBitcoin = new Arcade(new GLTFShape(""models/arcadeCabinetBitcoin.glb""), new Transform({ position: new Vector3(18, 0.01, 18) }))
arcadeCabinetBitcoin.getComponent(Transform).rotate(Vector3.Up(), -90)

// Breakout bitcoin
const bitcoinGameTransform = new Entity()
bitcoinGameTransform.addComponent(new Transform({ position: new Vector3(-0.48, 1.38, -0.155) }))
bitcoinGameTransform.getComponent(Transform).scale.setAll(0.03)
bitcoinGameTransform.getComponent(Transform).rotate(Vector3.Left(), 75)
bitcoinGameTransform.setParent(arcadeCabinetBitcoin)
let arcadeCabinetBitcoinTrigger = new utils.TriggerBoxShape(new Vector3(4, 4, 4), new Vector3(2, 2, 0))
loadBitcoinLevel(bitcoinGameTransform)

arcadeCabinetBitcoin.addComponent(
  new utils.TriggerComponent(arcadeCabinetBitcoinTrigger, {
    onCameraEnter: () => {
      if (!GameManager.hasGameLoaded) {
        loadBitcoinBricks(bitcoinGameTransform)
        loadPlayer(bitcoinGameTransform, arcadeCabinetBitcoin)
      }
    },
    onCameraExit: () => {
      if (GameManager.hasGameLoaded) {
        unloadBitcoinBricks()
        unloadPlayer()
      }
    },
    enableDebug: false,
  })
)

// Ethereum arcade cabinet
const arcadeCabinetEthereum = new Arcade(new GLTFShape(""models/arcadeCabinetEthereum.glb""), new Transform({ position: new Vector3(16, 0.01, 20) }))
arcadeCabinetEthereum.getComponent(Transform).rotate(Vector3.Up(), 180)

// Breakout ethereum
const ethereumGameTransform = new Entity()
ethereumGameTransform.addComponent(new Transform({ position: new Vector3(-0.48, 1.38, -0.155) }))
ethereumGameTransform.getComponent(Transform).scale.setAll(0.03)
ethereumGameTransform.getComponent(Transform).rotate(Vector3.Left(), 75)
ethereumGameTransform.setParent(arcadeCabinetEthereum)
let arcadeCabinetEthereumTrigger = new utils.TriggerBoxShape(new Vector3(4, 4, 4), new Vector3(0, 2, 2))
loadEthereumLevel(ethereumGameTransform)

arcadeCabinetEthereum.addComponent(
  new utils.TriggerComponent(arcadeCabinetEthereumTrigger, {
    onCameraEnter: () => {
      if (!GameManager.hasGameLoaded) {
        loadEthereumBricks(ethereumGameTransform)
        loadPlayer(ethereumGameTransform, arcadeCabinetEthereum)
      }
    },
    onCameraExit: () => {
      if (GameManager.hasGameLoaded) {
        unloadEthereumBricks()
        unloadPlayer()
      }
    },
    enableDebug: false,
  })
)

// Decentraland arcade cabinet
const arcadeCabinetDecentraland = new Arcade(new GLTFShape(""models/arcadeCabinetDecentraland.glb""), new Transform({ position: new Vector3(14, 0.01, 18) }))
arcadeCabinetDecentraland.getComponent(Transform).rotate(Vector3.Up(), 90)

// Breakout decentraland
const decentralandGameTransform = new Entity()
decentralandGameTransform.addComponent(new Transform({ position: new Vector3(-0.48, 1.38, -0.155) }))
decentralandGameTransform.getComponent(Transform).scale.setAll(0.03)
decentralandGameTransform.getComponent(Transform).rotate(Vector3.Left(), 75)
decentralandGameTransform.setParent(arcadeCabinetDecentraland)
let arcadeCabinetDecentralandTrigger = new utils.TriggerBoxShape(new Vector3(4, 4, 4), new Vector3(-2, 2, 0))
loadDecentralandLevel(decentralandGameTransform)

arcadeCabinetDecentraland.addComponent(
  new utils.TriggerComponent(arcadeCabinetDecentralandTrigger, {
    onCameraEnter: () => {
      if (!GameManager.hasGameLoaded) {
        loadDecentralandBricks(decentralandGameTransform)
        loadPlayer(decentralandGameTransform, arcadeCabinetDecentraland)
      }
    },
    onCameraExit: () => {
      if (GameManager.hasGameLoaded) {
        unloadDecentralandBricks()
        unloadPlayer()
      }
    },
    enableDebug: false,
  })
)"
/* atari arcade player */,"import { Paddle } from ""./gameObjects/paddle""
import { Ball } from ""./gameObjects/ball""
import { GameManager } from ""./gameManager""
import { Arcade } from ""./gameObjects/arcade""

// Intermediate variables
const input = Input.instance
let buttonSystem: ISystem
let paddle: Paddle
let activeParent: Entity

// To store player elements to load and unload
const playerElements: Entity[] = []

export function loadPlayer(parent: Entity, arcade: Arcade): void {
  activeParent = parent

  // Game has loaded
  GameManager.hasGameLoaded = true

  // Paddle
  paddle = new Paddle(
    new Transform({ position: new Vector3(16, GameManager.PLANE_HEIGHT, 4), scale: new Vector3(2, 0.01, 1) }),
    Color3.FromInts(127, 127, 255),
    activeParent
  )
  playerElements.push(paddle)

  // Fire a ball
  input.subscribe(""BUTTON_DOWN"", ActionButton.POINTER, false, () => {
    if (GameManager.hasGameLoaded && !GameManager.isBallAlive) {
      GameManager.isBallAlive = true
      let forwardVector = Vector3.Forward()
      forwardVector.y = 0 // Ignore y-axis
      shoot(Vector3.Normalize(forwardVector))
    }
  })

  // E Key
  input.subscribe(""BUTTON_DOWN"", ActionButton.PRIMARY, false, () => {
    GameManager.isEKeyPressed = true
  })
  input.subscribe(""BUTTON_UP"", ActionButton.PRIMARY, false, () => {
    GameManager.isEKeyPressed = false
  })

  // F Key
  input.subscribe(""BUTTON_DOWN"", ActionButton.SECONDARY, false, () => {
    GameManager.isFKeyPressed = true
  })
  input.subscribe(""BUTTON_UP"", ActionButton.SECONDARY, false, () => {
    GameManager.isFKeyPressed = false
  })

  // Calculate paddle position above all else
  class ButtonChecker {
    update(dt: number) {
      let transform = paddle.getComponent(Transform)
      let increment = Vector3.Right().scale(dt * GameManager.PADDLE_SPEED)

      if (!GameManager.isEKeyPressed && !GameManager.isFKeyPressed) arcade.controlStop()

      if (GameManager.isEKeyPressed && transform.position.x >= GameManager.NEG_X_LIMIT) {
        transform.translate(increment.multiplyByFloats(-1, -1, -1))
        arcade.controlLeft()
      }
      if (GameManager.isFKeyPressed && transform.position.x <= GameManager.POS_X_LIMIT) {
        transform.translate(increment)
        arcade.controlRight()
      }
    }
  }

  buttonSystem = engine.addSystem(new ButtonChecker(), 0)

  function shoot(direction: Vector3): void {
    let paddlePosition = paddle.getComponent(Transform).position
    let spawnPosition = new Vector3(paddlePosition.x, GameManager.PLANE_HEIGHT, paddlePosition.z + 1)
    const ball = new Ball(new Transform({ position: spawnPosition, scale: new Vector3(0.3, 0.1, 0.4) }), direction, activeParent)
    playerElements.push(ball)
  }
}

export function unloadPlayer() {
  while (playerElements.length) {
    let playerElement = playerElements.pop()
    engine.removeEntity(playerElement)
  }
  GameManager.hasGameLoaded = false
  GameManager.isBallAlive = false
  engine.removeSystem(buttonSystem)
}"
/* atari arcade game manager */ ,"export class GameManager {
  static hasGameLoaded = false
  static isEKeyPressed = false
  static isFKeyPressed = false
  static isBallAlive = false
  static PLANE_HEIGHT = 1
  static BALL_SPEED = 16
  static PADDLE_SPEED = 16
  static POS_X_LIMIT = 26.5
  static NEG_X_LIMIT = 5.5
  static OUT_OF_BOUNDS = 1.5
}"
/* atari arcade arcade */,"import * as utils from ""@dcl/ecs-scene-utils""

export class Arcade extends Entity {
  public knob: Entity = new Entity()
  constructor(model: GLTFShape, transform: Transform) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(transform)

    this.knob.addComponent(new GLTFShape(""models/knob.glb""))
    this.knob.addComponent(new Transform({ position: new Vector3(0, 1.383, -0.397) }))
    this.knob.getComponent(Transform).rotate(Vector3.Left(), 11.6)
    this.knob.setParent(this)
  }
  controlStop() {
    if (this.knob.hasComponent(utils.KeepRotatingComponent)) this.knob.removeComponent(utils.KeepRotatingComponent)
  }
  controlLeft() {
    this.knob.addComponentOrReplace(new utils.KeepRotatingComponent(Quaternion.Euler(0, -90, 0)))
  }
  controlRight() {
    this.knob.addComponentOrReplace(new utils.KeepRotatingComponent(Quaternion.Euler(0, 90, 0)))
  }
}"
/* atari ball */,"@Component(""ballFlag"")
export class BallFlag {}

export class Ball extends Entity {
  public direction: Vector3
  constructor(transform: Transform, direction: Vector3, parent: Entity) {
    super()
    engine.addEntity(this)
    this.setParent(parent)
    this.addComponent(transform)
    this.addComponent(new BallFlag())
    this.addComponent(new BoxShape())
    this.getComponent(BoxShape).withCollisions = false
    this.direction = direction
  }
}"
/* atari bricks */,"import { CollisionFlag } from ""../gameLogic/collision""

@Component(""brickFlag"")
export class BrickFlag {}

export class Brick extends Entity {
  constructor(transform: Transform, color: Color3, parent: Entity) {
    super()
    engine.addEntity(this)
    this.addComponent(transform)
    this.addComponent(new BrickFlag())
    this.addComponent(new CollisionFlag())
    this.addComponent(new BoxShape())
    this.addComponent(new Material())
    this.getComponent(Material).albedoColor = color
    this.getComponent(Material).emissiveColor = color
    this.getComponent(Material).emissiveIntensity = 0.95
    this.setParent(parent)
  }
}"
/* atari background */,"const background = new Entity()
export class Background extends Entity {
  constructor(transform: Transform, parent: Entity) {
    super()
    this.addComponent(transform)
    this.addComponent(new BoxShape())
    this.addComponent(new Material())
    this.getComponent(Material).albedoColor = Color3.Black()
    this.getComponent(Material).roughness = 0.9
    this.setParent(parent)
  }
}"
/* atari paddle */,"import { CollisionFlag } from ""../gameLogic/collision""

@Component(""paddleFlag"")
export class PaddleFlag {}

export class Paddle extends Entity {
  constructor(transform: Transform, color: Color3, parent: Entity) {
    super()
    engine.addEntity(this)
    this.addComponent(transform)
    this.addComponent(new PaddleFlag())
    this.addComponent(new CollisionFlag())
    this.addComponent(new BoxShape())
    this.addComponent(new Material())
    this.getComponent(Material).albedoColor = color
    this.setParent(parent)
  }
}"
/* atari sound */,"export class Sound extends Entity {
  constructor(audio: AudioClip, loop: boolean = false, transform?: Vector3) {
    super()
    engine.addEntity(this)
    this.addComponent(new AudioSource(audio))
    this.getComponent(AudioSource).loop = loop
    this.addComponent(new Transform())
    if (transform) {
      this.getComponent(Transform).position = transform
    } else {
      this.getComponent(Transform).position = Camera.instance.position
    }
  }

  playAudioOnceAtPos(transform: Vector3): void {
    this.getComponent(Transform).position = transform
    this.getComponent(AudioSource).playOnce()
  }

  playAudioAtPos(transform: Vector3): void {
    this.getComponent(Transform).position = transform
    this.getComponent(AudioSource).playing = true
  }
}"
/* atari wall */,"import { CollisionFlag } from ""../gameLogic/collision""

@Component(""wallFlag"")
export class WallFlag {}

export class Wall extends Entity {
  public normal: Vector3
  constructor(transform: Transform, normal: Vector3, color: Color3, parent: Entity) {
    super()
    engine.addEntity(this)
    this.addComponent(transform)
    this.addComponent(new WallFlag())
    this.addComponent(new CollisionFlag())
    this.addComponent(new BoxShape())
    this.addComponent(new Material())
    this.normal = normal
    this.getComponent(Material).albedoColor = color
    this.setParent(parent)
  }
}"
/* atari level */ ,"import { Brick } from ""../gameObjects/brick""
import { Wall } from ""../gameObjects/wall""
import { Background } from ""../gameObjects/background""
import { GameManager } from ""../gameManager""

// Ready player one
const readyPlayerOne = new Entity()
readyPlayerOne.addComponent(new GLTFShape(""models/readyPlayerOne.glb""))
readyPlayerOne.addComponent(new Transform({ position: new Vector3(16, 1, 16) }))

// Brick
const colorRed = Color3.FromInts(255, 127, 0)
const colorGreen = Color3.FromInts(127, 255, 127)
const gameElements: Entity[] = []

// Load level
export function loadAtariLevel(parent: Entity): void {
  readyPlayerOne.setParent(parent)

  // Wall
  const wallLeft = new Wall(
    new Transform({ position: new Vector3(3.5, GameManager.PLANE_HEIGHT + 0.1, 16), scale: new Vector3(2, 0.1, 32) }),
    new Vector3(1, 0, 0),
    Color3.White(),
    parent
  )
  const wallTop = new Wall(
    new Transform({ position: new Vector3(16, GameManager.PLANE_HEIGHT + 0.1, 31.5), scale: new Vector3(27, 0.1, 2) }),
    new Vector3(0, 0, -1),
    Color3.White(),
    parent
  )
  const wallRight = new Wall(
    new Transform({ position: new Vector3(28.5, GameManager.PLANE_HEIGHT + 0.1, 16), scale: new Vector3(2, 0.1, 32) }),
    new Vector3(-1, 0, 0),
    Color3.White(),
    parent
  )

  // Background
  const background = new Background(new Transform({ position: new Vector3(16, GameManager.PLANE_HEIGHT - 0.1, 16), scale: new Vector3(26, 0.01, 32) }), parent)
}

export function loadAtariBricks(parent: Entity): void {
  readyPlayerOne.getComponent(GLTFShape).visible = false

  // Red bricks
  let brickPosX = 6
  let redBrickPosZ = 24
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 9; j++) {
      const brick = new Brick(
        new Transform({ position: new Vector3(brickPosX, GameManager.PLANE_HEIGHT, redBrickPosZ), scale: new Vector3(2, 0.1, 1) }),
        colorRed,
        parent
      )
      brickPosX += 2.5
      gameElements.push(brick)
    }
    redBrickPosZ -= 1.5
    brickPosX = 6
  }

  // Green bricks
  let greenBrickPosZ = 19.5
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 9; j++) {
      const brick = new Brick(
        new Transform({ position: new Vector3(brickPosX, GameManager.PLANE_HEIGHT, greenBrickPosZ), scale: new Vector3(2, 0.1, 1) }),
        colorGreen,
        parent
      )
      brickPosX += 2.5
      gameElements.push(brick)
    }
    greenBrickPosZ -= 1.5
    brickPosX = 6
  }
}

export function unloadAtariBricks(): void {
  readyPlayerOne.getComponent(GLTFShape).visible = true
  while (gameElements.length) {
    let gameElement = gameElements.pop()
    engine.removeEntity(gameElement)
  }
}"
/* atari ballTranslator */,"import { Ball, BallFlag } from ""../gameObjects/ball""
import { Sound } from ""../gameObjects/sound""
import { GameManager } from ""../gameManager""

// Sound
const missSound = new Sound(new AudioClip(""sounds/miss.mp3""))

// Translate ball based on its direction property
class BallTranslatorSystem {
  private ballGroup = engine.getComponentGroup(BallFlag)

  update(dt: number) {
    for (let entity of this.ballGroup.entities as Ball[]) {
      let transform = entity.getComponent(Transform)
      let increment = entity.direction.scale(dt * GameManager.BALL_SPEED)
      transform.translate(increment)
      if (transform.position.z <= GameManager.OUT_OF_BOUNDS) {
        GameManager.isBallAlive = false
        missSound.getComponent(AudioSource).playOnce()
        engine.removeEntity(entity)
      }
      if (transform.position.x < 0 || transform.position.x > 32 || transform.position.z < 0 || transform.position.z > 32) {
        GameManager.isBallAlive = false
        engine.removeEntity(entity)
      }
    }
  }
}

engine.addSystem(new BallTranslatorSystem(), 1)"
/* atari collision */,"import { Ball, BallFlag } from ""../gameObjects/ball""
import { BrickFlag } from ""../gameObjects/brick""
import { PaddleFlag } from ""../gameObjects/paddle""
import { Sound } from ""../gameObjects/sound""
import { Wall, WallFlag } from ""../gameObjects/wall""
import * as utils from ""@dcl/ecs-scene-utils""

@Component(""collisionFlag"")
export class CollisionFlag {}

const hitSound = new Sound(new AudioClip(""sounds/hit.mp3""))

// 2D collision detection
class CollisionDetection {
  private ballGroup = engine.getComponentGroup(BallFlag)
  private collisionGroup = engine.getComponentGroup(CollisionFlag)
  update(dt: number) {
    for (let ballEntity of this.ballGroup.entities as Ball[]) {
      for (let hitEntity of this.collisionGroup.entities as Wall[]) {
        let ballPos = ballEntity.getComponent(Transform).position
        let brickPos = hitEntity.getComponent(Transform).position
        let ballSize = ballEntity.getComponent(Transform).scale
        let brickSize = hitEntity.getComponent(Transform).scale
        let ballPosX = ballPos.x - ballSize.x / 2
        let ballPosZ = ballPos.z + ballSize.z / 2
        let brickPosX = brickPos.x - brickSize.x / 2
        let brickPosZ = brickPos.z + brickSize.z / 2
        let collisionNorm: Vector3

        if (
          ballPosX + ballSize.x >= brickPosX &&
          ballPosX <= brickPosX + brickSize.x &&
          ballPosZ - ballSize.z <= brickPosZ &&
          ballPosZ >= brickPosZ - brickSize.z
        ) {
          hitSound.getComponent(AudioSource).playOnce()

          // HACK: Temporary disable collisions on entity that's already been hit
          hitEntity.removeComponent(CollisionFlag)
          hitEntity.addComponentOrReplace(
            new utils.Delay(100, () => {
              hitEntity.addComponent(new CollisionFlag())
            })
          )

          let isPaddle = hitEntity.hasComponent(PaddleFlag)
          let isWall = hitEntity.hasComponent(WallFlag)
          isWall ? (collisionNorm = hitEntity.normal) : (collisionNorm = collisionNormal(ballEntity, hitEntity))
          ballEntity.direction = reflectVector(ballEntity.direction, collisionNorm, isPaddle, isWall)

          // If it's a brick then remove it
          if (hitEntity.hasComponent(BrickFlag) && !hitEntity.hasComponent(utils.ExpireIn)) {
            hitEntity.addComponent(new utils.ExpireIn(100))
          }
        }
      }
    }
  }
}
engine.addSystem(new CollisionDetection())

function reflectVector(incident: Vector3, normal: Vector3, isPaddle: boolean, isWall: boolean): Vector3 {
  let dot = 2 * Vector3.Dot(incident, normal)
  let reflected = incident.subtract(normal.multiplyByFloats(dot, dot, dot))

  // HACKS: Collision issues
  if (isWall) {
    if (normal.x == 1 && reflected.x < 0) reflected.x *= -1
    if (normal.x == -1 && reflected.x > 0) reflected.x *= -1
    if (normal.z == 1 && reflected.z < 0) reflected.z *= -1
    if (normal.z == -1 && reflected.z > 0) reflected.z *= -1
  }
  if (isPaddle && reflected.z <= 0) reflected.z *= -1

  // Remove shallow angles to prevent stale gameplay
  if (reflected.z >= 0 && reflected.z <= 0.25) reflected.z = 0.35
  if (reflected.z <= 0 && reflected.z >= -0.25) reflected.z = -0.35

  return Vector3.Normalize(reflected)
}

function collisionNormal(ballEntity: Ball, hitEntity: IEntity): Vector3 {
  let ballPosition = ballEntity.getComponent(Transform).position
  let hitEntityPosition = hitEntity.getComponent(Transform).position
  let hitEntityWidth = hitEntity.getComponent(Transform).scale.x
  let delta = ballPosition.subtract(hitEntityPosition)
  let normal = new Vector3(0, 0, 1)

  // If the ball hits a paddle
  if (hitEntity.hasComponent(PaddleFlag)) {
    // Paddle normal logic
    normal.x = delta.x / 2

    // If ball hits the side of the paddle
    if (delta.x <= -hitEntityWidth / 2 || delta.x >= hitEntityWidth / 2) normal.set(1, 0, 0)

    // Corner cases
    if (delta.x <= -hitEntityWidth / 2 && ballEntity.direction.x < 0) normal.set(-1, 0, 1)
    if (delta.x >= hitEntityWidth / 2 && ballEntity.direction.x > 0) normal.set(1, 0, 1)

    return Vector3.Normalize(normal) // Normalize the vector first to maintain constant ball speed
  } else {
    if (delta.x <= -hitEntityWidth / 2 || delta.x >= hitEntityWidth / 2) normal.set(1, 0, 0)

    // Corner cases
    if (delta.x <= -hitEntityWidth / 2 && ballEntity.direction.x < 0) normal.set(0, 0, 1)
    if (delta.x >= hitEntityWidth / 2 && ballEntity.direction.x > 0) normal.set(0, 0, 1)
  }
  return Vector3.Normalize(normal)
}"
/* coconut mesh data */,https://github.com/decentraland-scenes/coconut-shy/blob/main/src/modules/meshData/coconutShyMesh.ts
/* coconut shy ball */,"import { Sound } from ""./sound""
import { HighlightFlag } from ""./highlighter""

const hitSound01 = new Sound(new AudioClip(""sounds/hit01.mp3""), false)
const hitSound02 = new Sound(new AudioClip(""sounds/hit02.mp3""), false)
const hitSound03 = new Sound(new AudioClip(""sounds/hit03.mp3""), false)
const hitSounds: Sound[] = [hitSound01, hitSound02, hitSound03]

const pickUpSound = new Sound(new AudioClip(""sounds/pickUp.mp3""), false)
const throwSound = new Sound(new AudioClip(""sounds/throw.mp3""), false)

const THROW_STRENGTH_MULTIPLIER = 0.125

export class Ball extends Entity {
  public isActive: boolean = false
  public isThrown: boolean = true
  public body: CANNON.Body
  public world: CANNON.World
  public glowEntity = new Entity()

  constructor(transform: Transform, cannonMaterial: CANNON.Material, cannonWorld: CANNON.World) {
    super()
    engine.addEntity(this)
    this.addComponent(new GLTFShape(""models/ball.glb""))
    this.addComponent(transform)
    this.world = cannonWorld
    this.toggleOnPointerDown(true)

    // Setup glow
    this.addComponent(new HighlightFlag())
    this.glowEntity.addComponent(new GLTFShape(""models/ballGlow.glb""))
    this.glowEntity.addComponent(new Transform())
    this.glowEntity.getComponent(Transform).scale.setAll(0)
    this.glowEntity.setParent(this)

    // Create physics body for ball
    this.body = new CANNON.Body({
      mass: 1, // kg
      position: new CANNON.Vec3(transform.position.x, transform.position.y, transform.position.z), // m
      shape: new CANNON.Sphere(0.12), // Create sphere shaped body with a diameter of 0.22m
    })

    // Add material and dampening to stop the ball rotating and moving continuously
    this.body.sleep()
    this.body.material = cannonMaterial
    this.body.linearDamping = 0.4
    this.body.angularDamping = 0.4
    this.world.addBody(this.body) // Add ball body to the world

    // Ball collision
    this.body.addEventListener(""collide"", () => {
      let randomTrackNo = Math.floor(Math.random() * 2)
      hitSounds[randomTrackNo].playAudioOnceAtPosition(this.getComponent(Transform).position)
    })

    this.addComponent(new Animator())
    this.getComponent(Animator).addClip(new AnimationState(""PickUp"", { looping: false }))
  }

  playerPickup(): void {
    pickUpSound.getComponent(AudioSource).playOnce()
    this.isActive = true
    this.body.sleep()
    this.isThrown = false
    this.body.position.set(Camera.instance.position.x, Camera.instance.position.y, Camera.instance.position.z)
    this.setParent(Attachable.FIRST_PERSON_CAMERA)
    this.getComponent(Transform).position.set(0, -0.2, 0.5)
    this.playPickUpAnim()
    this.toggleOnPointerDown(false)

    // FIX: Issue with highlight glow showing when it's not supposed to
    this.glowEntity.getComponent(GLTFShape).visible = false
  }

  playerThrow(throwDirection: Vector3, throwPower: number): void {
    throwSound.getComponent(AudioSource).playOnce()

    this.isActive = false
    this.isThrown = true
    this.setParent(null)
    this.toggleOnPointerDown(true)

    // Physics
    this.body.wakeUp()
    this.body.velocity.setZero()
    this.body.angularVelocity.setZero()

    this.body.position.set(
      Camera.instance.feetPosition.x + throwDirection.x,
      throwDirection.y + Camera.instance.position.y,
      Camera.instance.feetPosition.z + throwDirection.z
    )

    let throwPowerAdjusted = throwPower * THROW_STRENGTH_MULTIPLIER

    // Throw
    this.body.applyImpulse(
      new CANNON.Vec3(throwDirection.x * throwPowerAdjusted, throwDirection.y * throwPowerAdjusted, throwDirection.z * throwPowerAdjusted),
      new CANNON.Vec3(this.body.position.x, this.body.position.y, this.body.position.z)
    )
  }

  toggleOnPointerDown(isOn: boolean): void {
    if (isOn) {
      this.addComponentOrReplace(
        new OnPointerDown(
          () => {
            this.playerPickup()
          },
          { hoverText: ""Pick up"", distance: 4, button: ActionButton.PRIMARY }
        )
      )
    } else {
      if (this.hasComponent(OnPointerDown)) this.removeComponent(OnPointerDown)
    }
  }

  playPickUpAnim() {
    this.getComponent(GLTFShape).visible = true
    this.getComponent(Animator).getClip(""PickUp"").stop()
    this.getComponent(Animator).getClip(""PickUp"").play()
  }

  setGlow(isOn: boolean): void {
    isOn ? this.glowEntity.getComponent(Transform).scale.setAll(1) : this.glowEntity.getComponent(Transform).scale.setAll(0)
  }
}"
/* coconut shy coconut */,"import { Sound } from ""./sound""

const hitSound01 = new Sound(new AudioClip(""sounds/hit01.mp3""), false)
const hitSound02 = new Sound(new AudioClip(""sounds/hit02.mp3""), false)
const hitSound03 = new Sound(new AudioClip(""sounds/hit03.mp3""), false)
const hitSounds: Sound[] = [hitSound01, hitSound02, hitSound03]

export class Coconut extends Entity {
  public body: CANNON.Body
  public world: CANNON.World

  constructor(transform: Transform, cannonMaterial: CANNON.Material, cannonWorld: CANNON.World) {
    super()
    engine.addEntity(this)
    this.addComponent(new GLTFShape(""models/coconut.glb""))
    this.addComponent(transform)
    this.world = cannonWorld

    // Create physics body for coconut
    this.body = new CANNON.Body({
      mass: 1, // kg
      position: new CANNON.Vec3(transform.position.x, transform.position.y, transform.position.z), // m
      shape: new CANNON.Sphere(0.15), // Create sphere shaped body with a diameter of 0.3m
    })

    // Add material and dampening to stop the coconut rotating and moving continuously
    this.body.sleep()
    this.body.material = cannonMaterial
    this.body.linearDamping = 0.4
    this.body.angularDamping = 0.4
    this.world.addBody(this.body) // Add coconut body to the world

    // Coconut collision
    this.body.addEventListener(""collide"", (e: any) => {
      // Only play sound when impact is high enough
      let relativeVelocity = e.contact.getImpactVelocityAlongNormal()
      if (Math.abs(relativeVelocity) > 0.75) {
        let randomTrackNo = Math.floor(Math.random() * 2)
        hitSounds[randomTrackNo].playAudioOnceAtPosition(this.getComponent(Transform).position)
      }
    })
  }
}"
/* coconut shy collider setup */,"import { coconutShyMeshVertices, coconutShyMeshIndices } from ""./meshData/coconutShyMesh""

export function loadColliders(cannonWorld: CANNON.World): void {
  // Coconut shy trimesh
  let coconutShyShape = new CANNON.Trimesh(coconutShyMeshVertices, coconutShyMeshIndices)
  const coconutShyBody = new CANNON.Body({
    mass: 0,
    position: new CANNON.Vec3(16, 0, 0),
  })
  coconutShyBody.addShape(coconutShyShape)
  cannonWorld.addBody(coconutShyBody)

  // Invisible walls
  //#region
  const wallShape = new CANNON.Box(new CANNON.Vec3(8, 32, 0.5))
  const wallNorth = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(8, 0, 16.45),
  })
  cannonWorld.addBody(wallNorth)

  const wallSouth = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(8, 0, -0.45),
  })
  cannonWorld.addBody(wallSouth)

  const wallWest = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(-0.45, 0, 8),
  })
  wallWest.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2)
  cannonWorld.addBody(wallWest)

  const wallEast = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(16.45, 0, 8),
  })
  wallEast.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2)
  cannonWorld.addBody(wallEast)
  //#endregion
}"
/* coconut shy highlighter */,"import { Ball } from ""./ball""

@Component(""highlightFlag"")
export class HighlightFlag {}

let physicsCast = PhysicsCast.instance

class HighlighterSystem implements ISystem {
  highlightGroup = engine.getComponentGroup(HighlightFlag)
  update(): void {
    // Fixed ray
    const ray: Ray = {
      origin: Vector3.Zero(),
      direction: Vector3.Forward(),
      distance: 1,
    }

    PhysicsCast.instance.hitAll(ray, (e) => {
      if (!e.didHit) {
        for (let highlightEntity of this.highlightGroup.entities as Ball[]) {
          highlightEntity.setGlow(false)
        }
      }
    })

    // Ray from camera
    const rayFromCamera: Ray = PhysicsCast.instance.getRayFromCamera(4.1) // NOTE: should be 4 but raycasting calc is off slightly
    physicsCast.hitFirst(rayFromCamera, (e) => {
      if (e.entity.meshName == ""interactive_collider"") {
        let entity = engine.entities[e.entity.entityId] as Ball
        entity.setGlow(true)
      }
    })
  }
}

engine.addSystem(new HighlighterSystem())"
/* coconut shy sound */,"export class Sound extends Entity {
  constructor(audio: AudioClip, loop: boolean, transform?: Vector3) {
    super()
    engine.addEntity(this)
    this.addComponent(new AudioSource(audio))
    this.getComponent(AudioSource).loop = loop
    this.addComponent(new Transform())
    if (transform) {
      this.getComponent(Transform).position = transform
    } else {
      this.getComponent(Transform).position = Camera.instance.position
    }
  }

  playAudioOnceAtPosition(transform: Vector3): void {
    this.getComponent(Transform).position = transform
    this.getComponent(AudioSource).playOnce()
  }

  playAudioAtPosition(transform: Vector3): void {
    this.getComponent(Transform).position = transform
    this.getComponent(AudioSource).playing = true
  }
}"
/* canon d */,"// Type definitions for cannon 0.1
// Project: https://github.com/clark-stevenson/cannon.d.ts
// Definitions by: Clark Stevenson <https://github.com/clark-stevenson>
//                 Grzegorz Rozdzialik <https://github.com/Gelio>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped


declare module CANNON {

    export interface IAABBOptions {

        upperBound?: Vec3;
        lowerBound?: Vec3;

    }

    export class AABB {

        lowerBound: Vec3;
        upperBound: Vec3;

        constructor(options?: IAABBOptions);

        clone(): AABB;
        copy(aabb: AABB): void;
        extend(aabb: AABB): void;
        getCorners(a: Vec3, b: Vec3, c: Vec3, d: Vec3, e: Vec3, f: Vec3, g: Vec3, h: Vec3): void;
        overlaps(aabb: AABB): boolean;
        setFromPoints(points: Vec3[], position?: Vec3, quaternion?: Quaternion, skinSize?: number): AABB;
        toLocalFrame(frame: Transform, target: AABB): AABB;
        toWorldFrame(frame: Transform, target: AABB): AABB;

    }

    export class ArrayCollisionMatrix {

        matrix: Mat3[];

        get(i: number, j: number): number;
        set(i: number, j: number, value: number): void;
        reset(): void;
        setNumObjects(n: number): void;

    }

    export class BroadPhase {

        world: World;
        useBoundingBoxes: boolean;
        dirty: boolean;

        collisionPairs(world: World, p1: Body[], p2: Body[]): void;
        needBroadphaseCollision(bodyA: Body, bodyB: Body): boolean;
        intersectionTest(bodyA: Body, bodyB: Body, pairs1: Body[], pairs2: Body[]): void;
        doBoundingSphereBroadphase(bodyA: Body, bodyB: Body, pairs1: Body[], pairs2: Body[]): void;
        doBoundingBoxBroadphase(bodyA: Body, bodyB: Body, pairs1: Body[], pairs2: Body[]): void;
        makePairsUnique(pairs1: Body[], pairs2: Body[]): void;
        setWorld(world: World): void;
        boundingSphereCheck(bodyA: Body, bodyB: Body): boolean;
        aabbQuery(world: World, aabb: AABB, result: Body[]): Body[];

    }

    export class GridBroadphase extends BroadPhase {

        nx: number;
        ny: number;
        nz: number;
        aabbMin: Vec3;
        aabbMax: Vec3;
        bins: any[];

        constructor(aabbMin?: Vec3, aabbMax?: Vec3, nx?: number, ny?: number, nz?: number);

    }

    export class NaiveBroadphase extends BroadPhase {
    }

    export class ObjectCollisionMatrix {

        matrix: number[];

        get(i: number, j: number): number;
        set(i: number, j: number, value: number): void;
        reset(): void;
        setNumObjects(n: number): void;

    }

    export class Ray {

        from: Vec3;
        to: Vec3;
        precision: number;
        checkCollisionResponse: boolean;

        constructor(from?: Vec3, to?: Vec3);

        getAABB(result: RaycastResult): void;

    }

    export class RaycastResult {

        rayFromWorld: Vec3;
        rayToWorld: Vec3;
        hitNormalWorld: Vec3;
        hitPointWorld: Vec3;
        hasHit: boolean;
        shape: Shape;
        body: Body;
        distance: number;

        reset(): void;
        set(rayFromWorld: Vec3, rayToWorld: Vec3, hitNormalWorld: Vec3, hitPointWorld: Vec3, shape: Shape, body: Body, distance: number): void;

    }

    export class SAPBroadphase extends BroadPhase {

        static insertionSortX(a: any[]): any[];
        static insertionSortY(a: any[]): any[];
        static insertionSortZ(a: any[]): any[];
        static checkBounds(bi: Body, bj: Body, axisIndex?: number): boolean;

        axisList: any[];
        world: World;
        axisIndex: number;

        constructor(world?: World);

        autoDetectAxis(): void;
        aabbQuery(world: World, aabb: AABB, result?: Body[]): Body[];

    }

    export interface IConstraintOptions {

        collideConnected?: boolean;
        wakeUpBodies?: boolean;

    }

    export class Constraint {

        equations: any[];
        bodyA: Body;
        bodyB: Body;
        id: number;
        collideConnected: boolean;

        constructor(bodyA: Body, bodyB: Body, options?: IConstraintOptions);

        update(): void;
        disable(): void;
        enable(): void;

    }

    export class DistanceConstraint extends Constraint {

        constructor(bodyA: Body, bodyB: Body, distance: number, maxForce?: number);

    }

    export interface IHingeConstraintOptions {

        pivotA?: Vec3;
        axisA?: Vec3;
        pivotB?: Vec3;
        axisB?: Vec3;
        maxForce?: number;

    }

    export class HingeConstraint extends Constraint {

        motorEnabled: boolean;
        motorTargetVelocity: number;
        motorMinForce: number;
        motorMaxForce: number;
        motorEquation: RotationalMotorEquation;

        constructor(bodyA: Body, bodyB: Body, options?: IHingeConstraintOptions);

        enableMotor(): void;
        disableMotor(): void;

    }

    export class PointToPointConstraint extends Constraint {

        constructor(bodyA: Body, pivotA: Vec3, bodyB: Body, pivotB: Vec3, maxForce?: number);

    }

    export interface ILockConstraintOptions {
        maxForce?: number;
    }

    export class LockConstraint extends Constraint {
        constructor(bodyA: Body, bodyB: Body, options?: ILockConstraintOptions);
    }

    export interface IConeTwistConstraintOptions {
        pivotA?: Vec3;
        pivotB?: Vec3;
        axisA?: Vec3;
        axisB?: Vec3;
        maxForce?: number;
    }

    export class ConeTwistConstraint extends Constraint {
        constructor(bodyA: Body, bodyB: Body, options?: IConeTwistConstraintOptions);
    }



    export class Equation {

        id: number;
        minForce: number;
        maxForce: number;
        bi: Body;
        bj: Body;
        a: number;
        b: number;
        eps: number;
        jacobianElementA: JacobianElement;
        jacobianElementB: JacobianElement;
        enabled: boolean;

        constructor(bi: Body, bj: Body, minForce?: number, maxForce?: number);

        setSpookParams(stiffness: number, relaxation: number, timeStep: number): void;
        computeB(a: number, b: number, h: number): number;
        computeGq(): number;
        computeGW(): number;
        computeGWlamda(): number;
        computeGiMf(): number;
        computeGiMGt(): number;
        addToWlamda(deltalambda: number): number;
        computeC(): number;

    }

    export class FrictionEquation extends Equation {

        constructor(bi: Body, bj: Body, slipForce: number);

    }

    export class RotationalEquation extends Equation {

        ni: Vec3;
        nj: Vec3;
        nixnj: Vec3;
        njxni: Vec3;
        invIi: Mat3;
        invIj: Mat3;
        relVel: Vec3;
        relForce: Vec3;

        constructor(bodyA: Body, bodyB: Body);

    }

    export class RotationalMotorEquation extends Equation {

        axisA: Vec3;
        axisB: Vec3;
        invLi: Mat3;
        invIj: Mat3;
        targetVelocity: number;

        constructor(bodyA: Body, bodyB: Body, maxForce?: number);

    }

    export class ContactEquation extends Equation {

        restitution: number;
        ri: Vec3;
        rj: Vec3;
        penetrationVec: Vec3;
        ni: Vec3;
        rixn: Vec3;
        rjxn: Vec3;
        invIi: Mat3;
        invIj: Mat3;
        biInvInertiaTimesRixn: Vec3;
        bjInvInertiaTimesRjxn: Vec3;

        constructor(bi: Body, bj: Body);

    }

    export interface IContactMaterialOptions {

        friction?: number;
        restitution?: number;
        contactEquationStiffness?: number;
        contactEquationRelaxation?: number;
        frictionEquationStiffness?: number;
        frictionEquationRelaxation?: number;

    }

    export class ContactMaterial {

        id: number;
        materials: Material[];
        friction: number;
        restitution: number;
        contactEquationStiffness: number;
        contactEquationRelaxation: number;
        frictionEquationStiffness: number;
        frictionEquationRelaxation: number;

        constructor(m1: Material, m2: Material, options?: IContactMaterialOptions);

    }

    export class Material {

        name: string;
        id: number;
        friction:number;
        restitution:number;

        constructor(name: string);

    }

    export class JacobianElement {

        spatial: Vec3;
        rotational: Vec3;

        multiplyElement(element: JacobianElement): number;
        multiplyVectors(spacial: Vec3, rotational: Vec3): number;

    }

    export class Mat3 {

        constructor(elements?: number[]);

        identity(): void;
        setZero(): void;
        setTrace(vec3: Vec3): void;
        getTrace(target: Vec3): void;
        vmult(v: Vec3, target?: Vec3): Vec3;
        smult(s: number): void;
        mmult(m: Mat3): Mat3;
        scale(v: Vec3, target?: Mat3): Mat3;
        solve(b: Vec3, target?: Vec3): Vec3;
        e(row: number, column: number, value?: number): number;
        copy(source: Mat3): Mat3;
        toString(): string;
        reverse(target?: Mat3): Mat3;
        setRotationFromQuaternion(q: Quaternion): Mat3;
        transpose(target?: Mat3): Mat3;

    }

    export class Quaternion {

        x: number;
        y: number;
        z: number;
        w: number;

        constructor(x?: number, y?: number, z?: number, w?: number);

        set(x: number, y: number, z: number, w: number): void;
        toString(): string;
        toArray(): number[];
        setFromAxisAngle(axis: Vec3, angle: number): void;
        toAxisAngle(targetAxis?: Vec3): any[];
        setFromVectors(u: Vec3, v: Vec3): void;
        mult(q: Quaternion, target?: Quaternion): Quaternion;
        inverse(target?: Quaternion): Quaternion;
        conjugate(target?: Quaternion): Quaternion;
        normalize(): void;
        normalizeFast(): void;
        vmult(v: Vec3, target?: Vec3): Vec3;
        copy(source: Quaternion): Quaternion;
        toEuler(target: Vec3, order?: string): void;
        setFromEuler(x: number, y: number, z: number, order?: string): Quaternion;
        clone(): Quaternion;

    }

    export class Transform {

        static pointToLocalFrame(position: Vec3, quaternion: Quaternion, worldPoint: Vec3, result?: Vec3): Vec3;
        static pointToWorldFrame(position: Vec3, quaternion: Quaternion, localPoint: Vec3, result?: Vec3): Vec3;

        position: Vec3;
        quaternion: Quaternion;

        vectorToWorldFrame(localVector: Vec3, result?: Vec3): Vec3;
        vectorToLocalFrame(position: Vec3, quaternion: Quaternion, worldVector: Vec3, result?: Vec3): Vec3;

    }

    export class Trimesh {
        constructor(vertices: number[],  indices: number[] );
    }

    export class Vec3 {

        static ZERO: Vec3;

        x: number;
        y: number;
        z: number;

        constructor(x?: number, y?: number, z?: number);

        cross(v: Vec3, target?: Vec3): Vec3;
        set(x: number, y: number, z: number): Vec3;
        setZero(): void;
        vadd(v: Vec3, target?: Vec3): Vec3;
        vsub(v: Vec3, target?: Vec3): Vec3;
        crossmat(): Mat3;
        normalize(): number;
        unit(target?: Vec3): Vec3;
        norm(): number;
        norm2(): number;
        distanceTo(p: Vec3): number;
        mult(scalar: number, target?: Vec3): Vec3;
        scale(scalar: number, target?: Vec3): Vec3;
        dot(v: Vec3): number;
        isZero(): boolean;
        negate(target?: Vec3): Vec3;
        tangents(t1: Vec3, t2: Vec3): void;
        toString(): string;
        toArray(): number[];
        copy(source: Vec3): Vec3;
        lerp(v: Vec3, t: number, target?: Vec3): void;
        almostEquals(v: Vec3, precision?: number): boolean;
        almostZero(precision?: number): boolean;
        isAntiparallelTo(v: Vec3, prescision?: number): boolean;
        clone(): Vec3;

    }

    export interface IBodyOptions {
        position?: Vec3;
        velocity?: Vec3;
        angularVelocity?: Vec3;
        quaternion?: Quaternion;
        mass?: number;
        material?: Material;
        type?: number;
        linearDamping?: number;
        angularDamping?: number;
        allowSleep?: boolean;
        sleepSpeedLimit?: number;
        sleepTimeLimit?: number;
        collisionFilterGroup?: number;
        collisionFilterMask?: number;
        fixedRotation?: boolean;
        shape?: Shape;
    }

    export class Body extends EventTarget {

        static DYNAMIC: number;
        static STATIC: number;
        static KINEMATIC: number;
        static AWAKE: number;
        static SLEEPY: number;
        static SLEEPING: number;
        static sleepyEvent: IEvent;
        static sleepEvent: IEvent;

        id: number;
        world: World;
        preStep: Function;
        postStep: Function;
        vlambda: Vec3;
        collisionFilterGroup: number;
        collisionFilterMask: number;
        collisionResponse: boolean;
        position: Vec3;
        previousPosition: Vec3;
        initPosition: Vec3;
        velocity: Vec3;
        initVelocity: Vec3;
        force: Vec3;
        mass: number;
        invMass: number;
        material: Material;
        linearDamping: number;
        type: number;
        allowSleep: boolean;
        sleepState: number;
        sleepSpeedLimit: number;
        sleepTimeLimit: number;
        timeLastSleepy: number;
        torque: Vec3;
        quaternion: Quaternion;
        initQuaternion: Quaternion;
        angularVelocity: Vec3;
        initAngularVelocity: Vec3;
        interpolatedPosition: Vec3;
        interpolatedQuaternion: Quaternion;
        shapes: Shape[];
        shapeOffsets: any[];
        shapeOrientations: any[];
        inertia: Vec3;
        invInertia: Vec3;
        invInertiaWorld: Mat3;
        invMassSolve: number;
        invInertiaSolve: Vec3;
        invInteriaWorldSolve: Mat3;
        fixedRotation: boolean;
        angularDamping: number;
        aabb: AABB;
        aabbNeedsUpdate: boolean;
        wlambda: Vec3;

        constructor(options?: IBodyOptions);

        wakeUp(): void;
        sleep(): void;
        sleepTick(time: number): void;
        updateSolveMassProperties(): void;
        pointToLocalFrame(worldPoint: Vec3, result?: Vec3): Vec3;
        pointToWorldFrame(localPoint: Vec3, result?: Vec3): Vec3;
        vectorToWorldFrame(localVector: Vec3, result?: Vec3): Vec3;
        addShape(shape: Shape, offset?: Vec3, orientation?: Quaternion): void;
        addShape(shape: Trimesh, offset?: Vec3, orientation?: Quaternion): void;
        updateBoundingRadius(): void;
        computeAABB(): void;
        updateInertiaWorld(force: Vec3): void;
        applyForce(force: Vec3, worldPoint: Vec3): void;
        applyImpulse(impulse: Vec3, worldPoint: Vec3): void;
        applyLocalForce(force: Vec3, localPoint: Vec3): void;
        applyLocalImpulse(impulse: Vec3, localPoint: Vec3): void;
        updateMassProperties(): void;
        getVelocityAtWorldPoint(worldPoint: Vec3, result: Vec3): Vec3;

    }

    export interface IRaycastVehicleOptions {

        chassisBody?: Body;
        indexRightAxis?: number;
        indexLeftAxis?: number;
        indexUpAxis?: number;

    }

    export interface IWheelInfoOptions {

        chassisConnectionPointLocal?: Vec3;
        chassisConnectionPointWorld?: Vec3;
        directionLocal?: Vec3;
        directionWorld?: Vec3;
        axleLocal?: Vec3;
        axleWorld?: Vec3;
        suspensionRestLength?: number;
        suspensionMaxLength?: number;
        radius?: number;
        suspensionStiffness?: number;
        dampingCompression?: number;
        dampingRelaxation?: number;
        frictionSlip?: number;
        steering?: number;
        rotation?: number;
        deltaRotation?: number;
        rollInfluence?: number;
        maxSuspensionForce?: number;
        isFronmtWheel?: boolean;
        clippedInvContactDotSuspension?: number;
        suspensionRelativeVelocity?: number;
        suspensionForce?: number;
        skidInfo?: number;
        suspensionLength?: number;
        maxSuspensionTravel?: number;
        useCustomSlidingRotationalSpeed?: boolean;
        customSlidingRotationalSpeed?: number;

        position?: Vec3;
        direction?: Vec3;
        axis?: Vec3;
        body?: Body;

    }

    export class WheelInfo {

        maxSuspensionTravbel: number;
        customSlidingRotationalSpeed: number;
        useCustomSlidingRotationalSpeed: boolean;
        sliding: boolean;
        chassisConnectionPointLocal: Vec3;
        chassisConnectionPointWorld: Vec3;
        directionLocal: Vec3;
        directionWorld: Vec3;
        axleLocal: Vec3;
        axleWorld: Vec3;
        suspensionRestLength: number;
        suspensionMaxLength: number;
        radius: number;
        suspensionStiffness: number;
        dampingCompression: number;
        dampingRelaxation: number;
        frictionSlip: number;
        steering: number;
        rotation: number;
        deltaRotation: number;
        rollInfluence: number;
        maxSuspensionForce: number;
        engineForce: number;
        brake: number;
        isFrontWheel: boolean;
        clippedInvContactDotSuspension: number;
        suspensionRelativeVelocity: number;
        suspensionForce: number;
        skidInfo: number;
        suspensionLength: number;
        sideImpulse: number;
        forwardImpulse: number;
        raycastResult: RaycastResult;
        worldTransform: Transform;
        isInContact: boolean;

        constructor(options?: IWheelInfoOptions);

    }

    export class RaycastVehicle {

        chassisBody: Body;
        wheelInfos: IWheelInfoOptions[];
        sliding: boolean;
        world: World;
        iindexRightAxis: number;
        indexForwardAxis: number;
        indexUpAxis: number;

        constructor(options?: IRaycastVehicleOptions);

        addWheel(options?: IWheelInfoOptions): void;
        setSteeringValue(value: number, wheelIndex: number): void;
        applyEngineForce(value: number, wheelIndex: number): void;
        setBrake(brake: number, wheelIndex: number): void;
        addToWorld(world: World): void;
        getVehicleAxisWorld(axisIndex: number, result: Vec3): Vec3;
        updateVehicle(timeStep: number): void;
        updateSuspension(deltaTime: number): void;
        removeFromWorld(world: World): void;
        getWheelTransformWorld(wheelIndex: number): Transform;

    }

    export interface IRigidVehicleOptions {

        chassisBody: Body;

    }

    export class RigidVehicle {

        wheelBodies: Body[];
        coordinateSystem: Vec3;
        chassisBody: Body;
        constraints: Constraint[];
        wheelAxes: Vec3[];
        wheelForces: Vec3[];

        constructor(options?: IRigidVehicleOptions);

        addWheel(options?: IWheelInfoOptions): Body;
        setSteeringValue(value: number, wheelIndex: number): void;
        setMotorSpeed(value: number, wheelIndex: number): void;
        disableMotor(wheelIndex: number): void;
        setWheelForce(value: number, wheelIndex: number): void;
        applyWheelForce(value: number, wheelIndex: number): void;
        addToWorld(world: World): void;
        removeFromWorld(world: World): void;
        getWheelSpeed(wheelIndex: number): number;

    }

    export class SPHSystem {

        particles: Particle[];
        density: number;
        smoothingRadius: number;
        speedOfSound: number;
        viscosity: number;
        eps: number;
        pressures: number[];
        densities: number[];
        neighbors: number[];

        add(particle: Particle): void;
        remove(particle: Particle): void;
        getNeighbors(particle: Particle, neighbors: Particle[]): void;
        update(): void;
        w(r: number): number;
        gradw(rVec: Vec3, resultVec: Vec3): void;
        nablaw(r: number): number;

    }

    export interface ISpringOptions {

        restLength?: number;
        stiffness?: number;
        damping?: number;
        worldAnchorA?: Vec3;
        worldAnchorB?: Vec3;
        localAnchorA?: Vec3;
        localAnchorB?: Vec3;

    }

    export class Spring {

        restLength: number;
        stffness: number;
        damping: number;
        bodyA: Body;
        bodyB: Body;
        localAnchorA: Vec3;
        localAnchorB: Vec3;

        constructor(options?: ISpringOptions);

        setWorldAnchorA(worldAnchorA: Vec3): void;
        setWorldAnchorB(worldAnchorB: Vec3): void;
        getWorldAnchorA(result: Vec3): void;
        getWorldAnchorB(result: Vec3): void;
        applyForce(): void;

    }

    export class Box extends Shape {

        static calculateIntertia(halfExtents: Vec3, mass: number, target: Vec3): void;

        boundingSphereRadius: number;
        collisionResponse: boolean;
        halfExtents: Vec3;
        convexPolyhedronRepresentation: ConvexPolyhedron;

        constructor(halfExtents: Vec3);

        updateConvexPolyhedronRepresentation(): void;
        calculateLocalInertia(mass: number, target?: Vec3): Vec3;
        getSideNormals(sixTargetVectors: boolean, quat?: Quaternion): Vec3[];
        updateBoundingSphereRadius(): number;
        volume(): number;
        forEachWorldCorner(pos: Vec3, quat: Quaternion, callback: Function): void;

    }

    export class ConvexPolyhedron extends Shape {

        static computeNormal(va: Vec3, vb: Vec3, vc: Vec3, target: Vec3): void;
        static project(hull: ConvexPolyhedron, axis: Vec3, pos: Vec3, quat: Quaternion, result: number[]): void;

        vertices: Vec3[];
        worldVertices: Vec3[];
        worldVerticesNeedsUpdate: boolean;
        faces: number[][];
        faceNormals: Vec3[];
        uniqueEdges: Vec3[];

        constructor(points?: Vec3[], faces?: number[]);

        computeEdges(): void;
        computeNormals(): void;
        getFaceNormal(i: number, target: Vec3): Vec3;
        clipAgainstHull(posA: Vec3, quatA: Quaternion, hullB: Vec3, quatB: Quaternion, separatingNormal: Vec3, minDist: number, maxDist: number, result: any[]): void;
        findSaparatingAxis(hullB: ConvexPolyhedron, posA: Vec3, quatA: Quaternion, posB: Vec3, quatB: Quaternion, target: Vec3, faceListA: any[], faceListB: any[]): boolean;
        testSepAxis(axis: Vec3, hullB: ConvexPolyhedron, posA: Vec3, quatA: Quaternion, posB: Vec3, quatB: Quaternion): number;
        getPlaneConstantOfFace(face_i: number): number;
        clipFaceAgainstHull(separatingNormal: Vec3, posA: Vec3, quatA: Quaternion, worldVertsB1: Vec3[], minDist: number, maxDist: number, result: any[]): void;
        clipFaceAgainstPlane(inVertices: Vec3[], outVertices: Vec3[], planeNormal: Vec3, planeConstant: number): Vec3;
        computeWorldVertices(position: Vec3, quat: Quaternion): void;
        computeLocalAABB(aabbmin: Vec3, aabbmax: Vec3): void;
        computeWorldFaceNormals(quat: Quaternion): void;
        calculateWorldAABB(pos: Vec3, quat: Quaternion, min: Vec3, max: Vec3): void;
        getAveragePointLocal(target: Vec3): Vec3;
        transformAllPoints(offset: Vec3, quat: Quaternion): void;
        pointIsInside(p: Vec3): boolean;

    }

    export class Cylinder extends Shape {

        constructor(radiusTop: number, radiusBottom: number, height: number, numSegments: number);

    }

    export interface IHightfield {

        minValue?: number;
        maxValue?: number;
        elementSize: number;

    }

    export class Heightfield extends Shape {

        data: number[][];
        maxValue: number;
        minValue: number;
        elementSize: number;
        cacheEnabled: boolean;
        pillarConvex: ConvexPolyhedron;
        pillarOffset: Vec3;
        type: number;

        constructor(data: number[], options?: IHightfield);

        update(): void;
        updateMinValue(): void;
        updateMaxValue(): void;
        setHeightValueAtIndex(xi: number, yi: number, value: number): void;
        getRectMinMax(iMinX: number, iMinY: number, iMaxX: number, iMaxY: number, result: any[]): void;
        getIndexOfPosition(x: number, y: number, result: any[], clamp: boolean): boolean;
        getConvexTrianglePillar(xi: number, yi: number, getUpperTriangle: boolean): void;

    }

    export class Particle extends Shape {

    }

    export class Plane extends Shape {

        worldNormal: Vec3;
        worldNormalNeedsUpdate: boolean;
        boundingSphereRadius: number;

        computeWorldNormal(quat: Quaternion): void;
        calculateWorldAABB(pos: Vec3, quat: Quaternion, min: number, max: number): void;

    }

    export class Shape {

        static types: {

            SPHERE: number;
            PLANE: number;
            BOX: number;
            COMPOUND: number;
            CONVEXPOLYHEDRON: number;
            HEIGHTFIELD: number;
            PARTICLE: number;
            CYLINDER: number;

        }

        type: number;
        boundingSphereRadius: number;
        collisionResponse: boolean;

        updateBoundingSphereRadius(): number;
        volume(): number;
        calculateLocalInertia(mass: number, target: Vec3): Vec3;

    }

    export class Sphere extends Shape {

        radius: number;

        constructor(radius: number);

    }

    export class GSSolver extends Solver {

        iterations: number;
        tolerance: number;

        solve(dy: number, world: World): number;


    }

    export class Solver {
        iterations: number;
        equations: Equation[];

        solve(dy: number, world: World): number;
        addEquation(eq: Equation): void;
        removeEquation(eq: Equation): void;
        removeAllEquations(): void;

    }

    export class SplitSolver extends Solver {

        subsolver: Solver;

        constructor(subsolver: Solver);

        solve(dy: number, world: World): number;

    }

    export class EventTarget {

        addEventListener(type: string, listener: Function): EventTarget;
        hasEventListener(type: string, listener: Function): boolean;
        removeEventListener(type: string, listener: Function): EventTarget;
        dispatchEvent(event: IEvent): IEvent;

    }

    export class Pool {

        objects: any[];
        type: any[];

        release(): any;
        get(): any;
        constructObject(): any;

    }

    export class TupleDictionary {

        data: {
            keys: any[];
        };

        get(i: number, j: number): number;
        set(i: number, j: number, value: number): void;
        reset(): void;

    }

    export class Utils {

        static defaults(options?: any, defaults?: any): any;

    }

    export class Vec3Pool extends Pool {

        type: any;

        constructObject(): Vec3;

    }

    export class NarrowPhase {

        contactPointPool: Pool[];
        v3pool: Vec3Pool;

    }

    export class World extends EventTarget {
        iterations: number;
        dt: number;
        allowSleep: boolean;
        contacts: ContactEquation[];
        frictionEquations: FrictionEquation[];
        quatNormalizeSkip: number;
        quatNormalizeFast: boolean;
        time: number;
        stepnumber: number;
        default_dt: number;
        nextId: number;
        gravity: Vec3;
        broadphase: NaiveBroadphase;
        bodies: Body[];
        solver: Solver;
        constraints: Constraint[];
        narrowPhase: NarrowPhase;
        collisionMatrix: ArrayCollisionMatrix;
        collisionMatrixPrevious: ArrayCollisionMatrix;
        materials: Material[];
        contactmaterials: ContactMaterial[];
        contactMaterialTable: TupleDictionary;
        defaultMaterial: Material;
        defaultContactMaterial: ContactMaterial;
        doProfiling: boolean;
        profile: {
            solve: number;
            makeContactConstraints: number;
            broadphaser: number;
            integrate: number;
            narrowphase: number;
        };
        subsystems: any[];
        addBodyEvent: IBodyEvent;
        removeBodyEvent: IBodyEvent;

        getContactMaterial(m1: Material, m2: Material): ContactMaterial;
        numObjects(): number;
        collisionMatrixTick(): void;
        addBody(body: Body): void;
        addConstraint(c: Constraint): void;
        removeConstraint(c: Constraint): void;
        rayTest(from: Vec3, to: Vec3, result: RaycastResult): void;
        remove(body: Body): void;
        addMaterial(m: Material): void;
        addContactMaterial(cmat: ContactMaterial): void;
        step(dy: number, timeSinceLastCalled?: number, maxSubSteps?: number): void;

    }

    export interface IEvent {

        type: string;

    }

    export interface IBodyEvent extends IEvent {

        body: Body;

    }

    export interface ICollisionEvent extends IBodyEvent {
        contact: any;
    }

}


declare module ""cannon"" {
    export = CANNON;
}"
/* coconut game */,"import { Ball } from ""./modules/ball""
import { Coconut } from ""./modules/coconut""
// import { coconutShyMeshVertices, coconutShyMeshIndices } from ""./modules/meshData/coconutShyMesh""
// import { wallMeshVertices, wallMeshIndices } from ""./modules/meshData/wallMesh""
import * as ui from ""@dcl/ui-scene-utils""
import { loadColliders } from ""./modules/colliderSetup""

const base = new Entity()
base.addComponent(new GLTFShape(""models/baseLight.glb""))
engine.addEntity(base)

const coconutShy = new Entity()
coconutShy.addComponent(new GLTFShape(""models/coconutShy.glb""))
coconutShy.addComponent(new Transform())
engine.addEntity(coconutShy)

// Setup our world
const world = new CANNON.World()
world.quatNormalizeSkip = 0
world.quatNormalizeFast = false
world.gravity.set(0, -9.82, 0) // m/sÂ²

loadColliders(world)

// Setup ground material
const physicsMaterial = new CANNON.Material(""groundMaterial"")
const ballContactMaterial = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, { friction: 1, restitution: 0.5 })
world.addContactMaterial(ballContactMaterial)

// Create balls
const ball1 = new Ball(new Transform({ position: new Vector3(7.4, 1.43, 6.7) }), physicsMaterial, world)
const ball2 = new Ball(new Transform({ position: new Vector3(7.7, 1.43, 6.7) }), physicsMaterial, world)
const ball3 = new Ball(new Transform({ position: new Vector3(8, 1.43, 6.7) }), physicsMaterial, world)
const ball4 = new Ball(new Transform({ position: new Vector3(8.3, 1.43, 6.7) }), physicsMaterial, world)
const ball5 = new Ball(new Transform({ position: new Vector3(8.6, 1.43, 6.7) }), physicsMaterial, world)

const balls: Ball[] = [ball1, ball2, ball3, ball4, ball5]

// Create coconuts
const coconut1 = new Coconut(new Transform({ position: new Vector3(7.2, 2.42, 9.535) }), physicsMaterial, world)
const coconut2 = new Coconut(new Transform({ position: new Vector3(7.6, 2.25, 9.535) }), physicsMaterial, world)
const coconut3 = new Coconut(new Transform({ position: new Vector3(8, 2.42, 9.535) }), physicsMaterial, world)
const coconut4 = new Coconut(new Transform({ position: new Vector3(8.4, 2.25, 9.535) }), physicsMaterial, world)
const coconut5 = new Coconut(new Transform({ position: new Vector3(8.8, 2.42, 9.535) }), physicsMaterial, world)
const coconuts: Coconut[] = [coconut1, coconut2, coconut3, coconut4, coconut5]

// Create a ground plane and apply physics material
const groundShape: CANNON.Plane = new CANNON.Plane()
const groundBody: CANNON.Body = new CANNON.Body({ mass: 0 })
groundBody.addShape(groundShape)
groundBody.material = physicsMaterial
groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2) // Reorient ground plane to be in the y-axis
groundBody.position.set(0, 0.05, 0)
world.addBody(groundBody) // Add ground body to world

// Controls and UI
let throwPower = 0
let powerBar = new ui.UIBar(0, -80, 80, Color4.Yellow(), ui.BarStyles.ROUNDWHITE)
let powerIcon = new ui.SmallIcon(""images/powerIcon.png"", -101, 85, 90, 23)
let isPowerUp = true
const POWER_UP_SPEED = 150

class PowerMeterSystem implements ISystem {
  update(dt: number): void {
    if (throwPower < 1) {
      isPowerUp = true
    } else if (throwPower > 99) {
      isPowerUp = false
    }

    if (throwPower > 0 || throwPower < 99) {
      isPowerUp ? (throwPower += dt * POWER_UP_SPEED * 1.1) : (throwPower -= dt * POWER_UP_SPEED) // Powering up is 10% faster
      powerBar.set(throwPower / 100)
      throwPower > 80 ? (powerBar.bar.color = Color4.Red()) : (powerBar.bar.color = Color4.Yellow())
    }
  }
}

let powerMeterSys: PowerMeterSystem

// Controls
Input.instance.subscribe(""BUTTON_DOWN"", ActionButton.POINTER, false, (e) => {
  for (let ball of balls) {
    if (ball.isActive && !ball.isThrown) {
      powerBar.bar.visible = true
      powerBar.background.visible = true
      throwPower = 1
      powerMeterSys = new PowerMeterSystem()
      engine.addSystem(powerMeterSys)
    }
  }
})

Input.instance.subscribe(""BUTTON_UP"", ActionButton.POINTER, false, (e) => {
  for (let ball of balls) {
    if (ball.isActive && !ball.isThrown) {
      // Strength system
      engine.removeSystem(powerMeterSys)
      powerBar.set(0)

      let throwDirection = Vector3.Forward().rotate(Camera.instance.rotation) // Camera's forward vector
      ball.playerThrow(throwDirection, throwPower)
    }
  }
})

// Set high to prevent tunnelling
const FIXED_TIME_STEPS = 1.0 / 60
const MAX_TIME_STEPS = 10

class PhysicsSystem implements ISystem {
  update(dt: number): void {
    world.step(FIXED_TIME_STEPS, dt, MAX_TIME_STEPS)

    for (let i = 0; i < balls.length; i++) {
      if (!balls[i].isActive) {
        balls[i].getComponent(Transform).position.copyFrom(balls[i].body.position)
        balls[i].getComponent(Transform).rotation.copyFrom(balls[i].body.quaternion)
      }
      if (balls[i].body.velocity.almostEquals(new CANNON.Vec3(0, 0, 0), 2) && balls[i].body.sleepState !== CANNON.Body.SLEEPING) {
        balls[i].glowEntity.getComponent(GLTFShape).visible = true
      }
    }
    for (let i = 0; i < coconuts.length; i++) {
      coconuts[i].getComponent(Transform).position.copyFrom(coconuts[i].body.position)
      coconuts[i].getComponent(Transform).rotation.copyFrom(coconuts[i].body.quaternion)
    }
  }
}
engine.addSystem(new PhysicsSystem())"
/* inflatable punch bag game */  ,"import { Sound } from ""./sound""

// Base
const base = new Entity()
base.addComponent(new GLTFShape(""models/baseDarkWithCollider.glb""))
engine.addEntity(base)

// Sound
const punchSound = new Sound(new AudioClip(""sounds/punch.mp3""))

// Punchbag
const punchBag = new Entity()
punchBag.addComponent(new GLTFShape(""models/dogePunchBag.glb""))
punchBag.addComponent(new Transform({ position: new Vector3(8, 0, 8) }))
punchBag.getComponent(Transform).scale.setAll(0.5)
engine.addEntity(punchBag)

// User variables
let forwardVector: Vector3 = Vector3.Forward().rotate(Camera.instance.rotation) // Camera's forward vector
let vectorScale: number = 20

// Allow the user to interact with the punchbag
punchBag.addComponent(
  new OnPointerDown(
    (e) => {
      // Apply impulse based on camera's direction
      targetAnchorBody.applyImpulse(
        new CANNON.Vec3(forwardVector.x * vectorScale, forwardVector.y * vectorScale, forwardVector.z * vectorScale),
        new CANNON.Vec3(targetAnchorBody.position.x, targetAnchorBody.position.y, targetAnchorBody.position.z)
      )
      punchSound.getComponent(AudioSource).playOnce()
    },
    {
      button: ActionButton.ANY,
      showFeedback: true,
      hoverText: ""punch"",
      distance: 4,
    }
  )
)

// Setup our world
const world: CANNON.World = new CANNON.World()
world.gravity.set(0, 10, 0) // m/sÂ²
world.broadphase = new CANNON.NaiveBroadphase()

// Create a ground plane and apply physics material
const groundBody: CANNON.Body = new CANNON.Body({
  mass: 0, // Setting the mass == 0 makes the body static
})
groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2) // Reorient ground plane to be in the y-axis

const physicsMaterial = new CANNON.Material(""physicsMaterial"")
const physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, { friction: 0, restitution: 0.1 })
world.addContactMaterial(physicsContactMaterial)

const groundShape: CANNON.Plane = new CANNON.Plane()
groundBody.addShape(groundShape)
groundBody.material = physicsMaterial
world.addBody(groundBody)

// Create a static body
let fixedAnchorBody = new CANNON.Body({ mass: 0 })
fixedAnchorBody.position.set(8, 0, 8)
world.addBody(fixedAnchorBody)

// Create target body
let sphereShape = new CANNON.Sphere(0.2)
let targetAnchorBody = new CANNON.Body({ mass: 5 })
targetAnchorBody.addShape(sphereShape)
targetAnchorBody.position.set(8, 3, 8)
world.addBody(targetAnchorBody)

targetAnchorBody.linearDamping = 0.4 // Round bodies will keep translating even with friction so you need linearDamping
targetAnchorBody.angularDamping = 1.0 // Round bodies will keep rotating even with friction so you need angularDamping

var spring = new CANNON.Spring(targetAnchorBody, fixedAnchorBody, {
  localAnchorA: new CANNON.Vec3(0, 0, 0),
  localAnchorB: new CANNON.Vec3(0, 0, 0),
  restLength: 0.0,
  stiffness: 50,
  damping: 8,
})

// Compute the force after each step
world.addEventListener(""postStep"", function () {
  spring.applyForce()
})

const fixedTimeStep: number = 1.0 / 60.0 // Seconds
const maxSubSteps: number = 10

class UpdateSystem implements ISystem {
  update(dt: number): void {
    world.step(fixedTimeStep, dt, maxSubSteps)

    // https://answers.unity.com/questions/24805/preventing-lookat-from-flipping.html
    let transform = punchBag.getComponent(Transform)
    let relativePos = targetAnchorBody.position.vsub(new CANNON.Vec3(transform.position.x, transform.position.y, transform.position.z))
    transform.rotation = Quaternion.LookRotation(new Vector3(relativePos.x, relativePos.y, relativePos.z), Vector3.Forward())

    // Update forward vector
    forwardVector = Vector3.Forward().rotate(Camera.instance.rotation)
  }
}

engine.addSystem(new UpdateSystem())"
/* inflatable punch bag sound */,"export class Sound extends Entity {
  constructor(audio: AudioClip) {
    super()
    engine.addEntity(this)
    this.addComponent(new AudioSource(audio))
    this.addComponent(new Transform())
    this.getComponent(AudioSource).loop = false
    this.getComponent(Transform).position = Camera.instance.position
  }
}"
/* mirror puzzle game */,"import * as utils from '@dcl/ecs-scene-utils'
import { Mirror } from './mirror'
import { redrawRays } from './reflectedRay'

// Base
const base = new Entity()
base.addComponent(new GLTFShape('models/baseCheckered.glb'))
engine.addEntity(base)

// Boundaries
const boundaries = new Entity()
boundaries.addComponent(new GLTFShape('models/boundaries.glb'))
engine.addEntity(boundaries)

// Blocked coordinates
const blocked: Vector3[] = [
  new Vector3(1.5, 0, 14.5),
  new Vector3(2.5, 0, 14.5),
  new Vector3(3.5, 0, 14.5),
  new Vector3(4.5, 0, 14.5),
  new Vector3(5.5, 0, 14.5),
  new Vector3(6.5, 0, 14.5),
  new Vector3(7.5, 0, 14.5),
  new Vector3(8.5, 0, 14.5),
  new Vector3(9.5, 0, 14.5),
  new Vector3(10.5, 0, 14.5),
  new Vector3(11.5, 0, 14.5),
  new Vector3(11.5, 0, 15.5),
  new Vector3(11.5, 0, 16.5),
  new Vector3(11.5, 0, 17.5),
  new Vector3(10.5, 0, 17.5),
  new Vector3(9.5, 0, 17.5),
  new Vector3(8.5, 0, 17.5),
  new Vector3(7.5, 0, 17.5),
  new Vector3(6.5, 0, 17.5),
  new Vector3(5.5, 0, 17.5),
  new Vector3(4.5, 0, 17.5),
  new Vector3(3.5, 0, 17.5),
  new Vector3(2.5, 0, 17.5),
  new Vector3(1.5, 0, 17.5)
]

// Mirrors
//#region
const mirrorSelectorShape = new GLTFShape('models/mirrorSelector.glb')
// Workaround: colliders have been scaled up as the raycasting is happening above the player's head
const mirrorShape = new GLTFShape('models/mirrorScaledColliders.glb')
const mirrors: Mirror[] = []

const mirrorA = new Mirror(
  mirrorSelectorShape,
  mirrorShape,
  new Transform({ position: new Vector3(2.5, 0, 7.5) })
)
mirrors.push(mirrorA)

const mirrorB = new Mirror(
  mirrorSelectorShape,
  mirrorShape,
  new Transform({ position: new Vector3(8.5, 0, 11.5) })
)
mirrors.push(mirrorB)

const mirrorC = new Mirror(
  mirrorSelectorShape,
  mirrorShape,
  new Transform({ position: new Vector3(8.5, 0, 20.5) })
)
mirrors.push(mirrorC)

const mirrorD = new Mirror(
  mirrorSelectorShape,
  mirrorShape,
  new Transform({ position: new Vector3(2.5, 0, 24.5) })
)
mirrors.push(mirrorD)
//#endregion

// Instance the input object
const input = Input.instance
const MAX_DISTANCE = 4

// Delay dummy entity for running mirror transform transitions
const delayDummyEntity = new Entity()
engine.addEntity(delayDummyEntity)

// Button down events
input.subscribe('BUTTON_DOWN', ActionButton.POINTER, true, (e) => {
  if (e.hit.meshName === 'mirrorSelector_collider') {
    const mirrorStand = engine.entities[e.hit.entityId] as Mirror
    const mirrorStandPos = mirrorStand.getComponent(Transform).position
    const distance = Vector3.Distance(mirrorStandPos, Camera.instance.position)

    if (distance < MAX_DISTANCE) {
      const currentPos = mirrorStand.getComponent(Transform).position
      const endPos = currentPos.subtract(e.hit.normal)

      // Checks if at least one mirror in the array is blocking its path
      const mirrorOverlap = mirrors.some((mirror) => {
        return endPos.equals(mirror.getComponent(Transform).position)
      })
      const isBlocked = blocked.some((block) => {
        return endPos.equals(block)
      })

      // Check boundaries
      if (
        endPos.x >= 1 &&
        endPos.x <= 15 &&
        endPos.z >= 1 &&
        endPos.z <= 31 &&
        !mirrorOverlap &&
        !isBlocked
      ) {
        // Slide the mirror to its endPos over half a second
        if (!mirrorStand.hasComponent(utils.MoveTransformComponent)) {
          mirrorStand.moveMirror(currentPos, endPos)
        }
      }
    }
  }
})

input.subscribe('BUTTON_DOWN', ActionButton.PRIMARY, true, (e) => {
  if (e.hit.meshName === 'mirrorSelector_collider') {
    const mirrorStand = engine.entities[e.hit.entityId] as Mirror
    const mirrorStandPos = mirrorStand.getComponent(Transform).position
    const distance = Vector3.Distance(mirrorStandPos, Camera.instance.position)

    if (distance < MAX_DISTANCE) {
      mirrorStand.rotateMirror(45)
    }
  }
})

input.subscribe('BUTTON_DOWN', ActionButton.SECONDARY, true, (e) => {
  if (e.hit.meshName === 'mirrorSelector_collider') {
    const mirrorStand = engine.entities[e.hit.entityId] as Mirror
    const mirrorStandPos = mirrorStand.getComponent(Transform).position
    const distance = Vector3.Distance(mirrorStandPos, Camera.instance.position)

    if (distance < MAX_DISTANCE) {
      mirrorStand.rotateMirror(-45)
    }
  }
})

redrawRays()"
/* mirror puzzle mirror */,"import { Sound } from './sound'
import { redrawRays } from './reflectedRay'
import * as utils from '@dcl/ecs-scene-utils'

// Sounds
const mirrorMoveSound = new Sound(new AudioClip('sounds/mirrorMove.mp3'), false)

export class Mirror extends Entity {
  public rotation: number = 0 // Workaround to rotation bug
  public mirror: Entity = new Entity()

  constructor(
    collider: GLTFShape,
    mirrorModel: GLTFShape,
    transform: Transform
  ) {
    super()
    engine.addEntity(this)
    this.addComponent(collider)
    this.addComponent(transform)
    this.mirror.addComponent(mirrorModel)
    this.mirror.addComponent(new Transform())
    this.mirror.setParent(this)
  }

  rotateMirror(rotateAngle: number): void {
    // Rotate the mirror to its endPot over half a second
    if (!this.mirror.hasComponent(utils.RotateTransformComponent)) {
      const currentRot = this.mirror.getComponent(Transform).rotation
      const endRot = Quaternion.Euler(0, (this.rotation += rotateAngle), 0)
      mirrorMoveSound.getComponent(AudioSource).playOnce()
      this.mirror.addComponent(
        new utils.RotateTransformComponent(currentRot, endRot, 0.5, () => {
          this.addComponentOrReplace(
            new utils.Delay(100, () => {
              redrawRays() // Redraw
            })
          )
        })
      )
    }
  }

  moveMirror(currentPos: Vector3, endPos: Vector3): void {
    // Slide the mirror to its endPos over half a second
    if (!this.hasComponent(utils.MoveTransformComponent)) {
      mirrorMoveSound.getComponent(AudioSource).playOnce()
      this.addComponent(
        new utils.MoveTransformComponent(currentPos, endPos, 0.5, () => {
          this.addComponentOrReplace(
            new utils.Delay(100, () => {
              redrawRays() // Redraw
            })
          )
        })
      )
    }
  }
}"
/* mirror puzzle sound */ ,"export class Sound extends Entity {
  constructor(audio: AudioClip, loop: boolean, transform?: Vector3) {
    super()
    engine.addEntity(this)
    this.addComponent(new AudioSource(audio))
    this.getComponent(AudioSource).loop = loop
    this.addComponent(new Transform())
    if (transform) {
      this.getComponent(Transform).position = transform
    } else {
      this.setParent(Attachable.AVATAR)
    }
  }

  playAudioOnceAtPosition(transform: Vector3): void {
    this.getComponent(Transform).position = transform
    this.getComponent(AudioSource).playOnce()
  }

  playAudioAtPosition(transform: Vector3): void {
    this.getComponent(Transform).position = transform
    this.getComponent(AudioSource).playing = true
  }
}"
/* mirror puzzle reflected rays */,"export class ReflectedRay extends Entity {
  public ray: Ray

  constructor(model: GLTFShape, origin: Vector3, direction: Vector3) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Transform({ position: origin.clone() }))

    this.ray = {
      origin: origin,
      direction: direction,
      distance: 100
    }
  }
}

// Ray
const rayEmitter = new Entity()
rayEmitter.addComponent(new GLTFShape('models/rayEmitter.glb'))
rayEmitter.addComponent(new Transform({ position: new Vector3(2.5, 0, 2.5) }))
engine.addEntity(rayEmitter)

const rayTarget = new Entity()
rayTarget.addComponent(new GLTFShape('models/rayTarget.glb'))
rayTarget.addComponent(new Transform({ position: new Vector3(2.5, 0, 31.5) }))
engine.addEntity(rayTarget)

// Ray emitter
const originPos = new Vector3(2.5, 4.5, 2.5)
const direction = Vector3.Forward()

const ray: Ray = {
  origin: originPos,
  direction: direction,
  distance: 100
}
const rayShape = new GLTFShape('models/rayOffsetY.glb') // Workaround: offset in y to avoid affecting the raycasting hitting player
const sourceRay = new ReflectedRay(rayShape, originPos, direction)

const physicsCast = PhysicsCast.instance
const reflectedRays: ReflectedRay[] = [] // Store reflected rays

export function redrawRays(): void {
  physicsCast.hitFirst(ray, (e) => {
    // Delete previous ray models
    while (reflectedRays.length > 0) {
      const ray = reflectedRays.pop()
      engine.removeEntity(ray)
    }
    // Workaround: for when the ray hits a blank collider when the scene loads
    if (e.entity.meshName === '') {
      redrawRays()
      return
    }
    if (e.entity.meshName === 'mirror_collider') {
      const reflectedVector: Vector3 = reflectVector(
        direction,
        new Vector3(e.hitNormal.x, e.hitNormal.y, e.hitNormal.z)
      )
      reflectRay(
        new Vector3(e.hitPoint.x, e.hitPoint.y, e.hitPoint.z),
        reflectedVector
      )
    }
    const distance = Vector3.Distance(ray.origin, e.hitPoint)
    sourceRay.getComponent(Transform).scale.z = distance
  })
}

// Recursive function for reflecting a ray every time it hits a mirror
function reflectRay(hitPoint: Vector3, reflectedVector: Vector3): void {
  const reflectedRay = new ReflectedRay(rayShape, hitPoint, reflectedVector)
  reflectedRay.getComponent(Transform).position = hitPoint
  const reflectedTarget = hitPoint.clone().add(reflectedVector)
  reflectedRay.getComponent(Transform).lookAt(reflectedTarget)
  reflectedRays.push(reflectedRay)

  physicsCast.hitFirst(reflectedRay.ray, (event) => {
    const distance = Vector3.Distance(reflectedRay.ray.origin, event.hitPoint)
    reflectedRay.getComponent(Transform).scale.z = distance

    if (event.entity.meshName === 'mirror_collider') {
      const reflectedVector: Vector3 = reflectVector(
        new Vector3(
          reflectedRay.ray.direction.x,
          reflectedRay.ray.direction.y,
          reflectedRay.ray.direction.z
        ),
        new Vector3(event.hitNormal.x, event.hitNormal.y, event.hitNormal.z)
      )
      reflectRay(
        new Vector3(event.hitPoint.x, event.hitPoint.y, event.hitPoint.z),
        reflectedVector
      )
    } else if (event.entity.meshName === 'rayTarget_collider') log('You win') // Win condition
  })
}

// Put in the direction of the previous ray and the normal of the raycast's hitpoint
function reflectVector(incident: Vector3, normal: Vector3): Vector3 {
  const dot = 2 * Vector3.Dot(incident, normal)
  const reflected = incident.subtract(normal.multiplyByFloats(dot, dot, dot))
  return reflected
}"
/* mirror puzzle selector */,"// Selector
const selectorHand = new Entity()
selectorHand.addComponent(new GLTFShape('models/selectorHand.glb'))
selectorHand.addComponent(new Transform())
selectorHand.getComponent(Transform).scale.setAll(0)
engine.addEntity(selectorHand)

const selectorGlow = new Entity()
selectorGlow.addComponent(new GLTFShape('models/selectorGlow.glb'))
selectorGlow.addComponent(new Transform())
selectorGlow.getComponent(Transform).scale.setAll(0)
engine.addEntity(selectorGlow)

const MAX_DISTANCE = 3
const SELECTOR_HAND_Y_OFFSET = 1.5

// System that casts the rays to generate selector
class SelectorSystem implements ISystem {
  update() {
    // Ray from camera
    const rayFromCamera = PhysicsCast.instance.getRayFromCamera(MAX_DISTANCE)

    // For the camera ray, we cast a hit all
    PhysicsCast.instance.hitFirst(rayFromCamera, (raycastHitEntity) => {
      if (raycastHitEntity.entity.meshName === 'mirrorSelector_collider') {
        const entityID = raycastHitEntity.entity.entityId
        selectorFace(engine.entities[entityID], raycastHitEntity)
      } else {
        selectorHand.getComponent(Transform).scale.setAll(0)
        selectorGlow.getComponent(Transform).scale.setAll(0)
      }
    })
  }
}

// Adds systems to the engine
engine.addSystem(new SelectorSystem())

// Snaps the hand icon to discrete points on the mirror selector
function selectorFace(entity: IEntity, raycastHitEntity: RaycastHitEntity) {
  const transform = entity.getComponent(Transform).position.clone() // Clone position of the mirror
  selectorGlow.getComponent(Transform).position = transform.clone()
  selectorGlow.getComponent(Transform).position.y = transform.y + 0.05
  selectorGlow.getComponent(Transform).scale.setAll(1)

  selectorHand.getComponent(Transform).position = transform // Set selector transform to match the mirror
  selectorHand.getComponent(Transform).position.y =
    transform.y + SELECTOR_HAND_Y_OFFSET
  selectorHand.getComponent(Transform).scale.setAll(1)

  let selectorRotation = selectorHand.getComponent(Transform).rotation
  if (raycastHitEntity.hitNormal.x > 0) {
    selectorRotation = Quaternion.Euler(0, 90, 0)
    selectorHand.getComponent(Transform).position.x = transform.x + 1 / 1.99
  } else if (raycastHitEntity.hitNormal.x < 0) {
    selectorRotation = Quaternion.Euler(0, -90, 0)
    selectorHand.getComponent(Transform).position.x = transform.x - 1 / 1.99
  }
  if (raycastHitEntity.hitNormal.z > 0) {
    selectorRotation = Quaternion.Euler(0, 0, 0)
    selectorHand.getComponent(Transform).position.z = transform.z + 1 / 1.99
  } else if (raycastHitEntity.hitNormal.z < 0) {
    selectorRotation = Quaternion.Euler(0, 180, 0)
    selectorHand.getComponent(Transform).position.z = transform.z - 1 / 1.99
  }
  selectorHand.getComponent(Transform).rotation = selectorRotation
}"
/* rocket board game */,"import { Sound } from './sound'
import { Ring } from './ring'
// import * as CANNON from './node_modules/cannon/dist/cannon'
//import {World} from ""./node_modules/cannon-es/dist/cannon-es""

/*
  IMPORTANT: The tsconfig.json has been configured to include ""node_modules/cannon/build/cannon.js""
*/

// Create base
const baseScene: Entity = new Entity()
baseScene.addComponent(new GLTFShape('models/baseLargeCheckered.glb'))
engine.addEntity(baseScene)

// Create ring
const ring = new Ring(
  new GLTFShape('models/ring.glb'),
  new Vector3(40, 12, 40),
  2
)
ring.getComponent(Transform).scale.setAll(2.5)

// Create rocket board
const rocketBoard = new Entity()
rocketBoard.addComponent(
  new Transform({
    position: new Vector3(12, 2, 12),
    scale: new Vector3(1, 1, 1),
  })
)
rocketBoard.addComponent(new GLTFShape('models/rocketBoard.glb'))
engine.addEntity(rocketBoard)

const rocketFlames = new Entity()
rocketFlames.addComponent(new Transform({ scale: new Vector3(0, 0, 0) }))
rocketFlames.addComponent(new GLTFShape('models/rocketFlames.glb'))
rocketFlames.setParent(rocketBoard)
const rocketBoosterSound = new Sound(
  new AudioClip('sounds/rocketBooster.mp3'),
  true
) // Rocket booster sound

// Useful vectors
let forwardVector: Vector3 = Vector3.Forward().rotate(Camera.instance.rotation) // Camera's forward vector
const velocityScale: number = 250

// Setup our world
const world = new CANNON.World()
world.gravity.set(0, -9.82, 0) // m/sÂ²
const groundMaterial = new CANNON.Material('groundMaterial')
const groundContactMaterial = new CANNON.ContactMaterial(
  groundMaterial,
  groundMaterial,
  { friction: 0.5, restitution: 0.33 }
)
world.addContactMaterial(groundContactMaterial)

// Invisible walls
//#region
const wallShape = new CANNON.Box(new CANNON.Vec3(40, 50, 0.5))
const wallNorth = new CANNON.Body({
  mass: 0,
  shape: wallShape,
  position: new CANNON.Vec3(40, 49.5, 80),
})
world.addBody(wallNorth)

const wallSouth = new CANNON.Body({
  mass: 0,
  shape: wallShape,
  position: new CANNON.Vec3(40, 49.5, 0),
})
world.addBody(wallSouth)

const wallEast = new CANNON.Body({
  mass: 0,
  shape: wallShape,
  position: new CANNON.Vec3(80, 49.5, 40),
})
wallEast.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2)
world.addBody(wallEast)

const wallWest = new CANNON.Body({
  mass: 0,
  shape: wallShape,
  position: new CANNON.Vec3(0, 49.5, 40),
})
wallWest.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2)
world.addBody(wallWest)
//#endregion

// Create a ground plane and apply physics material
const groundBody = new CANNON.Body({ mass: 0 })
groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2) // Reorient ground plane to be in the y-axis

const groundShape: CANNON.Plane = new CANNON.Plane()
groundBody.addShape(groundShape)
groundBody.material = groundMaterial
world.addBody(groundBody)

const boxMaterial = new CANNON.Material('boxMaterial')
const boxContactMaterial = new CANNON.ContactMaterial(
  groundMaterial,
  boxMaterial,
  { friction: 0.4, restitution: 0 }
)
world.addContactMaterial(boxContactMaterial)

// Create body to represent the rocket board
const rocketTransform = rocketBoard.getComponent(Transform)

const rocketBody: CANNON.Body = new CANNON.Body({
  mass: 5, // kg
  position: new CANNON.Vec3(
    rocketTransform.position.x,
    rocketTransform.position.y,
    rocketTransform.position.z
  ), // m
  shape: new CANNON.Box(new CANNON.Vec3(2, 0.1, 2)), // m (Create sphere shaped body with a radius of 1)
})
rocketBody.material = boxMaterial // Add bouncy material to box body
world.addBody(rocketBody) // Add body to the world

const fixedTimeStep: number = 1.0 / 60.0 // seconds
const maxSubSteps: number = 3

class physicsUpdateSystem implements ISystem {
  update(dt: number): void {
    // Instruct the world to perform a single step of simulation.
    // It is generally best to keep the time step and iterations fixed.
    world.step(fixedTimeStep, dt, maxSubSteps)

    if (isFKeyPressed) {
      rocketBody.applyForce(
        new CANNON.Vec3(0, 1 * velocityScale, 0),
        new CANNON.Vec3(
          rocketBody.position.x,
          rocketBody.position.y,
          rocketBody.position.z
        )
      )
    }

    if (isEKeyPressed) {
      rocketBody.applyForce(
        new CANNON.Vec3(
          forwardVector.x * velocityScale,
          0,
          forwardVector.z * velocityScale
        ),
        new CANNON.Vec3(
          rocketBody.position.x,
          rocketBody.position.y,
          rocketBody.position.z
        )
      )
    }

    rocketBody.angularVelocity.setZero() // Prevents the board from rotating in any direction

    // Position the rocket board to match that of the rocket body that's affected by physics
    rocketBoard.getComponent(Transform).position.copyFrom(rocketBody.position)
    forwardVector = Vector3.Forward().rotate(Camera.instance.rotation) // Update forward vector to wherever the player is facing
  }
}

engine.addSystem(new physicsUpdateSystem())

// Controls (workaround to check if a button is pressed or not)
const input = Input.instance
let isEKeyPressed = false
let isFKeyPressed = false

// E Key
input.subscribe('BUTTON_DOWN', ActionButton.PRIMARY, false, () => {
  activateRocketBooster((isEKeyPressed = true))
})
input.subscribe('BUTTON_UP', ActionButton.PRIMARY, false, () => {
  isEKeyPressed = false
  if (!isFKeyPressed) {
    activateRocketBooster(false)
  }
})

// F Key
input.subscribe('BUTTON_DOWN', ActionButton.SECONDARY, false, () => {
  activateRocketBooster((isFKeyPressed = true))
})
input.subscribe('BUTTON_UP', ActionButton.SECONDARY, false, () => {
  isFKeyPressed = false
  if (!isEKeyPressed) {
    activateRocketBooster(false)
  }
})

// Activate booster animation
function activateRocketBooster(isOn: boolean) {
  if (isOn) {
    rocketBoosterSound.getComponent(AudioSource).playing = true
    rocketFlames.getComponent(Transform).scale.setAll(1)
  } else {
    rocketBoosterSound.getComponent(AudioSource).playing = false
    rocketFlames.getComponent(Transform).scale.setAll(0)
  }
}"
/* rocket board ring */,"import * as utils from '@dcl/ecs-scene-utils'
import { Sound } from './sound'

// Sound
const ringPass = new Sound(new AudioClip('sounds/ringPass.mp3'), false)

// Config
const EDGE_OFFSET = 6
const Y_OFFSET = 8
const GROUND_OFFSET = 10
const SCENE_SIZE = 65
const MAX_HEIGHT = 20

// Creates a ring that floats up and down continuously
export class Ring extends Entity {
  startPos: Vector3
  endPos: Vector3

  constructor(model: GLTFShape, startPos: Vector3, time: number) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Transform({ position: startPos }))
    this.startPos = startPos
    this.endPos = new Vector3(startPos.x, startPos.y + Y_OFFSET, startPos.z)

    this.addComponent(
      new utils.TriggerComponent(
        new utils.TriggerBoxShape(
          new Vector3(10, 8.5, 1),
          new Vector3(0, 1.2, 0)
        ),
        {
          onCameraExit: () => {
            // Randomly reposition the ring after player passes through the ring
            this.startPos = new Vector3(
              Math.random() * SCENE_SIZE + EDGE_OFFSET,
              Math.random() * MAX_HEIGHT + GROUND_OFFSET,
              Math.random() * SCENE_SIZE + EDGE_OFFSET
            )
            this.endPos = new Vector3(
              this.startPos.x,
              this.startPos.y + GROUND_OFFSET,
              this.startPos.z
            )
            ringPass.getComponent(AudioSource).playOnce()
          }
        }
      )
    )

    // Move the ring up and down between start and end positions
    this.addComponent(
      new utils.ToggleComponent(
        utils.ToggleState.Off,
        (value: utils.ToggleState) => {
          if (value === utils.ToggleState.On) {
            this.addComponentOrReplace(
              new utils.MoveTransformComponent(
                this.startPos,
                this.endPos,
                time,
                () => {
                  this.getComponent(utils.ToggleComponent).toggle()
                },
                utils.InterpolationType.EASEQUAD // Ease in and out
              )
            )
          } else {
            this.addComponentOrReplace(
              new utils.MoveTransformComponent(
                this.endPos,
                this.startPos,
                time,
                () => {
                  this.getComponent(utils.ToggleComponent).toggle()
                },
                utils.InterpolationType.EASEQUAD // Ease in and out
              )
            )
          }
        }
      )
    )
    this.getComponent(utils.ToggleComponent).toggle()
  }
}"
/* rocket board sound */ ,"export class Sound extends Entity {
  constructor(audio: AudioClip, loop: boolean) {
    super()
    engine.addEntity(this)
    this.addComponent(new AudioSource(audio))
    this.getComponent(AudioSource).loop = loop
    this.addComponent(new Transform())
    this.setParent(Attachable.AVATAR)
  }
}"
/* Create a bullet entity that moves in the direction of the player's gun */,"import * as utils from '@dcl/ecs-scene-utils'

export class Bullet extends Entity {
  constructor(model: GLTFShape, startPosition: Vector3, direction: Vector3) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Transform({ position: startPosition }))
    this.addComponent(new utils.MoveTransformComponent(direction, 20)) // Moves in the given direction at a speed of 20
    this.addComponent(new utils.ExpireIn(2000)) // Disappears after 2 seconds
  }
}"
/* shooting range bullet */,"import * as utils from '@dcl/ecs-scene-utils'

export class BulletMark extends Entity {
  constructor(model: GLTFShape, time?: number) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Transform())
    this.getComponent(Transform).rotate(Vector3.Forward(), Math.random() * 360) // Randomly rotate each bullet mark
    this.addComponent(new utils.ExpireIn(time * 1000)) // Disappears after x amount of seconds
  }
}"
/* shooting range game */,"import { Target } from './target'
import { BulletMark } from './bullet'
import { Score } from './score'
import * as utils from '@dcl/ecs-scene-utils'

// Base scene
const base = new Entity()
base.addComponent(new GLTFShape('models/baseLight.glb'))
engine.addEntity(base)

// Shooting area
const redMaterial = new Material()
redMaterial.albedoColor = Color3.Red()

const shootingArea = new Entity()
shootingArea.addComponent(new BoxShape())
shootingArea.addComponent(
  new Transform({
    position: new Vector3(8, 0.075, 2),
    scale: new Vector3(16, 0.05, 4)
  })
)
shootingArea.addComponent(redMaterial)
engine.addEntity(shootingArea)

// Create trigger for shooting area
const triggerBox = new utils.TriggerBoxShape(
  new Vector3(16, 16, 4),
  Vector3.Zero()
)

shootingArea.addComponent(
  new utils.TriggerComponent(triggerBox, {
    onCameraEnter: () => {
      isPlayerInShootingArea = true
      shootingArea.getComponent(Material).emissiveColor = Color3.Yellow()
    },
    onCameraExit: () => {
      isPlayerInShootingArea = false
      shootingArea.getComponent(Material).emissiveColor = Color3.Black()
    }
  })
)

// Cache bullet mark on load otherwise the first bullet mark won't appear instantly when fired
const bulletMarkShape = new GLTFShape('models/bulletMark.glb')
const bulletMarkCache = new BulletMark(bulletMarkShape)
bulletMarkCache.getComponent(Transform).scale.setAll(0)

// Setup targets
const targetShape = new GLTFShape('models/target.glb')
const NUM_OF_TARGETS = 3
let time = 9
let posZ = 7

for (let i = 0; i < NUM_OF_TARGETS; i++) {
  // Define two positions for toggling
  const startPosX = new Vector3(1, 1.5, posZ)
  const endPosX = new Vector3(14, 1.5, posZ)
  if (i % 2 === 0) {
    const target = new Target(targetShape, startPosX, endPosX, time)
  } else {
    const target = new Target(targetShape, endPosX, startPosX, time)
  }
  time -= 0.33
  posZ += 3
}

// Score
const scoreTen = new Score(
  new GLTFShape('models/scoreTen.glb'),
  new Transform()
)
const scoreTwentyFive = new Score(
  new GLTFShape('models/scoreTwentyFive.glb'),
  new Transform()
)
const scoreFifty = new Score(
  new GLTFShape('models/scoreFifty.glb'),
  new Transform()
)

// Sounds
const gunShot = new Entity()
gunShot.addComponent(new AudioSource(new AudioClip('sounds/shot.mp3')))
gunShot.addComponent(new Transform())
engine.addEntity(gunShot)
gunShot.setParent(Attachable.AVATAR)

const gunShotFail = new Entity()
gunShotFail.addComponent(new AudioSource(new AudioClip('sounds/shotFail.mp3')))
gunShotFail.addComponent(new Transform())
engine.addEntity(gunShotFail)
gunShotFail.setParent(Attachable.AVATAR)

// Controls
const input = Input.instance
const DELETE_TIME = 8 // In seconds
let isPlayerInShootingArea = false

input.subscribe('BUTTON_DOWN', ActionButton.POINTER, true, (e) => {
  if (isPlayerInShootingArea) {
    gunShot.getComponent(AudioSource).playOnce()
    if (engine.entities[e.hit.entityId] !== undefined) {
      // Calculate the position of where the bullet hits relative to the target
      const targetPosition =
        engine.entities[e.hit.entityId].getComponent(Transform).position
      const relativePosition = e.hit.hitPoint.subtract(targetPosition)
      const bulletMark = new BulletMark(bulletMarkShape, DELETE_TIME)
      bulletMark.setParent(engine.entities[e.hit.entityId]) // Make the bullet mark the child of the target so that it remains on the target
      bulletMark.getComponent(Transform).position = relativePosition
      score(e.hit.meshName, e.hit.hitPoint) // Play score animation
    }
  } else {
    gunShotFail.getComponent(AudioSource).playOnce()
  }
})

// Show the score corresponding to where the target was hit
function score(targetHit: string, targetPosition: Vector3): void {
  switch (targetHit) {
    case 'target10_collider':
      scoreTen.getComponent(Transform).position = targetPosition
      scoreTen.getComponent(Transform).position.z -= 0.5
      scoreTen.playAnimation()
      break
    case 'target25_collider':
      scoreTwentyFive.getComponent(Transform).position = targetPosition
      scoreTwentyFive.getComponent(Transform).position.z -= 0.5
      scoreTwentyFive.playAnimation()
      break
    case 'target50_collider':
      scoreFifty.getComponent(Transform).position = targetPosition
      scoreFifty.getComponent(Transform).position.z -= 0.5
      scoreFifty.playAnimation()
      break
  }
}"
/* shooting range score */,"@Component('scoreFlag')
export class ScoreFlag {}

export class Score extends Entity {
  constructor(model: GLTFShape, transform: Transform) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(transform)
    this.addComponent(new ScoreFlag())
    this.addComponent(new Animator())
    this.getComponent(Animator).addClip(
      new AnimationState('Pop', { looping: false })
    )
  }

  // Play the score's pop up animation
  public playAnimation(): void {
    this.getComponent(Transform).lookAt(Camera.instance.position)
    this.getComponent(Animator).getClip('Pop').stop() // Bug workaround
    this.getComponent(Animator).getClip('Pop').play()
  }
}

// Score faces the user to help with readability
class ScoreTrackUserSystem {
  scoreGroup = engine.getComponentGroup(ScoreFlag)
  update() {
    for (const entity of this.scoreGroup.entities) {
      const entityTransform = entity.getComponent(Transform)
      entityTransform.lookAt(Camera.instance.position)
    }
  }
}

engine.addSystem(new ScoreTrackUserSystem())"
/* shooting range target */,"import * as utils from '@dcl/ecs-scene-utils'

export class Target extends Entity {
  constructor(
    model: GLTFShape,
    startPos: Vector3,
    endPos: Vector3,
    time: number
  ) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Transform())

    // Move the targets back and forth between start and end positions
    this.addComponent(
      new utils.ToggleComponent(
        utils.ToggleState.Off,
        (value: utils.ToggleState) => {
          if (value === utils.ToggleState.On) {
            this.addComponentOrReplace(
              new utils.MoveTransformComponent(startPos, endPos, time, () => {
                this.getComponent(utils.ToggleComponent).toggle()
              })
            )
          } else {
            this.addComponentOrReplace(
              new utils.MoveTransformComponent(endPos, startPos, time, () => {
                this.getComponent(utils.ToggleComponent).toggle()
              })
            )
          }
        }
      )
    )
    this.getComponent(utils.ToggleComponent).toggle()
  }
}"
/* splat attack game */,"import { Splat } from ""./splat""

/*
 * Adapted from the grid sampling solution versino 4 to the total circles area problem.
 * link: https://rosettacode.org/wiki/Total_circles_area#Grid_Sampling_Version_4
 */

// Base
const base = new Entity()
base.addComponent(new GLTFShape(""models/baseDarkWithCollider.glb""))
base.addComponent(new Transform({ scale: new Vector3(2, 1, 2) }))
engine.addEntity(base)

// Maths
// NOTE: Alos works with any circle with an arbitrary radius
class Circle {
  constructor(public x: number, public y: number, public r: number) {}
}

const circles: Circle[] = []

const x_min_diffs: number[] = []
const x_max_diffs: number[] = []
const y_min_diffs: number[] = []
const y_max_diffs: number[] = []
const sample_size = 256

function calculateArea(): number {
  for (let c of circles) {
    x_min_diffs.push(c.x - c.r)
    x_max_diffs.push(c.x + c.r)
    y_min_diffs.push(c.y - c.r)
    y_max_diffs.push(c.y + c.r)
  }
  let x_min = Math.min(...x_min_diffs)
  let x_max = Math.max(...x_max_diffs)
  let y_min = Math.min(...y_min_diffs)
  let y_max = Math.max(...y_max_diffs)

  let dx = (x_max - x_min) / sample_size
  let dy = (y_max - y_min) / sample_size

  let count = 0

  // Range
  for (let r = 0; r < sample_size; r++) {
    let y = y_min + r * dy
    for (let c = 0; c < sample_size; c++) {
      let x = x_min + c * dx
      for (let i = 0; i < circles.length; i++) {
        if (Math.pow(x - circles[i].x, 2) + Math.pow(y - circles[i].y, 2) <= Math.pow(circles[i].r, 2)) {
          count += 1
          break
        }
      }
    }
  }
  let areaCovered = count * dx * dy
  return areaCovered
}

// Splat
const splatShape = new GLTFShape(""models/splat.glb"")
const splatCache = new Entity()
splatCache.addComponent(new Transform({ scale: new Vector3(0, 0, 0) }))
splatCache.addComponent(splatShape)
engine.addEntity(splatCache)

// Controls
const input = Input.instance
input.subscribe(""BUTTON_DOWN"", ActionButton.POINTER, true, (e) => {
  const splat = new Splat(splatShape, new Transform())
  let transform = splat.getComponent(Transform)
  transform.position.copyFrom(e.hit.hitPoint)
  circles.push(new Circle(transform.position.x, transform.position.z, 0.5))
})

// UI
const canvas = new UICanvas()
const text = new UIText(canvas)
text.adaptWidth = true
text.fontSize = 16
text.color = Color4.Teal()
text.value = ""Press 'E' to Calculate Area""

input.subscribe(""BUTTON_DOWN"", ActionButton.PRIMARY, false, () => {
  let areaCoveredText = calculateArea()
  if(areaCoveredText) {
    text.value = `Press 'E' to Recalculate\nArea Covered: ${areaCoveredText.toFixed(2)}mÂ²`
  } else {
    text.value = ""Press 'E' to Recalculate\nArea Covered: 0mÂ²""
  }
  log(""Calculating..."")
  log(`Approximated Area Covered: ${areaCoveredText}mÂ²`)
})"
/* splat attack splat */,"const sound = new Entity()
sound.addComponent(new Transform())
sound.getComponent(Transform).position = Camera.instance.position
sound.addComponent(new AudioSource(new AudioClip(""sounds/splat.mp3"")))
engine.addEntity(sound)

export class Splat extends Entity {
  constructor(model: GLTFShape, transform: Transform) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(transform)
    sound.getComponent(AudioSource).playOnce()
  }
}"
/* switchboard */,"import * as utils from '@dcl/ecs-scene-utils'

// Sound
const switchSound = new Entity()
switchSound.addComponent(new AudioSource(new AudioClip('sounds/switch.mp3')))
switchSound.addComponent(new Transform())
engine.addEntity(switchSound)
switchSound.setParent(Attachable.AVATAR)

export class Switchboard extends Entity {
  constructor(
    model: GLTFShape,
    startPos: Vector3,
    endPos: Vector3,
    public buttonA: Entity,
    public buttonB: Entity,
    public gears: Entity
  ) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Transform({ position: startPos }))

    // Parent button and gears to switchboard
    buttonA.setParent(this)
    buttonB.setParent(this)
    gears.setParent(this)

    // Trigger configurations
    const buttonTriggerA = new utils.TriggerBoxShape(
      new Vector3(2.75, 2.75, 2.75),
      new Vector3(1.5, 2, 0)
    )
    const buttonTriggerB = new utils.TriggerBoxShape(
      new Vector3(2.75, 2.75, 2.75),
      new Vector3(-1.5, 2, 0)
    )

    // Button triggers
    buttonA.addComponent(
      new utils.TriggerComponent(buttonTriggerA, {
        onCameraEnter: () => {
          this.movePlatform(-0.12, 0, -180, endPos)
        }
      })
    )

    buttonB.addComponent(
      new utils.TriggerComponent(buttonTriggerB, {
        onCameraEnter: () => {
          this.movePlatform(0, -0.12, 180, startPos)
        }
      })
    )
  }

  private movePlatform(
    buttonAPos: number,
    buttonBPos: number,
    rotationSpeed: number,
    targetPos: Vector3
  ) {
    switchSound.getComponent(AudioSource).playOnce()
    this.buttonA.getComponent(Transform).position.y = buttonAPos
    this.buttonB.getComponent(Transform).position.y = buttonBPos
    const currentPos = this.getComponent(Transform).position
    this.gears.addComponentOrReplace(
      new utils.KeepRotatingComponent(Quaternion.Euler(0, 0, rotationSpeed))
    )
    this.addComponentOrReplace(
      new utils.MoveTransformComponent(
        currentPos,
        targetPos,
        Math.abs(targetPos.x - currentPos.x) * 0.25,
        () => {
          // Reset buttons
          switchSound.getComponent(AudioSource).playOnce()
          this.buttonA.getComponent(Transform).position.y = 0
          this.buttonB.getComponent(Transform).position.y = 0
          this.gears.getComponent(utils.KeepRotatingComponent).stop()
        }
      )
    )
  }
}"
/* switchboard platform */,"import * as utils from '@dcl/ecs-scene-utils'
import { createCoin } from './coin'
import { Switchboard } from './switchboard'

// Base
const base = new Entity()
base.addComponent(new GLTFShape('models/baseLight.glb'))
base.addComponent(new Transform({ scale: new Vector3(2, 1, 1) }))
engine.addEntity(base)

// Platform and rails
const platforms = new Entity()
platforms.addComponent(new GLTFShape('models/platforms.glb'))
engine.addEntity(platforms)

// Coins
const coinShape = new GLTFShape('models/starCoin.glb') // Includes the spinning animation
const triggerBoxShape = new utils.TriggerBoxShape(
  new Vector3(1.5, 2.5, 1.5),
  new Vector3(0, 1, 0)
) // Trigger shape for coin
createCoin(
  coinShape,
  new Transform({ position: new Vector3(29, 6, 8) }),
  triggerBoxShape
)

// Switchboard
const buttonAShape = new GLTFShape('models/buttonA.glb')
const buttonBShape = new GLTFShape('models/buttonB.glb')

const buttonA = new Entity()
buttonA.addComponent(buttonAShape)
buttonA.addComponent(new Transform())

const buttonB = new Entity()
buttonB.addComponent(buttonBShape)
buttonB.addComponent(new Transform())

const gears = new Entity()
gears.addComponent(new GLTFShape('models/gears.glb'))
gears.addComponent(new Transform())

const switchboard = new Switchboard(
  new GLTFShape('models/switchboard.glb'),
  new Vector3(8, 3, 8),
  new Vector3(27, 3, 8),
  buttonA,
  buttonB,
  gears
)"
/* coin */,"import * as utils from '@dcl/ecs-scene-utils'

/**
 * Sound is a separated from the coin entity so that you can
 * still hear it even when the coin is removed from the engine.
 */
const coinPickupSound = new Entity()
coinPickupSound.addComponent(new Transform())
engine.addEntity(coinPickupSound)
coinPickupSound.setParent(Attachable.AVATAR)
coinPickupSound.addComponent(
  new AudioSource(new AudioClip('sounds/coinPickup.mp3'))
)
engine.addEntity(coinPickupSound)

export function createCoin(
  model: GLTFShape,
  transform: Transform,
  triggerShape: utils.TriggerBoxShape
): Entity {
  const entity = new Entity()
  engine.addEntity(entity)
  entity.addComponent(model)
  entity.addComponent(transform)

  // Create trigger for coin
  entity.addComponent(
    new utils.TriggerComponent(triggerShape, {
      onCameraEnter: () => {
        // Camera enter
        entity.getComponent(Transform).scale.setAll(0)
        coinPickupSound.getComponent(AudioSource).playOnce()
      },
      onCameraExit: () => {
        // Camera exit
        engine.removeEntity(entity)
      }
    })
  )
  return entity
}"
/* translocator */,"export class Translocator extends Entity {
  isFired: boolean = false
  blueGlow = new Entity()
  orangeGlow = new Entity()

  constructor(transform: Transform) {
    super()
    engine.addEntity(this)
    this.addComponent(new GLTFShape(""models/translocator.glb""))
    this.addComponent(transform)

    // Glow setup
    this.blueGlow.addComponent(new Transform())
    this.blueGlow.addComponent(new GLTFShape(""models/blueGlow.glb""))
    this.blueGlow.setParent(this)

    this.orangeGlow.addComponent(new Transform())
    this.orangeGlow.addComponent(new GLTFShape(""models/orangeGlow.glb""))
    this.orangeGlow.setParent(this)

    this.setGlow(false)
  }

  // Switches between the glows
  setGlow(isFired: boolean): void {
    if (isFired) {
      this.isFired = isFired
      this.blueGlow.getComponent(Transform).scale.setAll(0)
      this.orangeGlow.getComponent(Transform).scale.setAll(1)
    } else {
      this.isFired = isFired
      this.blueGlow.getComponent(Transform).scale.setAll(1)
      this.orangeGlow.getComponent(Transform).scale.setAll(0)
    }
  }
}"
/* teleport entity */,"export class Teleport extends Entity {
  constructor(model: GLTFShape) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Transform({ position: new Vector3(0, -0.5, 0) }))
    this.addComponent(new Animator())
    this.getComponent(Animator).addClip(new AnimationState(""Teleport"", { looping: false }))
    this.setParent(Attachable.AVATAR)
  }

  playAnimation() {
    this.getComponent(Animator).getClip(""Teleport"").stop() // Bug workaround
    this.getComponent(Animator).getClip(""Teleport"").play()
  }
}"
/* translocator sound */,"export class Sound extends Entity {
  constructor(audio: AudioClip) {
    super()
    engine.addEntity(this)
    this.addComponent(new AudioSource(audio))
    this.addComponent(new Transform())
    this.setParent(Attachable.FIRST_PERSON_CAMERA) // Play the sound wherever the player is standing
  }
}"
/* translocator game */,"import { Sound } from ""./sound""
import { Translocator } from ""./translocator""
import { Teleport } from ""./teleport""

// Create base scene
const base = new Entity()
base.addComponent(new GLTFShape(""models/baseLight.glb""))
base.addComponent(new Transform({ scale: new Vector3(3, 1, 3) }))
engine.addEntity(base)

// Teleport effect (not the actual translocator)
const teleport = new Teleport(new GLTFShape(""models/teleport.glb""))

// Translocator and setting
const X_OFFSET = 0
const Y_OFFSET = 0.5
const Z_OFFSET = 1

const translocator = new Translocator(new Transform({ position: new Vector3(X_OFFSET, Y_OFFSET, Z_OFFSET) }))
translocator.setParent(Attachable.FIRST_PERSON_CAMERA)

// Sounds
const teleportSound = new Sound(new AudioClip(""sounds/teleport.mp3""))
const shootSound = new Sound(new AudioClip(""sounds/shoot.mp3""))
const recallSound = new Sound(new AudioClip(""sounds/recall.mp3""))

// Setup our CANNON world
const world = new CANNON.World()
world.quatNormalizeSkip = 0
world.quatNormalizeFast = false
world.gravity.set(0, -9.82, 0) // m/sÂ²

const groundMaterial = new CANNON.Material(""groundMaterial"")
const groundContactMaterial = new CANNON.ContactMaterial(groundMaterial, groundMaterial, { friction: 0, restitution: 0.33 })
world.addContactMaterial(groundContactMaterial)

// Create a ground plane and apply physics material
const groundShape = new CANNON.Plane()
const groundBody = new CANNON.Body({ mass: 0 })
groundBody.addShape(groundShape)
groundBody.material = groundMaterial
groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2) // Reorient ground plane to be in the y-axis
world.addBody(groundBody)

// Invisible walls
//#region
const wallShape = new CANNON.Box(new CANNON.Vec3(24, 50, 0.5))
const wallNorth = new CANNON.Body({
  mass: 0,
  shape: wallShape,
  position: new CANNON.Vec3(24, 49.5, 48),
})
world.addBody(wallNorth)

const wallSouth = new CANNON.Body({
  mass: 0,
  shape: wallShape,
  position: new CANNON.Vec3(24, 49.5, 0),
})
world.addBody(wallSouth)

const wallEast = new CANNON.Body({
  mass: 0,
  shape: wallShape,
  position: new CANNON.Vec3(48, 49.5, 24),
})
wallEast.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2)
world.addBody(wallEast)

const wallWest = new CANNON.Body({
  mass: 0,
  shape: wallShape,
  position: new CANNON.Vec3(0, 49.5, 24),
})
wallWest.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2)
world.addBody(wallWest)
//#endregion

// Create translocator physics
let translocatorTransform = translocator.getComponent(Transform)

const translocatorBody: CANNON.Body = new CANNON.Body({
  mass: 3, // kg
  position: new CANNON.Vec3(translocatorTransform.position.x, translocatorTransform.position.y, translocatorTransform.position.z), // m
  shape: new CANNON.Sphere(0.2), // m (Create sphere shaped body with a radius of 0.2)
})

const translocatorPhysicsMaterial: CANNON.Material = new CANNON.Material(""translocatorMaterial"")
const translocatorPhysicsContactMaterial = new CANNON.ContactMaterial(groundMaterial, translocatorPhysicsMaterial, {
  friction: 0.0,
  restitution: 0.8,
})
world.addContactMaterial(translocatorPhysicsContactMaterial)

translocatorBody.material = translocatorPhysicsMaterial // Add bouncy material to translocator body
translocatorBody.linearDamping = 0.4 // Round bodies will keep translating even with friction so you need linearDamping
translocatorBody.angularDamping = 0.4 // Round bodies will keep rotating even with friction so you need angularDamping

world.addBody(translocatorBody) // Add body to the world

// Config
const SHOOT_VELOCITY = 100
const FIXED_TIME_STEPS = 1.0 / 60.0 // seconds
const MAX_TIME_STEPS = 3
const RECALL_SPEED = 10

// Intermediate variables
const player = Camera.instance
const transform = translocator.getComponent(Transform)

class shootDiscSystem implements ISystem {
  update(dt: number): void {
    if (translocator.isFired) {
      world.step(FIXED_TIME_STEPS, dt, MAX_TIME_STEPS)
      transform.position.copyFrom(translocatorBody.position)
    } else {
      engine.removeSystem(this)
    }
  }
}

// Recall translocator disc
class recallDiscSystem implements ISystem {
  update(dt: number): void {
    if (!translocator.isFired) {
      let playerForwardVector = transform.position.subtract(new Vector3(player.position.x, player.position.y - Y_OFFSET, player.position.z))
      let increment = playerForwardVector.scale(-dt * RECALL_SPEED)
      transform.translate(increment)
      let distance = Vector3.DistanceSquared(transform.position, player.position) // Check distance squared as it's more optimized
      // Note: Distance is squared so a value of 2 is when the translocator is ~1.4m away
      if (distance <= 2) {
        engine.removeSystem(this)
        resetDisc()
      }
    }
  }
}

// Controls
const input = Input.instance

// Shoot / recall translocator disc
input.subscribe(""BUTTON_DOWN"", ActionButton.POINTER, false, (e) => {
  if (!translocator.isFired) {
    engine.addSystem(new shootDiscSystem())
    shootSound.getComponent(AudioSource).playOnce()
    translocator.setGlow(true)
    translocator.setParent(null)

    let shootDirection = Vector3.Forward().rotate(Camera.instance.rotation) // Camera's forward vector
    translocatorBody.position.set(
      Camera.instance.feetPosition.x + shootDirection.x,
      shootDirection.y + Camera.instance.position.y,
      Camera.instance.feetPosition.z + shootDirection.z
    )

    // Shoot
    translocatorBody.applyImpulse(
      new CANNON.Vec3(shootDirection.x * SHOOT_VELOCITY, shootDirection.y * SHOOT_VELOCITY, shootDirection.z * SHOOT_VELOCITY),
      new CANNON.Vec3(translocatorBody.position.x, translocatorBody.position.y, translocatorBody.position.z)
    )
  } else {
    // Recall
    engine.addSystem(new recallDiscSystem())
    recallSound.getComponent(AudioSource).playOnce()
    translocator.setGlow(false)
  }
})

// Teleport with the E key
input.subscribe(""BUTTON_DOWN"", ActionButton.PRIMARY, false, (e) => {
  if (translocator.isFired) {
    translocator.setGlow(false)
    teleportSound.getComponent(AudioSource).playOnce()
    movePlayerTo(translocatorBody.position)
    resetDisc()
    teleport.playAnimation()
  }
})

function resetDisc(): void {
  translocatorBody.velocity.setZero()
  translocatorBody.angularVelocity.setZero()
  translocator.setParent(Attachable.FIRST_PERSON_CAMERA)
  translocator.getComponent(Transform).position.set(X_OFFSET, Y_OFFSET, Z_OFFSET)
}"
/* block portable experiences chests */,"import { hasWornPE, isWearingPE } from './peTracking'

export default class Chest extends Entity {
  openClip = new AudioClip('sounds/open.mp3')
  closeClip = new AudioClip('sounds/close.mp3')
  denyClip = new AudioClip('sounds/navigationBackward.mp3')
  open: boolean = false

  constructor(transform: TranformConstructorArgs) {
    super()
    engine.addEntity(this)
    this.addComponent(new Transform(transform))

    const animator = new Animator()
    const closeClip = new AnimationState('close', { looping: false })
    const openClip = new AnimationState('open', { looping: false })
    animator.addClip(closeClip)
    animator.addClip(openClip)
    this.addComponent(animator)

    this.addComponent(new GLTFShape('models/Chest_Pirates.glb'))

    this.addComponent(
      new OnPointerDown(
        () => {
          if (isWearingPE || hasWornPE) {
            log('CANT OPEN, CHEATER')
            const source = new AudioSource(this.denyClip)
            this.addComponentOrReplace(source)
            source.playing = true
            return
          }
          this.toggle(true)
        },
        {
          button: ActionButton.POINTER,
          hoverText: 'Open',
          distance: 6
        }
      )
    )
  }

  toggle(value?: boolean) {
    if (value && this.open === value) return

    //sound
    const source = new AudioSource(value ? this.openClip : this.closeClip)
    this.addComponentOrReplace(source)
    source.playing = true

    //animation
    const animator = this.getComponent(Animator)
    const openClip = animator.getClip('open')
    const closeClip = animator.getClip('close')
    openClip.stop()
    closeClip.stop()
    const clip = value ? openClip : closeClip
    clip.play()

    this.open = value
  }
}"
/* a class bullet that shoots bullets in the game */,"export class Bullet extends Entity {
  constructor(model: GLTFShape, position: Vector3, direction: Vector3, speed: number) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Transform({ position: position }))
    this.move(direction, speed)
    this.setParent(scene)
  }

  move(direction: Vector3, speed: number) {
    this.addComponent(new BulletBehavior(direction, speed))
  }
}
"
"/* create a new class ""Enemy"" that spawns enemies in a game */","export class Enemy extends Entity {
  constructor(model: GLTFShape, position: Vector3) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Transform({ position: position }))
    this.addComponent(new Animator())
    this.getComponent(Animator).addClip(new AnimationState(""Spawn"", { looping: false }))
    this.setParent(scene)
  }

  spawn() {
    this.getComponent(Animator).getClip(""Spawn"").stop() // Bug workaround
    this.getComponent(Animator).getClip(""Spawn"").play()
  }
}
"
/* block portable experiences denyUI*/,"const canvas = new UICanvas()

const denyTexture = new Texture('images/no-sign.png')

const denyImage = new UIImage(canvas, denyTexture)
denyImage.hAlign = 'center'
denyImage.vAlign = 'center'
denyImage.positionX = 0
denyImage.positionY = 0
denyImage.width = 256
denyImage.height = 256
denyImage.sourceLeft = 0
denyImage.sourceTop = 0
denyImage.sourceWidth = 512
denyImage.sourceHeight = 512
denyImage.isPointerBlocker = false
denyImage.visible = false

const denyCaption = new UIText(canvas)
denyCaption.hAlign = 'center'
denyCaption.vAlign = 'center'
denyCaption.hTextAlign = 'center'
denyCaption.positionX = 0
denyCaption.positionY = -170
denyCaption.fontSize = 20
denyCaption.isPointerBlocker = false
denyCaption.visible = false
denyCaption.value =
  'This scene does not allow smart wearables.\nTake them off, then step out and back in.'

export function showDenyUI() {
  denyImage.visible = true
  denyCaption.visible = true
}

export function hideDenyUI() {
  denyImage.visible = false
  denyCaption.visible = false
}"
/* block portable experiences game */,"import Chest from './chest'
import { addPlatforms } from './platforms'

addPlatforms()

const treasureChest = new Chest({
  position: new Vector3(6.5, 5, 7.5),
  rotation: new Quaternion(0, 0, 0, 1),
  scale: new Vector3(1, 1, 1)
})"
/* block portable experiences peTracking */,"import { getPortableExperiencesLoaded } from '@decentraland/PortableExperiences'
import { getUserData } from '@decentraland/Identity'
import { hideDenyUI, showDenyUI } from './denyUI'

export let isWearingPE: boolean = false
export let hasWornPE: boolean = false

function checkPortableExperiences() {
  getPortableExperiencesLoaded()
    .then((data) => {
      log('PORTABLE EXPERIENCES: ', data.portableExperiences)
      if (data.portableExperiences && data.portableExperiences.length > 0) {
        isWearingPE = true
        hasWornPE = true
        showDenyUI()
      } else {
        isWearingPE = false
      }
    })
    .catch((error) => log(error))
}

// check when first loading
checkPortableExperiences()

// check when changing avatar
onProfileChanged.add((profileData) => {
  log('Own profile data is ', profileData)
  checkPortableExperiences()
})

// check when entering scene
getUserData()
  .then((myPlayer) => {
    onEnterSceneObservable.add(async (player) => {
      log('player entered scene: ', player.userId)
      if (player.userId === myPlayer?.userId) {
        log('I entered the scene!')
        await checkPortableExperiences()

        if (!isWearingPE) {
          hasWornPE = false
        }

        if (hasWornPE || isWearingPE) {
          showDenyUI()
        }
      }
    })

    onLeaveSceneObservable.add((player) => {
      log('player left scene: ', player.userId)
      if (player.userId === myPlayer?.userId) {
        log('I left the scene!')
        hideDenyUI()
      }
    })
  })
  .catch((error) => log(error))"
/* block portable experiences platforms */,"export function addPlatforms() {
  const _scene = new Entity('_scene')
  engine.addEntity(_scene)
  const transform = new Transform({
    position: new Vector3(0, 0, 0),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1, 1, 1)
  })
  _scene.addComponentOrReplace(transform)

  const bermudaGrass = new Entity('bermudaGrass')
  engine.addEntity(bermudaGrass)
  bermudaGrass.setParent(_scene)
  const gltfShape = new GLTFShape('models/FloorBaseGrass_01.glb')
  gltfShape.withCollisions = true
  gltfShape.isPointerBlocker = true
  gltfShape.visible = true
  bermudaGrass.addComponentOrReplace(gltfShape)
  const transform2 = new Transform({
    position: new Vector3(8, 0, 8),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1, 1, 1)
  })
  bermudaGrass.addComponentOrReplace(transform2)

  const dirtGrass = new Entity('dirtGrass')
  engine.addEntity(dirtGrass)
  dirtGrass.setParent(_scene)
  const transform3 = new Transform({
    position: new Vector3(8.5, 4, 11.5),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1, 1, 1)
  })
  dirtGrass.addComponentOrReplace(transform3)
  const gltfShape2 = new GLTFShape('models/dirt_grass.glb')
  gltfShape2.withCollisions = true
  gltfShape2.isPointerBlocker = true
  gltfShape2.visible = true
  dirtGrass.addComponentOrReplace(gltfShape2)

  const dirtGrass3 = new Entity('dirtGrass3')
  engine.addEntity(dirtGrass3)
  dirtGrass3.setParent(_scene)
  const transform4 = new Transform({
    position: new Vector3(3.5, 0, 3),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1, 1, 1)
  })
  dirtGrass3.addComponentOrReplace(transform4)
  dirtGrass3.addComponentOrReplace(gltfShape2)

  const dirtGrass4 = new Entity('dirtGrass4')
  engine.addEntity(dirtGrass4)
  dirtGrass4.setParent(_scene)
  const transform5 = new Transform({
    position: new Vector3(2.5, 1, 7),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1, 1, 1)
  })
  dirtGrass4.addComponentOrReplace(transform5)
  dirtGrass4.addComponentOrReplace(gltfShape2)

  const dirtGrass5 = new Entity('dirtGrass5')
  engine.addEntity(dirtGrass5)
  dirtGrass5.setParent(_scene)
  const transform6 = new Transform({
    position: new Vector3(2.5, 2, 11),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1, 1, 1)
  })
  dirtGrass5.addComponentOrReplace(transform6)
  dirtGrass5.addComponentOrReplace(gltfShape2)

  const dirtGrass6 = new Entity('dirtGrass6')
  engine.addEntity(dirtGrass6)
  dirtGrass6.setParent(_scene)
  const transform7 = new Transform({
    position: new Vector3(4.5, 3, 13.5),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1, 1, 1)
  })
  dirtGrass6.addComponentOrReplace(transform7)
  dirtGrass6.addComponentOrReplace(gltfShape2)

  const dirtGrass7 = new Entity('dirtGrass7')
  engine.addEntity(dirtGrass7)
  dirtGrass7.setParent(_scene)
  const transform8 = new Transform({
    position: new Vector3(7.5, 3.5, 13),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1, 1, 1)
  })
  dirtGrass7.addComponentOrReplace(transform8)
  dirtGrass7.addComponentOrReplace(gltfShape2)

  const solidYellow = new Entity('solidYellow')
  engine.addEntity(solidYellow)
  solidYellow.setParent(_scene)
  const transform9 = new Transform({
    position: new Vector3(6.5, 0, 8.5),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(5, 5, 5)
  })
  solidYellow.addComponentOrReplace(transform9)
  const gltfShape3 = new GLTFShape('models/solid_yellow.glb')
  gltfShape3.withCollisions = true
  gltfShape3.isPointerBlocker = true
  gltfShape3.visible = true
  solidYellow.addComponentOrReplace(gltfShape3)
}"
/* video streaming */ ,"// Base
const base = new Entity()
base.addComponent(new GLTFShape('models/baseDarkWithCollider.glb'))
base.addComponent(new Transform({ scale: new Vector3(2, 1, 2) }))
engine.addEntity(base)

// Seating
const seat = new Entity()
seat.addComponent(new GLTFShape('models/seats.glb'))
seat.addComponent(new Transform({ position: new Vector3(16, 0.05, 10) }))
engine.addEntity(seat)

const screenBody = new Entity()
screenBody.addComponent(new GLTFShape('models/screen.glb'))
screenBody.addComponent(new Transform({ position: new Vector3(16, 0.05, 16) }))
engine.addEntity(screenBody)

// Screen
const screenTransform = new Entity()
screenTransform.addComponent(
  new Transform({ position: new Vector3(0, 6.15, 5) })
)
screenTransform.getComponent(Transform).rotate(Vector3.Right(), -15)
screenTransform.setParent(screenBody)

const screen = new Entity()
screen.addComponent(new PlaneShape())
screen.addComponent(new Transform({ scale: new Vector3(19.2, 10.8, 1) }))
screen.getComponent(Transform).rotate(Vector3.Up(), 180)
screen.setParent(screenTransform)

screenTransform.getComponent(Transform).scale.setAll(0.625) // You can change the scale of the screen here...

// Video stream link from Vimeo
const videoClip = new VideoClip(
  'https://player.vimeo.com/external/552481870.m3u8?s=c312c8533f97e808fccc92b0510b085c8122a875'
)
const videoTexture = new VideoTexture(videoClip)
videoTexture.play()
videoTexture.loop = true

// Adjust screen material to increase the brightness and clarity
const screenMaterial = new Material()
screenMaterial.albedoTexture = videoTexture
screenMaterial.emissiveTexture = videoTexture
screenMaterial.emissiveColor = Color3.White()
screenMaterial.emissiveIntensity = 0.6
screenMaterial.roughness = 1.0
screen.addComponent(screenMaterial)"
/* cannon balls */,"export class Ball extends Entity {
  constructor(model: GLTFShape, transform: Transform) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(transform)
  }
}"
/* cannon game */,"/*
  IMPORTANT: The tsconfig.json has been configured to include ""node_modules/cannon/build/cannon.js""
*/
import { Ball } from './ball'
import { loadColliders } from './wallCollidersSetup'

// Create base scene
const baseScene: Entity = new Entity()
baseScene.addComponent(new GLTFShape('models/baseScene.glb'))
baseScene.addComponent(new Transform())
engine.addEntity(baseScene)

// Ball shapes
const ballShapes: GLTFShape[] = [
  new GLTFShape('models/redBall.glb'),
  new GLTFShape('models/greenBall.glb'),
  new GLTFShape('models/blueBall.glb'),
  new GLTFShape('models/pinkBall.glb'),
  new GLTFShape('models/yellowBall.glb')
]

const balls: Ball[] = [] // Store balls
const ballBodies: CANNON.Body[] = [] // Store ball bodies
let ballHeight = 12 // Start height for the balls
let forwardVector: Vector3 = Vector3.Forward().rotate(Camera.instance.rotation) // Camera's forward vector
const vectorScale: number = 25

// Create random balls and positions
for (let i = 0; i < ballShapes.length; i++) {
  const randomPositionX: number = Math.floor(Math.random() * 3) + 14
  const randomPositionY: number = ballHeight
  const randomPositionZ: number = Math.floor(Math.random() * 3) + 14

  const ball = new Ball(
    ballShapes[i],
    new Transform({
      position: new Vector3(randomPositionX, randomPositionY, randomPositionZ)
    })
  )
  balls.push(ball)
  ballHeight += 2 // To ensure the colliders aren't intersecting when the simulation starts

  // Allow the user to interact with the ball
  ball.addComponent(
    new OnPointerDown(
      (e) => {
        // Apply impulse based on the direction of the camera
        ballBodies[i].applyImpulse(
          new CANNON.Vec3(
            forwardVector.x * vectorScale,
            forwardVector.y * vectorScale,
            forwardVector.z * vectorScale
          ),
          // Applies impulse based on the player's position and where they click on the ball
          new CANNON.Vec3(e.hit.hitPoint.x, e.hit.hitPoint.y, e.hit.hitPoint.z)
        )
      },
      {
        button: ActionButton.ANY,
        showFeedback: true,
        hoverText: 'kick'
      }
    )
  )
}

// Setup our world
const world: CANNON.World = new CANNON.World()
world.gravity.set(0, -9.82, 0) // m/sÂ²

// Add invisible colliders
loadColliders(world)

const groundPhysicsMaterial = new CANNON.Material('groundMaterial')
const groundPhysicsContactMaterial = new CANNON.ContactMaterial(
  groundPhysicsMaterial,
  groundPhysicsMaterial,
  {
    friction: 0.5,
    restitution: 0.33
  }
)
world.addContactMaterial(groundPhysicsContactMaterial)

// Create a ground plane and apply physics material
const groundBody: CANNON.Body = new CANNON.Body({
  mass: 0 // mass === 0 makes the body static
})
groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2) // Reorient ground plane to be in the y-axis

const groundShape: CANNON.Plane = new CANNON.Plane()
groundBody.addShape(groundShape)
groundBody.material = groundPhysicsMaterial
world.addBody(groundBody)

const ballPhysicsMaterial: CANNON.Material = new CANNON.Material('ballMaterial')
const ballPhysicsContactMaterial = new CANNON.ContactMaterial(
  groundPhysicsMaterial,
  ballPhysicsMaterial,
  {
    friction: 0.4,
    restitution: 0.75
  }
)
world.addContactMaterial(ballPhysicsContactMaterial)

// Create bodies to represent each of the balls
for (let i = 0; i < balls.length; i++) {
  const ballTransform: Transform = balls[i].getComponent(Transform)

  const ballBody: CANNON.Body = new CANNON.Body({
    mass: 5, // kg
    position: new CANNON.Vec3(
      ballTransform.position.x,
      ballTransform.position.y,
      ballTransform.position.z
    ), // m
    shape: new CANNON.Sphere(1) // m (Create sphere shaped body with a radius of 1)
  })

  ballBody.material = ballPhysicsMaterial // Add bouncy material to ball body
  ballBody.linearDamping = 0.4 // Round will keep translating even with friction so you need linearDamping
  ballBody.angularDamping = 0.4 // Round bodies will keep rotating even with friction so you need angularDamping

  world.addBody(ballBody) // Add body to the world
  ballBodies.push(ballBody)
}

const fixedTimeStep: number = 1.0 / 60.0 // seconds
const maxSubSteps: number = 3

class updateSystem implements ISystem {
  update(dt: number): void {
    // Instruct the world to perform a single step of simulation.
    // It is generally best to keep the time step and iterations fixed.
    world.step(fixedTimeStep, dt, maxSubSteps)

    // Position and rotate the balls in the scene to match their cannon world counterparts
    for (let i = 0; i < balls.length; i++) {
      balls[i].getComponent(Transform).position.copyFrom(ballBodies[i].position)
      balls[i]
        .getComponent(Transform)
        .rotation.copyFrom(ballBodies[i].quaternion)
    }

    // Update forward vector
    forwardVector = Vector3.Forward().rotate(Camera.instance.rotation)
    log('Forward Vector: ', forwardVector)
  }
}

engine.addSystem(new updateSystem())"
/* cannon wall collider setup */,"export function loadColliders(world: CANNON.World): void {
  // Invisible walls
  const wallShape = new CANNON.Box(new CANNON.Vec3(16, 32, 1))
  const wallNorth = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(16, 0, 32)
  })
  world.addBody(wallNorth)

  const wallSouth = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(16, 0, 0)
  })
  world.addBody(wallSouth)

  const wallWest = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(0, 0, 16)
  })
  wallWest.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2)
  world.addBody(wallWest)

  const wallEast = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(32, 0, 16)
  })
  wallEast.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2)
  world.addBody(wallEast)
}"
/* digital bouncer game */,"import { initiateVJUI } from './bouncerUI'

initiateVJUI().catch((error) => log(error))

// ground
const bermudaGrass = new Entity('bermudaGrass')
bermudaGrass.addComponentOrReplace(
  new GLTFShape('models/FloorBaseGrass_01/FloorBaseGrass_01.glb')
)
bermudaGrass.addComponentOrReplace(
  new Transform({
    position: new Vector3(8, 0, 8),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1, 1, 1)
  })
)
engine.addEntity(bermudaGrass)

// building
const shopEmissive = new Entity('shopEmissive')
shopEmissive.addComponentOrReplace(
  new Transform({
    position: new Vector3(9.5, 0, 8),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1, 1, 1)
  })
)
shopEmissive.addComponentOrReplace(new GLTFShape('models/Shop_Emissive.glb'))
engine.addEntity(shopEmissive)"
/* digital bouncer BouncerUI */,"import * as ui from '@dcl/ui-scene-utils'
import { getUserData, UserData } from '@decentraland/Identity'
import { isPreviewMode } from '@decentraland/EnvironmentAPI'

import { movePlayerTo } from '@decentraland/RestrictedActions'

export let userData: UserData

export async function fetchUserData() {
  const data = await getUserData()
  if (data) {
    log(data.displayName)
  }
  return data
}

export async function setUserData() {
  const data = await getUserData()
  if (data) {
    log(data.displayName)
    userData = data
  }
}

export const allowListedIds = ['SceneAdmin', 'ToonPunk']

export const sceneMessageBus = new MessageBus()

let announceUI: ui.FillInPrompt

let bouncerUI: ui.FillInPrompt

export async function initiateVJUI() {
  if (!userData) {
    await setUserData()
  }

  let authorized = false

  if (await isPreviewMode()) {
    authorized = true
  } else {
    for (const id of allowListedIds) {
      if (userData && id === userData.displayName) {
        authorized = true
        break
      }
    }
  }

  if (authorized) {
    announceUI = new ui.FillInPrompt(
      'Announcements',
      (e: string) => {
        sceneMessageBus.emit('announcement', {
          text: e
        })
      },
      'Send',
      'Announcement',
      true
    )
    announceUI.hide()

    bouncerUI = new ui.FillInPrompt(
      'Digital Bouncer',
      (e: string) => {
        sceneMessageBus.emit('kick', {
          player: e
        })
      },
      'Kick',
      'player name',
      true
    )
    bouncerUI.hide()

    Input.instance.subscribe(
      'BUTTON_DOWN',
      ActionButton.PRIMARY,
      false,
      (e) => {
        if (announceUI) {
          if (!announceUI.background.visible) {
            announceUI.show()
          } else {
            announceUI.hide()
          }
        }
      }
    )

    Input.instance.subscribe(
      'BUTTON_DOWN',
      ActionButton.SECONDARY,
      false,
      (e) => {
        if (bouncerUI) {
          if (!bouncerUI.background.visible) {
            bouncerUI.show()
          } else {
            bouncerUI.hide()
          }
        }
      }
    )
  }
}

sceneMessageBus.on('announcement', (e) => {
  ui.displayAnnouncement(e.text)
})

sceneMessageBus.on('kick', async (_e) => {
  if (!userData) {
    await setUserData()
  }

  if (e.player === userData.displayName) {
    movePlayerTo({ x: 0, y: 5, z: 0 }).catch((error) => log(error))
  }
})"
/* POAP Booth game */,"import { createDispenser } from './booth/dispenser'

createDispenser(
  {
    position: new Vector3(8, 0, 8),
    rotation: Quaternion.Euler(0, 0, 0)
  },
  'acd27e4b-24bd-4040-b715-c0e11e863fb0'
)"
/* POAP Booth dispenser */,"import * as utils from '@dcl/ecs-scene-utils'
import * as UI from '@dcl/ui-scene-utils'
import * as boothUI from './ui'

import { getUserData, UserData } from '@decentraland/Identity'
import { getCurrentRealm, Realm } from '@decentraland/EnvironmentAPI'
import { PlayCloseSound } from './sounds'
import { signedFetch } from '@decentraland/SignedFetch'

export const sceneMessageBus = new MessageBus()
const timeDelay = 5 * 60 * 1000 // Delay before being able to claim a POAP in milliseconds

/**
 *
 * @param {TranformConstructorArgs} transform position, rotation and scale of the booth
 * @param {string} poapServer server to use
 * @param {string} eventUUID ID of the event
 *
 */
export function createDispenser(
  transform: TranformConstructorArgs,
  eventUUID: string,
  poapServer?: string
) {
  const createdTime = new Date()
  const serverURL: string = poapServer
    ? poapServer
    : 'poap-api.decentraland.org'

  let alreadyAttempted: boolean = false

  const entity = new Entity()
  engine.addEntity(entity)
  eventUUID = eventUUID

  entity.addComponent(new GLTFShape('models/poap/POAP_dispenser.glb'))
  entity.addComponent(new Transform(transform))

  const idleAnim = new AnimationState('Idle_POAP', { looping: true })
  entity.addComponent(new Animator())
  entity.getComponent(Animator).addClip(idleAnim)
  entity
    .getComponent(Animator)
    .addClip(new AnimationState('Action_POAP', { looping: false }))
  idleAnim.play()

  const button = new Entity()
  button.addComponent(new GLTFShape('models/poap/POAP_button.glb'))
  button.addComponent(new Animator())
  button
    .getComponent(Animator)
    .addClip(new AnimationState('Button_Action', { looping: false }))
  button.setParent(entity)
  button.addComponent(
    new OnPointerDown(
      (_e) => {
        button.getComponent(Animator).getClip('Button_Action').play()
        //sceneMessageBus.emit('activatePoap', {})
        void makeTransaction()
      },
      { hoverText: 'Get Attendance Token' }
    )
  )
  engine.addEntity(button)

  sceneMessageBus.on('activatePoap', () => {
    activate()
  })

  function activate(): void {
    const anim = entity.getComponent(Animator)

    anim.getClip('Action_POAP').play()

    entity.addComponentOrReplace(
      new utils.Delay(4000, () => {
        anim.getClip('Action_POAP').stop()

        anim.getClip('Idle_POAP').play()
      })
    )
  }

  async function getCaptcha(): Promise<string> {
    const captchaUUIDQuery = await signedFetch(`https://${serverURL}/captcha`, {
      method: 'POST'
    })
    const json = JSON.parse(captchaUUIDQuery.text)
    return json.data.uuid
  }

  async function makeTransaction() {
    const userData = await getUserData()

    // no wallet
    if (!userData || !userData.hasConnectedWeb3) {
      log('no wallet')
      PlayCloseSound()

      boothUI.metamask()
      return
    }

    // 5 minutes timer before claiming
    if (+createdTime > +new Date() - timeDelay) {
      PlayCloseSound()
      boothUI.timerBeforeClaim(createdTime, timeDelay)
      return
    }

    if (alreadyAttempted) {
      // already attempted
      PlayCloseSound()
      boothUI.alreadyClaimed()
      return
    }

    alreadyAttempted = true
    const realm = await getCurrentRealm()

    try {
      const captchaUUID = await getCaptcha()
      const captchaResult = await boothUI.captcha(serverURL, captchaUUID)
      if (captchaResult === undefined) {
        alreadyAttempted = false
        return
      }
      const response = await claimCall(captchaResult, userData, realm)
      log(response)
      log(response.status)
      const json = await response.json()
      log(json)
      if (response.status === 200) {
        boothUI.viewSuccessMessage(
          json.data.event.name,
          json.data.event.image_url,
          1024,
          1024
        )

        sceneMessageBus.emit('activatePoap', {})
      } else {
        PlayCloseSound()
        switch (json.error) {
          case 'Address already claimed a code for this event':
            UI.displayAnnouncement(`You already claimed this event`, 3)

            break

          default:
            alreadyAttempted = false
            UI.displayAnnouncement(
              `Oops, there was an error: ""${json.error}""`,
              3
            )
            break
        }
      }
    } catch {
      alreadyAttempted = false
      log('Error fetching from POAP server ', serverURL)
    }

    return
  }

  async function claimCall(
    captchaResult: string,
    userData: UserData,
    realm: Realm
  ) {
    const response = await fetch(`https://${serverURL}/claim/${eventUUID}`, {
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      body: JSON.stringify({
        address: userData.publicKey,
        catalyst: realm.domain,
        room: realm.room,
        captcha: captchaResult
      })
    })
    return response
  }

  return entity
}"
/* POAP Booth ui */,"import * as utils from '@dcl/ecs-scene-utils'
import * as UI from '@dcl/ui-scene-utils'
import { PlayCloseSound, PlayCoinSound } from './sounds'

export function timerBeforeClaim(createdTime: Date, delay: number) {
  const mmPrompt = new UI.CustomPrompt(undefined, 450, 200)
  const timeRemaining = (+new Date() + delay - +createdTime) / 1000
  log(timeRemaining)
  const minutes = Math.floor(timeRemaining / 60)
  const seconds = Math.floor(timeRemaining - minutes * 60)
  mmPrompt.addText(
    `You need to wait \n${
      minutes ? `${minutes} minutes${seconds > 0 ? ' and ' : ''}` : ''
    }${seconds ? `${seconds} seconds` : ''}\nbefore claiming this POAP`,
    0,
    0,
    Color4.Black(),
    20
  )
}

/* UI asking to install metamask */
export function metamask() {
  const mmPrompt = new UI.CustomPrompt()

  mmPrompt.addText(
    'A MetaMask Digital wallet\nis required to claim this token.',
    0,
    25,
    Color4.Black(),
    20
  )
  mmPrompt.addButton(
    'Get MetaMask',
    -100,
    -100,
    () => {
      openExternalURL('https://metamask.io/')
    },
    UI.ButtonStyles.RED
  )

  mmPrompt.addButton(
    'Cancel',
    100,
    -100,
    () => {
      PlayCloseSound()
      mmPrompt.hide()
    },
    UI.ButtonStyles.F
  )
}

/* UI asking for captcha solution */
export async function captcha(
  serverURL: string,
  captchaUUID: string
): Promise<string | undefined> {
  return new Promise((resolve) => {
    const captchaUI = new UI.CustomPrompt('dark', 600, 370)
    captchaUI.addText(
      'Please complete this captcha',
      0,
      160,
      Color4.White(),
      24
    )
    captchaUI.addIcon(
      `https://${serverURL}/captcha/${captchaUUID}`,
      0,
      40,
      500,
      150,
      { sourceHeight: 0, sourceWidth: 0 }
    )
    let captchaCode = ''
    captchaUI.addTextBox(0, -75, '', (e) => {
      captchaCode = e
    })
    captchaUI.addButton(
      'Submit',
      100,
      -140,
      () => {
        captchaUI.hide()
        resolve(captchaCode)
      },
      UI.ButtonStyles.ROUNDGOLD
    )
    captchaUI.addButton(
      'Cancel',
      -100,
      -140,
      () => {
        captchaUI.hide()
        resolve(undefined)
      },
      UI.ButtonStyles.ROUNDBLACK
    )
  })
}

export function alreadyClaimed() {
  const prompt = new UI.CustomPrompt()
  prompt.addText('Already attempted', 0, 120, Color4.Red(), 24)

  prompt.addText(
    ""You've already requested to\nclaim this POAP token."",
    0,
    50,
    Color4.Black(),
    22
  )

  prompt.addButton(
    'See my POAPs',
    -100,
    -100,
    () => {
      openExternalURL('https://app.poap.xyz')
    },
    UI.ButtonStyles.DARK
  )

  prompt.addButton(
    'Ok',
    100,
    -100,
    () => {
      prompt.hide()
      PlayCloseSound()
    },
    UI.ButtonStyles.E
  )
}

export function viewSuccessMessage(
  poapName: string,
  image: string,
  imageSizeX: number,
  imageSizeY: number
) {
  PlayCoinSound()
  const thumbTexture = new Texture(image, { hasAlpha: true })

  const name = new UIText(UI.canvas)
  name.value = poapName
  name.color = Color4.Yellow()
  name.outlineColor = Color4.Black()
  name.outlineWidth = 0.1
  name.positionY = -85
  name.visible = true
  name.fontSize = 30
  name.hTextAlign = 'center'
  name.hAlign = 'center'

  const thumb = new UIImage(UI.canvas, thumbTexture)
  thumb.hAlign = 'center'
  thumb.vAlign = 'center'
  thumb.positionY = 90
  thumb.width = 256
  thumb.height = 256
  thumb.sourceLeft = 0
  thumb.sourceTop = 0
  thumb.sourceHeight = imageSizeY
  thumb.sourceWidth = imageSizeX
  thumb.visible = true

  const note = new UIText(UI.canvas)
  note.value = 'This POAP token is being sent to your wallet'
  note.color = Color4.Black()
  note.positionY = -128
  note.visible = true
  note.fontSize = 30
  note.hTextAlign = 'center'
  note.hAlign = 'center'

  utils.setTimeout(7000, () => {
    name.visible = false
    thumb.visible = false
    note.visible = false
  })
}"
/* POAP Booth sounds */,"// Open dialog sound
export const openDialogSound = new Entity()
openDialogSound.addComponent(new Transform())
openDialogSound.addComponent(
  new AudioSource(new AudioClip('sounds/navigationForward.mp3'))
)
openDialogSound.getComponent(AudioSource).volume = 0.5
engine.addEntity(openDialogSound)
openDialogSound.setParent(Attachable.AVATAR)

// Close dialog sound
export const closeDialogSound = new Entity()
closeDialogSound.addComponent(new Transform())
closeDialogSound.addComponent(
  new AudioSource(new AudioClip('sounds/navigationBackward.mp3'))
)
closeDialogSound.getComponent(AudioSource).volume = 0.5
engine.addEntity(closeDialogSound)
closeDialogSound.setParent(Attachable.AVATAR)

export const coinSound = new Entity()
coinSound.addComponent(new Transform())
coinSound.addComponent(
  new AudioSource(new AudioClip('sounds/star-collect.mp3'))
)
coinSound.getComponent(AudioSource).volume = 0.5
coinSound.getComponent(AudioSource).loop = false
engine.addEntity(coinSound)
coinSound.setParent(Attachable.AVATAR)

export function PlayOpenSound() {
  openDialogSound.getComponent(AudioSource).playOnce()
}

export function PlayCloseSound() {
  closeDialogSound.getComponent(AudioSource).playOnce()
}

export function PlayCoinSound() {
  coinSound.getComponent(AudioSource).playOnce()
}"
/* green screen */,"//Shapes
let planeShape1 = new PlaneShape()
planeShape1.withCollisions = false

let buttonShape = new SphereShape()



//Materials
let greenMat = new BasicMaterial()
greenMat.texture = new Texture(""images/green.png"")

let blueMat = new BasicMaterial()
blueMat.texture = new Texture(""images/blue.png"")

let redMat = new BasicMaterial()
redMat.texture = new Texture(""images/red.png"")

let yellowMat = new BasicMaterial()
yellowMat.texture = new Texture(""images/yellow.png"")

let whiteMat = new BasicMaterial()
whiteMat.texture = new Texture(""images/white.png"")

let blackMat = new BasicMaterial()
blackMat.texture = new Texture(""images/black.png"")

let greyMat = new BasicMaterial()
greyMat.texture = new Texture(""images/grey.png"")

let orangeMat = new BasicMaterial()
orangeMat.texture = new Texture(""images/orange.png"")

let purpleMat = new BasicMaterial()
purpleMat.texture = new Texture(""images/purple.png"")



//Walls
const floorPlane = new Entity()
floorPlane.addComponent(new Transform({position: new Vector3(8,0,8), scale: new Vector3(16,16,16), rotation:Quaternion.Euler(90,0,0)}))
floorPlane.addComponent(planeShape1)
floorPlane.addComponent(greenMat)
engine.addEntity(floorPlane)

const northPlane = new Entity()
northPlane.addComponent(new Transform({position: new Vector3(8,7,15), scale: new Vector3(14,14,14), rotation:Quaternion.Euler(0,0,0)}))
northPlane.addComponent(planeShape1)
northPlane.addComponent(greenMat)
engine.addEntity(northPlane)

const southPlane = new Entity()
southPlane.addComponent(new Transform({position: new Vector3(8,7,1), scale: new Vector3(14,14,14), rotation:Quaternion.Euler(0,0,0)}))
southPlane.addComponent(planeShape1)
southPlane.addComponent(greenMat)
engine.addEntity(southPlane)

const eastPlane = new Entity()
eastPlane.addComponent(new Transform({position: new Vector3(15,7,8), scale: new Vector3(14,14,14), rotation:Quaternion.Euler(0,90,0)}))
eastPlane.addComponent(planeShape1)
eastPlane.addComponent(greenMat)
engine.addEntity(eastPlane)

const westPlane = new Entity()
westPlane.addComponent(new Transform({position: new Vector3(1,7,8), scale: new Vector3(14,14,14), rotation:Quaternion.Euler(0,90,0)}))
westPlane.addComponent(planeShape1)
westPlane.addComponent(greenMat)
engine.addEntity(westPlane)

const topPlane = new Entity()
topPlane.addComponent(new Transform({position: new Vector3(8,14,8), scale: new Vector3(14,14,14), rotation:Quaternion.Euler(90,0,0)}))
topPlane.addComponent(planeShape1)
topPlane.addComponent(greenMat)
engine.addEntity(topPlane)



//Buttons
const redButton = new Entity()
redButton.addComponent(buttonShape)
redButton.addComponent(new Transform({position: new Vector3(0.5,1.5,0.5), scale: new Vector3(0.2,0.2,0.2), rotation:Quaternion.Euler(0,0,0)}))
redButton.addComponent(redMat)
engine.addEntity(redButton)

const orangeButton = new Entity()
orangeButton.addComponent(buttonShape)
orangeButton.addComponent(new Transform({position: new Vector3(0.5,1.5,1), scale: new Vector3(0.2,0.2,0.2), rotation:Quaternion.Euler(0,0,0)}))
orangeButton.addComponent(orangeMat)
engine.addEntity(orangeButton)

const yellowButton = new Entity()
yellowButton.addComponent(buttonShape)
yellowButton.addComponent(new Transform({position: new Vector3(0.5,1.5,1.5), scale: new Vector3(0.2,0.2,0.2), rotation:Quaternion.Euler(0,0,0)}))
yellowButton.addComponent(yellowMat)
engine.addEntity(yellowButton)

const greenButton = new Entity()
greenButton.addComponent(buttonShape)
greenButton.addComponent(new Transform({position: new Vector3(0.5,1.5,2), scale: new Vector3(0.2,0.2,0.2), rotation:Quaternion.Euler(0,0,0)}))
greenButton.addComponent(greenMat)
engine.addEntity(greenButton)

const blueButton = new Entity()
blueButton.addComponent(buttonShape)
blueButton.addComponent(new Transform({position: new Vector3(0.5,1.5,2.5), scale: new Vector3(0.2,0.2,0.2), rotation:Quaternion.Euler(0,0,0)}))
blueButton.addComponent(blueMat)
engine.addEntity(blueButton)

const purpleButton = new Entity()
purpleButton.addComponent(buttonShape)
purpleButton.addComponent(new Transform({position: new Vector3(0.5,1.5,3), scale: new Vector3(0.2,0.2,0.2), rotation:Quaternion.Euler(0,0,0)}))
purpleButton.addComponent(purpleMat)
engine.addEntity(purpleButton)

const whiteButton = new Entity()
whiteButton.addComponent(buttonShape)
whiteButton.addComponent(new Transform({position: new Vector3(0.5,1.5,3.5), scale: new Vector3(0.2,0.2,0.2), rotation:Quaternion.Euler(0,0,0)}))
whiteButton.addComponent(whiteMat)
engine.addEntity(whiteButton)

const greyButton = new Entity()
greyButton.addComponent(buttonShape)
greyButton.addComponent(new Transform({position: new Vector3(0.5,1.5,4), scale: new Vector3(0.2,0.2,0.2), rotation:Quaternion.Euler(0,0,0)}))
greyButton.addComponent(greyMat)
engine.addEntity(greyButton)

const blackButton = new Entity()
blackButton.addComponent(buttonShape)
blackButton.addComponent(new Transform({position: new Vector3(0.5,1.5,4.5), scale: new Vector3(0.2,0.2,0.2), rotation:Quaternion.Euler(0,0,0)}))
blackButton.addComponent(blackMat)
engine.addEntity(blackButton)



//Switch colours
redButton.addComponent(
    new OnPointerDown(
        (e) => {
            floorPlane.addComponentOrReplace(redMat)
            northPlane.addComponentOrReplace(redMat)
            southPlane.addComponentOrReplace(redMat)
            eastPlane.addComponentOrReplace(redMat)
            westPlane.addComponentOrReplace(redMat)
            topPlane.addComponentOrReplace(redMat)
        },
        {
            hoverText: ""Switch to Red""
        }
    )
)

orangeButton.addComponent(
    new OnPointerDown(
        (e) => {
            floorPlane.addComponentOrReplace(orangeMat)
            northPlane.addComponentOrReplace(orangeMat)
            southPlane.addComponentOrReplace(orangeMat)
            eastPlane.addComponentOrReplace(orangeMat)
            westPlane.addComponentOrReplace(orangeMat)
            topPlane.addComponentOrReplace(orangeMat)
        },
        {
            hoverText: ""Switch to Orange""
        }
    )
)

yellowButton.addComponent(
    new OnPointerDown(
        (e) => {
            floorPlane.addComponentOrReplace(yellowMat)
            northPlane.addComponentOrReplace(yellowMat)
            southPlane.addComponentOrReplace(yellowMat)
            eastPlane.addComponentOrReplace(yellowMat)
            westPlane.addComponentOrReplace(yellowMat)
            topPlane.addComponentOrReplace(yellowMat)
        },
        {
            hoverText: ""Switch to Yellow""
        }
    )
)

greenButton.addComponent(
    new OnPointerDown(
        (e) => {
            floorPlane.addComponentOrReplace(greenMat)
            northPlane.addComponentOrReplace(greenMat)
            southPlane.addComponentOrReplace(greenMat)
            eastPlane.addComponentOrReplace(greenMat)
            westPlane.addComponentOrReplace(greenMat)
            topPlane.addComponentOrReplace(greenMat)
        },
        {
            hoverText: ""Switch to Green""
        }
    )
)

blueButton.addComponent(
    new OnPointerDown(
        (e) => {
            floorPlane.addComponentOrReplace(blueMat)
            northPlane.addComponentOrReplace(blueMat)
            southPlane.addComponentOrReplace(blueMat)
            eastPlane.addComponentOrReplace(blueMat)
            westPlane.addComponentOrReplace(blueMat)
            topPlane.addComponentOrReplace(blueMat)
        },
        {
            hoverText: ""Switch to Blue""
        }
    )
)

purpleButton.addComponent(
    new OnPointerDown(
        (e) => {
            floorPlane.addComponentOrReplace(purpleMat)
            northPlane.addComponentOrReplace(purpleMat)
            southPlane.addComponentOrReplace(purpleMat)
            eastPlane.addComponentOrReplace(purpleMat)
            westPlane.addComponentOrReplace(purpleMat)
            topPlane.addComponentOrReplace(purpleMat)
        },
        {
            hoverText: ""Switch to Purple""
        }
    )
)

whiteButton.addComponent(
    new OnPointerDown(
        (e) => {
            floorPlane.addComponentOrReplace(whiteMat)
            northPlane.addComponentOrReplace(whiteMat)
            southPlane.addComponentOrReplace(whiteMat)
            eastPlane.addComponentOrReplace(whiteMat)
            westPlane.addComponentOrReplace(whiteMat)
            topPlane.addComponentOrReplace(whiteMat)
        },
        {
            hoverText: ""Switch to White""
        }
    )
)

greyButton.addComponent(
    new OnPointerDown(
        (e) => {
            floorPlane.addComponentOrReplace(greyMat)
            northPlane.addComponentOrReplace(greyMat)
            southPlane.addComponentOrReplace(greyMat)
            eastPlane.addComponentOrReplace(greyMat)
            westPlane.addComponentOrReplace(greyMat)
            topPlane.addComponentOrReplace(greyMat)
        },
        {
            hoverText: ""Switch to Grey""
        }
    )
)

blackButton.addComponent(
    new OnPointerDown(
        (e) => {
            floorPlane.addComponentOrReplace(blackMat)
            northPlane.addComponentOrReplace(blackMat)
            southPlane.addComponentOrReplace(blackMat)
            eastPlane.addComponentOrReplace(blackMat)
            westPlane.addComponentOrReplace(blackMat)
            topPlane.addComponentOrReplace(blackMat)
        },
        {
            hoverText: ""Switch to Black""
        }
    )
)"
/* DCL access library game */,"import * as access from 'dcl-access-area'
import { buildScene } from './builder-content'

buildScene()

/// access area checking for NFT-721 ownership on ETH chain
let wall = access.createArea({
  transform: {position: new Vector3(12,1,4), scale: new Vector3(3,8,5)},
  debug: false, //toggle this true/false to see the access area and position within your scene
  type: access.Type.NFT,
  nftType: access.NFTType.ERC721,
  chain: access.ChainType.ETH,
  contract: ""0xf23e1aa97de9ca4fb76d2fa3fafcf4414b2afed0"",
  name: ""wall1"",
  deniedMessage: ""You do not have bar access""
})

/// access area checking for user wearing wearables
// let wall = access.createArea({
//   transform: {position: new Vector3(12,1,4), scale: new Vector3(3,8,5)},
//   debug: false, //toggle this true/false to see the access area and position within your scene
//   type: access.Type.WEARABLESON,
//   wearables:[""urn:decentraland:matic:collections-v2:0xf87a8372437c40ef9176c1b224cbe9307a617a25:1""],
//   name: ""wall1"",
//   deniedMessage: ""You do not have bar access""
// })

/// access area checking for user owning wearables
// let wall = access.createArea({
//   transform: {position: new Vector3(12,1,4), scale: new Vector3(3,8,5)},
//   debug: false, //toggle this true/false to see the access area and position within your scene
//   type: access.Type.HASWEARABLES,
//   wearables:[""urn:decentraland:matic:collections-v2:0xf87a8372437c40ef9176c1b224cbe9307a617a25:0"", ""urn:decentraland:matic:collections-v2:0xf87a8372437c40ef9176c1b224cbe9307a617a25:1""],
//   wearablesMatch: access.Match.ALL,
//   name: ""wall1"",
//   deniedMessage: ""You do not have bar access""
// })"
/* DCL access library builder content */,"export function buildScene(){

//exported builder 3d files
const _scene = new Entity('_scene')
engine.addEntity(_scene)
const transform = new Transform({
  position: new Vector3(0, 0, 0),
  rotation: new Quaternion(0, 0, 0, 1),
  scale: new Vector3(1, 1, 1)
})
_scene.addComponentOrReplace(transform)

const entity = new Entity('entity')
engine.addEntity(entity)
entity.setParent(_scene)
const gltfShape = new GLTFShape(""models/Cracked.glb"")
gltfShape.withCollisions = true
gltfShape.isPointerBlocker = true
gltfShape.visible = true
entity.addComponentOrReplace(gltfShape)
const transform2 = new Transform({
  position: new Vector3(8, 0, 8),
  rotation: new Quaternion(0, 0, 0, 1),
  scale: new Vector3(1, 1, 1)
})
entity.addComponentOrReplace(transform2)

const houseMYellow = new Entity('houseMYellow')
engine.addEntity(houseMYellow)
houseMYellow.setParent(_scene)
const transform3 = new Transform({
  position: new Vector3(12.5, 0, 9.5),
  rotation: new Quaternion(2.763665218983441e-15, -1.4901159772762185e-7, 1.5885987729273576e-14, -1),
  scale: new Vector3(1.0000008344650269, 1, 1.0000008344650269)
})
houseMYellow.addComponentOrReplace(transform3)
const gltfShape2 = new GLTFShape(""models/House 6 M Yellow.glb"")
gltfShape2.withCollisions = true
gltfShape2.isPointerBlocker = true
gltfShape2.visible = true
houseMYellow.addComponentOrReplace(gltfShape2)

const deckL = new Entity('deckL')
engine.addEntity(deckL)
deckL.setParent(_scene)
const transform4 = new Transform({
  position: new Vector3(12.5, 0, 9.5),
  rotation: new Quaternion(0, 0, 0, 1),
  scale: new Vector3(1, 1, 1)
})
deckL.addComponentOrReplace(transform4)
const gltfShape3 = new GLTFShape(""models/Deck L.glb"")
gltfShape3.withCollisions = true
gltfShape3.isPointerBlocker = true
gltfShape3.visible = true
deckL.addComponentOrReplace(gltfShape3)

const awningM = new Entity('awningM')
engine.addEntity(awningM)
awningM.setParent(_scene)
const transform5 = new Transform({
  position: new Vector3(12, 0, 10),
  rotation: new Quaternion(0, 0, 0, 1),
  scale: new Vector3(1, 1, 1)
})
awningM.addComponentOrReplace(transform5)
const gltfShape4 = new GLTFShape(""models/Awning 5M.glb"")
gltfShape4.withCollisions = true
gltfShape4.isPointerBlocker = true
gltfShape4.visible = true
awningM.addComponentOrReplace(gltfShape4)

const barrel = new Entity('barrel')
engine.addEntity(barrel)
barrel.setParent(_scene)
const transform6 = new Transform({
  position: new Vector3(13, 0, 5.5),
  rotation: new Quaternion(-1.5394153601527394e-15, 0.7071068286895752, -8.429369557916289e-8, 0.7071068286895752),
  scale: new Vector3(1.0000003576278687, 1, 1.0000003576278687)
})
barrel.addComponentOrReplace(transform6)
const gltfShape5 = new GLTFShape(""models/Barrel 4.glb"")
gltfShape5.withCollisions = true
gltfShape5.isPointerBlocker = true
gltfShape5.visible = true
barrel.addComponentOrReplace(gltfShape5)

const bonfire = new Entity('bonfire')
engine.addEntity(bonfire)
bonfire.setParent(_scene)
const transform7 = new Transform({
  position: new Vector3(3, 0, 13.5),
  rotation: new Quaternion(0, 0, 0, 1),
  scale: new Vector3(1, 1, 1)
})
bonfire.addComponentOrReplace(transform7)
const gltfShape6 = new GLTFShape(""models/Bonfire 1.glb"")
gltfShape6.withCollisions = true
gltfShape6.isPointerBlocker = true
gltfShape6.visible = true
bonfire.addComponentOrReplace(gltfShape6)

const bucket = new Entity('bucket')
engine.addEntity(bucket)
bucket.setParent(_scene)
const transform8 = new Transform({
  position: new Vector3(8, 0.5, 10),
  rotation: new Quaternion(0, 0, 0, 1),
  scale: new Vector3(1, 1, 1)
})
bucket.addComponentOrReplace(transform8)
const gltfShape7 = new GLTFShape(""models/Bucket.glb"")
gltfShape7.withCollisions = true
gltfShape7.isPointerBlocker = true
gltfShape7.visible = true
bucket.addComponentOrReplace(gltfShape7)

const cartBigClosed = new Entity('cartBigClosed')
engine.addEntity(cartBigClosed)
cartBigClosed.setParent(_scene)
const transform9 = new Transform({
  position: new Vector3(3.5, 0, 8),
  rotation: new Quaternion(0, 0, 0, 1),
  scale: new Vector3(1, 1, 1)
})
cartBigClosed.addComponentOrReplace(transform9)
const gltfShape8 = new GLTFShape(""models/Cart Big Closed.glb"")
gltfShape8.withCollisions = true
gltfShape8.isPointerBlocker = true
gltfShape8.visible = true
cartBigClosed.addComponentOrReplace(gltfShape8)

const barM = new Entity('barM')
engine.addEntity(barM)
barM.setParent(_scene)
const transform10 = new Transform({
  position: new Vector3(6.5, 5, 4),
  rotation: new Quaternion(-1.9728792828333256e-15, 0.7071068286895752, -8.429368847373553e-8, 0.7071067690849304),
  scale: new Vector3(0.9999998807907104, 1, 0.9999998807907104)
})
barM.addComponentOrReplace(transform10)
const gltfShape9 = new GLTFShape(""models/Furnit Bar 2 3M.glb"")
gltfShape9.withCollisions = true
gltfShape9.isPointerBlocker = true
gltfShape9.visible = true
barM.addComponentOrReplace(gltfShape9)

const barM3 = new Entity('barM3')
engine.addEntity(barM3)
barM3.setParent(_scene)
const transform11 = new Transform({
  position: new Vector3(7.5, 3.5, 1),
  rotation: new Quaternion(-1.5394153601527394e-15, -0.7071068286895752, 8.429369557916289e-8, 0.7071068286895752),
  scale: new Vector3(1.0000016689300537, 1, 1.0000016689300537)
})
barM3.addComponentOrReplace(transform11)
const gltfShape10 = new GLTFShape(""models/Furnit Bar 1 2M.glb"")
gltfShape10.withCollisions = true
gltfShape10.isPointerBlocker = true
gltfShape10.visible = true
barM3.addComponentOrReplace(gltfShape10)
/////////



}"
/* NFT scanner basic  game */,"// NOTE: remember to add &ENABLE_WEB3 to the url when running locally
import * as EthereumController from ""@decentraland/EthereumController""
import * as crypto from ""@dcl/crypto-scene-utils""
import { Door } from ""./door""
import { Sound } from ""./sound""
import * as ui from ""@dcl/ui-scene-utils""

// Config
let userAddress: string

// Example token from the contract: https://opensea.io/assets/0x6b47e7066c7db71aa04a1d5872496fe05c4c331f/2
// Contract address on Etherscan: https://etherscan.io/address/0x6b47e7066c7db71aa04a1d5872496fe05c4c331f
const contractAddress = ""0x6b47e7066c7db71aa04a1d5872496fe05c4c331f"" // Contract for RTFKT x Atari wearables collection

// Sounds
const openDoorSound = new Sound(new AudioClip(""sounds/openDoor.mp3""), false)
const accessDeniedSound = new Sound(new AudioClip(""sounds/accessDenied.mp3""), false)

// Music
const jazzMuffledSound = new Sound(new AudioClip(""sounds/jazzMuffled.mp3""), true, true)
const jazzSound = new Sound(new AudioClip(""sounds/jazz.mp3""), true, true)
jazzSound.getComponent(AudioSource).volume = 0.0

// Base
const base = new Entity()
base.addComponent(new GLTFShape(""models/baseDarkWithCollider.glb""))
engine.addEntity(base)

// Facade
const facade = new Entity()
facade.addComponent(new GLTFShape(""models/facade.glb""))
facade.addComponent(new Transform({ position: new Vector3(8, 0.05, 10) }))
facade.getComponent(Transform).rotate(Vector3.Up(), 180)
engine.addEntity(facade)

// Door
const door = new Door(new GLTFShape(""models/door.glb""))
door.setParent(facade)
door.addComponent(
  new OnPointerDown(
    () => {
      checkTokens()
    },
    {
      button: ActionButton.PRIMARY,
      hoverText: ""Enter Club"",
      showFeedback: true,
    }
  )
)

// UI
let noSign = new ui.CenterImage(""images/no-sign.png"", 1, true, 0, 20, 128, 128, {
  sourceHeight: 512,
  sourceWidth: 512,
  sourceLeft: 0,
  sourceTop: 0,
})

// On load
executeTask(async () => {
  try {
    userAddress = await EthereumController.getUserAccount()
    log(""User Address: "", userAddress)
  } catch (error) {
    log(error.toString())
  }
})

// Check player's wallet to see if they're holding any tokens relating to that contract address
async function checkTokens() {
  let balance = await crypto.currency.balance(contractAddress, userAddress)
  log(""BALANCE: "", balance)

  if (Number(balance) > 0) {
    door.playDoorOpen()
    openDoorSound.getComponent(AudioSource).playOnce()
    jazzSound.getComponent(AudioSource).volume = 1.0
  } else {
    noSign.show(1)
    accessDeniedSound.getComponent(AudioSource).playOnce()
    jazzMuffledSound.getComponent(AudioSource).volume = 1.0
  }
}"
/* NFT scanner basic door */,"export class Door extends Entity {
  constructor(model: GLTFShape) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Transform())

    this.addComponent(new Animator())
    this.getComponent(Animator).addClip(new AnimationState(""Blank"", { looping: false }))
    this.getComponent(Animator).addClip(new AnimationState(""OpenDoor"", { looping: false }))
    this.getComponent(Animator).getClip(""Blank"").play()
  }

  playDoorOpen() {
    this.getComponent(Animator).getClip(""Blank"").stop()
    this.getComponent(Animator).getClip(""OpenDoor"").stop()
    this.getComponent(Animator).getClip(""OpenDoor"").play()
    this.removeComponent(OnPointerDown)
  }
}"
/* NFT scanner basic sound */,"export class Sound extends Entity {
  constructor(audio: AudioClip, loop: boolean, play: boolean = false, transform?: Vector3) {
    super()
    engine.addEntity(this)
    this.addComponent(new AudioSource(audio))
    this.getComponent(AudioSource).loop = loop
    this.getComponent(AudioSource).playing = play 
    this.addComponent(new Transform())

    if (transform) {
      this.getComponent(Transform).position = transform
    } else {
      this.setParent(Attachable.AVATAR)
    }
  }

  playAudioOnceAtPosition(transform: Vector3): void {
    this.getComponent(Transform).position = transform
    this.getComponent(AudioSource).playOnce()
  }

  playAudioAtPosition(transform: Vector3): void {
    this.getComponent(Transform).position = transform
    this.getComponent(AudioSource).playing = true
  }
}"
/* Box 2D bouncing ball */,"import { b2Vec2 } from '../node_modules/box2d.ts/Box2D/Common/b2Math'
import { b2World } from '../node_modules/box2d.ts/Box2D/Dynamics/b2World'
import { b2FixtureDef, b2Fixture } from '../node_modules/box2d.ts/Box2D/Dynamics/b2Fixture'
import { b2BodyDef, b2BodyType, b2Body } from '../node_modules/box2d.ts/Box2D/Dynamics/b2Body'
import { b2PolygonShape } from '../node_modules/box2d.ts/Box2D/Collision/Shapes/b2PolygonShape'
import { b2CircleShape } from '../node_modules/box2d.ts/Box2D/Collision/Shapes/b2CircleShape'

// Create base scene
const baseScene = new Entity()
baseScene.addComponent(new GLTFShape(""models/baseScene.glb""))
baseScene.addComponent(new Transform())
engine.addEntity(baseScene)

// Create red ball
const redMaterial = new Material()
redMaterial.albedoColor = Color3.Red()
const ballShape = new SphereShape()
const ball = new Entity()
ball.addComponent(ballShape)
ball.addComponent(redMaterial)
ball.addComponent(new Transform({}))
ball.getComponent(Transform).position.z = 8
ball.getComponent(Transform).scale.setAll(1)
engine.addEntity(ball)

// Define the gravity vector.
const gravity: b2Vec2 = new b2Vec2(0, -10)

// Construct a world object, which will hold and simulate the rigid bodies.
const world: b2World = new b2World(gravity)

// Define the ground body.
const groundBodyDef: b2BodyDef = new b2BodyDef()
groundBodyDef.position.Set(0, -10)

// Call the body factory which allocates memory for the ground body
// from a pool and creates the ground box shape (also from a pool).
// The body is also added to the world.
const groundBody: b2Body = world.CreateBody(groundBodyDef)

// Define the ground box shape.
const groundBox: b2PolygonShape = new b2PolygonShape()

// The extents are the half-widths of the box.
groundBox.SetAsBox(50, 10)

// Add the ground fixture to the ground body.
groundBody.CreateFixture(groundBox, 0)

// Define the dynamic body. We set its position and call the body factory.
const bodyDef: b2BodyDef = new b2BodyDef()
bodyDef.type = b2BodyType.b2_dynamicBody
bodyDef.position.Set(8, 8)
const body: b2Body = world.CreateBody(bodyDef)

// Define another shape for our dynamic body.
const dynamicBox: b2CircleShape = new b2CircleShape(1) // Radius to match ball radius

// Define the dynamic body fixture.
const fixtureDef: b2FixtureDef = new b2FixtureDef()
fixtureDef.shape = dynamicBox

// Set the box density to be non-zero, so it will be dynamic.
fixtureDef.density = 1

// Override the default friction.
fixtureDef.friction = 0.5

// Setting the bounciness of the ball
fixtureDef.restitution = 0.6

// Add the shape to the body.
const fixture: b2Fixture = body.CreateFixture(fixtureDef)

// Prepare for simulation. Typically we use a time step of 1/60 of a
// second (60Hz) and 10 iterations. This provides a high quality simulation
// in most game scenarios.
const timeStep: number = 1 / 60 // UNUSED: using dt instead
const velocityIterations: number = 6
const positionIterations: number = 2

class updateSystem implements ISystem {
  update(dt: number): void {
    // Instruct the world to perform a single step of simulation.
    // It is generally best to keep the time step and iterations fixed.
    world.Step(dt, velocityIterations, positionIterations)

    // Now print the position and angle of the body.
    const position: b2Vec2 = body.GetPosition()
    const angle: number = body.GetAngle()

    ball.getComponent(Transform).position.x = position.x
    ball.getComponent(Transform).position.y = position.y

    log(position.x.toFixed(2), position.y.toFixed(2), angle.toFixed(2))
  }
}

engine.addSystem(new updateSystem())"
/* cannon car */ ,"/*
  IMPORTANT: The tsconfig.json has been configured to include ""node_modules/cannon/build/cannon.js""
  Code is adapted from: https://github.com/schteppe/cannon.js/blob/master/demos/raycastVehicle.html
*/

/// >>>>>>>>>> TODO: Reorient the car and wheels <<<<<<<<<<
/// >>>>>>>>>> TODO: Needs refactoring <<<<<<<<<<
/// >>>>>>>>>> TODO: Switch to cannon-es.js <<<<<<<<<<

// Create base scene
const baseScene: Entity = new Entity()
baseScene.addComponent(new GLTFShape(""models/baseScene.glb""))
baseScene.addComponent(
  new Transform({
    scale: new Vector3(2.5, 0.05, 2.5),
  })
)
engine.addEntity(baseScene)

const boxes: Entity[] = [] // Store boxes
const boxBodies: CANNON.Body[] = [] // Store box bodies
let boxStartPosition: number = 34 // Start position for the boxes
let boxHeightPosition: number = 2

const blueMaterial: Material = new Material()
blueMaterial.roughness = 0.5
blueMaterial.albedoColor = Color3.FromInts(21, 105, 195)

const blackMaterial: Material = new Material()
blackMaterial.roughness = 0.5
blackMaterial.albedoColor = Color3.FromInts(35, 35, 35)

// Create wall of boxes
for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 6; j++) {
    let positionX: number = boxStartPosition
    let positionY: number = boxHeightPosition
    let positionZ: number = 38

    const box: Entity = new Entity()
    engine.addEntity(box)
    box.addComponent(new BoxShape())
    box.addComponent(
      new Transform({
        position: new Vector3(positionX, positionY, positionZ),
        scale: new Vector3(2, 2, 2),
      })
    )
    if (i % 2 == 0) {
      if (j % 2 == 0) {
        box.addComponent(blueMaterial)
      } else {
        box.addComponent(blackMaterial)
      }
    } else {
      if (j % 2 == 0) {
        box.addComponent(blackMaterial)
      } else {
        box.addComponent(blueMaterial)
      }
    }
    boxes.push(box)
    boxStartPosition += 2
  }
  boxStartPosition = 34
  boxHeightPosition += 2 // To ensure the colliders aren't intersecting when the simulation starts
}

// Car entities
const chassis: Entity = new Entity()
chassis.addComponent(new GLTFShape(""models/carBody.glb""))
chassis.addComponent(new Transform())
engine.addEntity(chassis)

const wheels: Entity[] = []
const wheelPositions: Vector3[] = [new Vector3(2, 1.5, 0), new Vector3(2, -1.5, 0), new Vector3(-2.1, 1.5, 0), new Vector3(-2.1, -1.5, 0)]

for (let i = 0; i < wheelPositions.length; i++) {
  const wheel: Entity = new Entity()
  if (i % 2 == 0) {
    wheel.addComponent(new GLTFShape(""models/carWheelRight.glb""))
  } else {
    wheel.addComponent(new GLTFShape(""models/carWheelLeft.glb""))
  }

  wheel.addComponent(new Transform({ position: wheelPositions[i] }))
  engine.addEntity(wheel)
  wheels.push(wheel)
}

// Setup our world
const world: CANNON.World = new CANNON.World()
world.broadphase = new CANNON.SAPBroadphase(world)
world.gravity.set(0, -9.82, 0) // m/sÂ²
world.defaultContactMaterial.friction = 0

const groundMaterial: CANNON.Material = new CANNON.Material(""groundMaterial"")
const wheelMaterial: CANNON.Material = new CANNON.Material(""wheelMaterial"")
const wheelGroundContactMaterial: CANNON.ContactMaterial = new CANNON.ContactMaterial(wheelMaterial, groundMaterial, {
  friction: 0.3,
  restitution: 0,
  contactEquationStiffness: 1000,
})

const boxMaterial: CANNON.Material = new CANNON.Material(""boxMaterial"")
const boxToGroundContactMaterial: CANNON.ContactMaterial = new CANNON.ContactMaterial(groundMaterial, boxMaterial, {
  friction: 0.4,
  restitution: 0.5,
})
const boxToBoxContactMaterial: CANNON.ContactMaterial = new CANNON.ContactMaterial(boxMaterial, boxMaterial, {
  friction: 0.5,
  restitution: 0.5,
})
world.addContactMaterial(boxToGroundContactMaterial)
world.addContactMaterial(boxToBoxContactMaterial)

// Create bodies to represent each of the box
for (let i = 0; i < boxes.length; i++) {
  let boxTransform: Transform = boxes[i].getComponent(Transform)
  const boxBody: CANNON.Body = new CANNON.Body({
    mass: 2, // kg
    position: new CANNON.Vec3(boxTransform.position.x, boxTransform.position.y, boxTransform.position.z), // m
    shape: new CANNON.Box(new CANNON.Vec3(1, 1, 1)), // m
  })

  boxBody.material = boxMaterial
  boxBody.linearDamping = 0.5
  boxBody.angularDamping = 0.5

  world.addBody(boxBody) // Add body to the world
  boxBodies.push(boxBody)
}

// We must add the contact materials to the world
world.addContactMaterial(wheelGroundContactMaterial)

// Create a ground plane and apply physics material
const groundBody: CANNON.Body = new CANNON.Body({
  mass: 0, // mass == 0 makes the body static
})
groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2) // Reorient ground plane to be in the y-axis

const groundShape: CANNON.Plane = new CANNON.Plane()
groundBody.addShape(groundShape)
groundBody.material = groundMaterial
world.addBody(groundBody)

const chassisShape: CANNON.Box = new CANNON.Box(new CANNON.Vec3(7.2 / 2, 3.3 / 2, 1.7 / 2)) // Dimensions is from the center
const chassisBody: CANNON.Body = new CANNON.Body({ mass: 150 })
chassisBody.addShape(chassisShape)
chassisBody.position.set(16, 4, 16) // Start position in scene
chassisBody.angularVelocity.set(-1.5, 0.0, 1.5)

const options = {
  radius: 0.5, // m
  directionLocal: new CANNON.Vec3(0, 0, -1),
  suspensionStiffness: 30,
  suspensionRestLength: 0.4,
  frictionSlip: 5,
  dampingRelaxation: 2.3,
  dampingCompression: 4.4,
  maxSuspensionForce: 100000,
  rollInfluence: 0.01,
  axleLocal: new CANNON.Vec3(0, 1, 0),
  chassisConnectionPointLocal: new CANNON.Vec3(1, 1, 0),
  maxSuspensionTravel: 0.3,
  customSlidingRotationalSpeed: -30,
  useCustomSlidingRotationalSpeed: true,
}

// Create the vehicle
const vehicle: CANNON.RaycastVehicle = new CANNON.RaycastVehicle({
  chassisBody: chassisBody,
})

// Set the wheel bodies positions
for (let i = 0; i < wheelPositions.length; i++) {
  options.chassisConnectionPointLocal.set(wheelPositions[i].clone().x, wheelPositions[i].clone().y, wheelPositions[i].clone().z)
  vehicle.addWheel(options)
}
vehicle.addToWorld(world)

const wheelBodies: CANNON.Body[] = []

for (let i = 0; i < vehicle.wheelInfos.length; i++) {
  let wheel = vehicle.wheelInfos[i]
  let cylinderShape: CANNON.Cylinder = new CANNON.Cylinder(wheel.radius, wheel.radius, wheel.radius / 2, 20)
  let wheelBody: CANNON.Body = new CANNON.Body({
    mass: 0,
  })
  wheelBody.type = CANNON.Body.KINEMATIC
  wheelBody.collisionFilterGroup = 0 // turn off collisions
  let q: CANNON.Quaternion = new CANNON.Quaternion()
  q.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2)
  wheelBody.addShape(cylinderShape, new CANNON.Vec3(), q)
  wheelBodies.push(wheelBody)
  world.addBody(wheelBody)
}

const fixedTimeStep: number = 1.0 / 60.0 // seconds
const maxSubSteps: number = 3

class updateSystem implements ISystem {
  update(dt: number): void {
    // Instruct the world to perform a single step of simulation.
    // It is generally best to keep the time step and iterations fixed.
    world.step(fixedTimeStep, dt, maxSubSteps)

    // Position and rotate the boxes in the scene to match their cannon world counterparts
    for (let i = 0; i < boxes.length; i++) {
      boxes[i].getComponent(Transform).position.copyFrom(boxBodies[i].position)
      boxes[i].getComponent(Transform).rotation.copyFrom(boxBodies[i].quaternion)
    }

    for (let i = 0; i < vehicle.wheelInfos.length; i++) {
      vehicle.updateWheelTransform(i)
      let t: CANNON.Transform = vehicle.wheelInfos[i].worldTransform
      let wheelBody: CANNON.Body = wheelBodies[i]
      wheelBody.position.copy(t.position)
      wheelBody.quaternion.copy(t.quaternion)
      wheels[i].getComponent(Transform).position.copyFrom(wheelBodies[i].position)
      wheels[i].getComponent(Transform).rotation.copyFrom(wheelBodies[i].quaternion)
    }

    // Modifying the wheels position and rotation needs to happen before the chassis
    chassis.getComponent(Transform).position.copyFrom(chassisBody.position)
    chassis.getComponent(Transform).rotation.copyFrom(chassisBody.quaternion)
  }
}

engine.addSystem(new updateSystem())

let forwardForce: number = 0.0
let steerValue: number = 0.0
const maxSteerValue: number = 0.5
const maxSpeed: number = 300
const brakeForce: number = 25

class updateDriveSystem implements ISystem {
  update(): void {
    // Forward force
    vehicle.applyEngineForce(forwardForce, 2)
    vehicle.applyEngineForce(forwardForce, 3)

    // Steering
    vehicle.setSteeringValue(steerValue, 0)
    vehicle.setSteeringValue(steerValue, 1)

    // Braking
    // Press E and F Keys together
    if (isEKeyPressed && isFKeyPressed) {
      vehicle.setBrake(brakeForce, 0)
      vehicle.setBrake(brakeForce, 1)
      vehicle.setBrake(brakeForce, 2)
      vehicle.setBrake(brakeForce, 3)
    } else {
      vehicle.setBrake(0, 0)
      vehicle.setBrake(0, 1)
      vehicle.setBrake(0, 2)
      vehicle.setBrake(0, 3)
    }
  }
}
engine.addSystem(new updateDriveSystem())

// Controls
const input = Input.instance

let isPointerPressed = false
let isEKeyPressed = false
let isFKeyPressed = false

// Pointer
input.subscribe(""BUTTON_DOWN"", ActionButton.POINTER, false, () => {
  isPointerPressed = true
})
input.subscribe(""BUTTON_UP"", ActionButton.POINTER, false, () => {
  isPointerPressed = false
})

// E Key
input.subscribe(""BUTTON_DOWN"", ActionButton.PRIMARY, false, () => {
  isEKeyPressed = true
})
input.subscribe(""BUTTON_UP"", ActionButton.PRIMARY, false, () => {
  isEKeyPressed = false
})

// F Key
input.subscribe(""BUTTON_DOWN"", ActionButton.SECONDARY, false, () => {
  isFKeyPressed = true
})
input.subscribe(""BUTTON_UP"", ActionButton.SECONDARY, false, () => {
  isFKeyPressed = false
})

class ButtonChecker {
  update(dt: number) {
    if (isPointerPressed) {
      // Accelerate
      if (forwardForce > -maxSpeed) forwardForce -= 300 * dt
      log(forwardForce)
    } else {
      // Decelerate
      if (forwardForce < 0) {
        forwardForce += 300 * dt
      } else {
        forwardForce = 0
      }
    }

    if (isEKeyPressed && steerValue > -maxSteerValue) {
      log(steerValue)
      steerValue -= 3 * dt
    }
    if (isFKeyPressed && steerValue < maxSteerValue) {
      steerValue += 3 * dt
    }
  }
}

engine.addSystem(new ButtonChecker())"
/* NFT wall nfts */,"import { InfoPanel } from ""./infoPanel""

export class NFT extends Entity {
  public id: number
  public originalScale: Vector3 // Scale to revert back to once the ""visibility"" is turned back on

  constructor(
    nft: NFTShape,
    transform: Transform,
    color: Color3,
    id: number,
    infoPanel: InfoPanel,
  ) {
    super()
    engine.addEntity(this)
    this.addComponent(nft)
    this.addComponent(transform)
    this.originalScale = new Vector3(
      transform.scale.x,
      transform.scale.y,
      transform.scale.z
    )
    this.getComponent(NFTShape).color = color
    this.id = id

    // Sound
    this.addComponent(
      new AudioSource(
        new AudioClip(""sounds/navigation_forward-selection-minimal.mp3"")
      )
    )

    this.addComponent(
      new OnPointerDown(
        (): void => {
          this.getComponent(AudioSource).playOnce()
          infoPanel.openInfoPanel(this.id)
        },
        {
          button: ActionButton.POINTER,
          showFeedback: true,
          hoverText: ""More Info"",
          distance: 8,
        }
      )
    )
  }
}"
/* NFT wall infoPanel */,"import { data } from ""./data""

export class InfoPanel {
  private container: UIContainerRect
  private dropShadow: UIImage
  private mainPanel: UIImage
  private nftImage: UIImage
  private nftType: UIText
  private nftTitle: UIText
  private nftDetails: UIText
  private nftDirectLink: UIText
  private sound: Entity = new Entity()

  constructor(canvas: UICanvas) {
    // Container
    this.container = new UIContainerRect(canvas)
    this.container.width = ""100%""
    this.container.height = ""100%""
    this.container.positionY = 25
    this.container.visible = false

    // Drop Shadow
    this.dropShadow = new UIImage(
      this.container,
      new Texture(""images/shadow.png"")
    )
    this.dropShadow.sourceWidth = 960
    this.dropShadow.sourceHeight = 1200
    this.dropShadow.width = 485
    this.dropShadow.height = 606
    this.dropShadow.opacity = 0.2

    // Main Panel
    this.mainPanel = new UIImage(
      this.container,
      new Texture(""images/mainPanel.png"")
    )
    this.mainPanel.sourceWidth = 960
    this.mainPanel.sourceHeight = 1200
    this.mainPanel.width = 480
    this.mainPanel.height = 600

    // NFT Type
    this.nftType = new UIText(this.container)
    this.nftType.hAlign = ""center""
    this.nftType.vAlign = ""center""
    this.nftType.positionX = -143
    this.nftType.positionY = 265
    this.nftType.fontSize = 16
    this.nftType.fontWeight = ""normal""
    this.nftType.color = new Color4(1, 0.1, 0.4)
    this.nftType.value = ""Not Found""
    this.nftType.visible = false

    // NFT Title
    this.nftTitle = new UIText(this.container)
    this.nftTitle.hAlign = ""center""
    this.nftTitle.vAlign = ""center""
    this.nftTitle.positionX = -143
    this.nftTitle.positionY = 233
    this.nftTitle.fontSize = 25
    this.nftTitle.fontWeight = ""bold""
    this.nftTitle.color = Color4.Black()
    this.nftTitle.value = ""Not Found""
    this.nftTitle.visible = false

    // Image
    this.nftImage = new UIImage(
      this.container,
      new Texture(""images/mainPanel.png"") // Default image if nothing is found ...
    )
    this.nftImage.sourceWidth = 1024
    this.nftImage.sourceHeight = 1024
    this.nftImage.width = 384
    this.nftImage.height = 384
    this.nftImage.visible = false

    // Close button to the top right
    const closeButton = new UIImage(
      this.container,
      new Texture(""images/closeButton.png"")
    )
    closeButton.sourceWidth = 50
    closeButton.sourceHeight = 50
    closeButton.width = 37.5
    closeButton.height = 37.5
    closeButton.positionX = 206
    closeButton.positionY = 265
    closeButton.isPointerBlocker = true
    closeButton.onClick = new OnClick((): void => {
      this.closeInfoPanel()
    })

    // NFT Details
    this.nftDetails = new UIText(this.container)
    this.nftDetails.adaptWidth = true
    this.nftDetails.hAlign = ""center""
    this.nftDetails.vAlign = ""center""
    this.nftDetails.positionY = -208
    this.nftDetails.fontSize = 18
    this.nftDetails.fontWeight = ""bold""
    this.nftDetails.color = Color4.Black()
    this.nftDetails.value = ""Not Found""
    this.nftDetails.visible = false

    // NFT Direct Link
    this.nftDirectLink = new UIText(this.container)
    this.nftDirectLink.adaptWidth = true
    this.nftDirectLink.hAlign = ""center""
    this.nftDirectLink.vAlign = ""center""
    this.nftDirectLink.positionY = -233
    this.nftDirectLink.fontSize = 10
    this.nftDirectLink.fontWeight = ""normal""
    this.nftDirectLink.color = Color4.Black()
    this.nftDirectLink.value = ""Not Found""
    this.nftDirectLink.visible = false

    // Sound
    this.sound.addComponent(
      new Transform({
        position: new Vector3(8, 0, 8),
      })
    )
    this.sound.addComponent(
      new AudioSource(
        new AudioClip(""sounds/navigation_backward-selection-minimal.mp3"")
      )
    )
    engine.addEntity(this.sound)
  }

  public openInfoPanel(id: number): void {
    for (let i = 0; i < data.length; i++) {
      if (id == data[i].id) {
        log(data[i].images)
        this.nftType.value = data[i].type
        this.nftTitle.value = data[i].title
        this.nftImage.source = new Texture(data[i].images)
        this.nftDetails.value = data[i].details.info
        this.nftDetails.fontSize = data[i].details.fontSize
        this.nftDirectLink.value = data[i].directLink.link
        this.nftDirectLink.fontSize = data[i].directLink.fontSize
      }
    }

    this.container.visible = true
    this.nftType.visible = true
    this.nftTitle.visible = true
    this.nftImage.visible = true
    this.nftDetails.visible = true
    this.nftDirectLink.visible = true
  }

  private closeInfoPanel(): void {
    this.container.visible = false
    this.nftType.visible = false
    this.nftTitle.visible = false
    this.nftImage.visible = false
    this.nftDetails.visible = false
    this.nftDirectLink.visible = false
    this.sound.getComponent(AudioSource).playOnce()
  }
}"
/* NFT wall game */,"import utils from ""../node_modules/decentraland-ecs-utils/index""
import { NFT } from ""./nft""
import { data } from ""./data""
import { InfoPanel } from ""./infoPanel""

// Base scene
const baseScene = new Entity()
baseScene.addComponent(new GLTFShape(""models/baseScene.glb""))
baseScene.addComponent(
  new Transform({
    position: new Vector3(0, 0, 0),
  })
)
engine.addEntity(baseScene)

// UI Elements
const canvas = new UICanvas()
const infoPanel = new InfoPanel(canvas)

// NFTs
const makersPlaceNFT = new NFT(
  new NFTShape(""ethereum://"" + data[0].address),
  new Transform({
    position: new Vector3(5, 2.5, 8),
    scale: new Vector3(4, 4, 4),
  }),
  new Color3(0.0, 1.0, 1.5),
  data[0].id,
  infoPanel
)

const cryptoKittiesNFT = new NFT(
  new NFTShape(""ethereum://"" + data[1].address),
  new Transform({
    position: new Vector3(8, 2.5, 8),
    scale: new Vector3(4, 4, 4),
  }),
  new Color3(1.5, 1.5, 0.0),
  data[1].id,
  infoPanel
)

const knownOriginNFT = new NFT(
  new NFTShape(""ethereum://"" + data[2].address),
  new Transform({
    position: new Vector3(11, 2.5, 8),
    scale: new Vector3(4, 4, 4),
  }),
  new Color3(1.5, 0.5, 0.0),
  data[2].id,
  infoPanel
)

const axieInfinityNFT = new NFT(
  new NFTShape(""ethereum://"" + data[3].address),
  new Transform({
    position: new Vector3(5, 2.5, 8),
    scale: new Vector3(5, 5, 5),
  }),
  new Color3(1.5, 0.8, 0.8),
  data[3].id,
  infoPanel
)
axieInfinityNFT.getComponent(Transform).scale.setAll(0)

const chainGuardiansNFT = new NFT(
  new NFTShape(""ethereum://"" + data[4].address),
  new Transform({
    position: new Vector3(8, 2.5, 8),
    scale: new Vector3(4, 4, 4),
  }),
  new Color3(0.0, 1.0, 1.5),
  data[4].id,
  infoPanel
)
chainGuardiansNFT.getComponent(Transform).scale.setAll(0)

const myCryptoHeroesNFT = new NFT(
  new NFTShape(""ethereum://"" + data[5].address),
  new Transform({
    position: new Vector3(11, 2.5, 8),
    scale: new Vector3(4, 4, 4),
  }),
  new Color3(1.25, 1.25, 1.25),
  data[5].id,
  infoPanel
)
myCryptoHeroesNFT.getComponent(Transform).scale.setAll(0)

const nfts: NFT[] = [makersPlaceNFT, cryptoKittiesNFT, knownOriginNFT, axieInfinityNFT, chainGuardiansNFT, myCryptoHeroesNFT]
const swapNFTEntity = new Entity()

// NOTE: Using the scale instead of the visibility to turn the NFT on / off 
// as there are issues with the colliders getting in the way of each other
// when the user tries to click on an NFT to get more information...
swapNFTEntity.addComponent(
  new utils.Interval(8000, () => {
    for (let i = 0; i < nfts.length; i++) {
      if (nfts[i].getComponent(Transform).scale.x == 0) {
        nfts[i]
        .getComponent(Transform)
        .scale.set(
          nfts[i].originalScale.x,
          nfts[i].originalScale.y,
          nfts[i].originalScale.z
        )
      } else {
        nfts[i].getComponent(Transform).scale.setAll(0)
      }
    }
  })
)
engine.addEntity(swapNFTEntity)"
/* NFT wall data */,"export const data = [
  {
    id: 0,
    images: ""images/makersPlaceAliceInWater.png"",
    type: ""MakersPlace"",
    title: ""Alice in Water"",
    details: { info: ""Artist: Katy Arrington"", fontSize: 18 },
    directLink: {
      link:
        ""https://makersplace.com/katyarrington/alice-in-water-4-of-10-23747"",
      fontSize: 10,
    },
    address: ""0x2a46f2ffd99e19a89476e2f62270e0a35bbf0756/20606"",
  },
  {
    id: 1,
    images: ""images/cryptoKittiesPuddingDaintytot.png"",
    type: ""CryptoKitties"",
    title: ""Pudding Daintytot"",
    details: { info: ""#1320779 / Gen 19 / Slow Cooldown  (16h)"", fontSize: 15 },
    directLink: {
      link: ""https://www.cryptokitties.co/kitty/1320779"",
      fontSize: 11,
    },
    address: ""0x06012c8cf97bead5deae237070f9587f8e7a266d/1320779"",
  },
  {
    id: 2,
    images: ""images/knownOriginPussyBird.png"",
    type: ""Known Origin"",
    title: ""Pussy Bird"",
    details: { info: ""Artist: Kozachok"", fontSize: 18 },
    directLink: {
      link: ""https://knownorigin.io/token/165777"",
      fontSize: 12,
    },
    address: ""0xfbeef911dc5821886e1dda71586d90ed28174b7d/165777"",
  },
  {
    id: 3,
    images: ""images/axieInfinity265.png"",
    type: ""Axie Infinity"",
    title: ""Axie #265"",
    details: {
      info: ""Aquatic / Breed count: 0 of 7 / Level: 1 / Battles ready: 3 of 3"",
      fontSize: 11,
    },
    directLink: {
      link: ""https://axieinfinity.com/axie/265"",
      fontSize: 11,
    },
    address: ""0xf5b0a3efb8e8e4c201e2a935f110eaaf3ffecb8d/265"",
  },
  {
    id: 4,
    images: ""images/chainGuardiansCaptainDevezAttazer3.png"",
    type: ""ChainGuardians"",
    title: ""Captain Devex Attazer #3"",
    details: {
      info: ""Legendary / Rank: Captain / Catch: 3 of 1000 / Level: 0001 "",
      fontSize: 12,
    },
    directLink: {
      link: ""https://chainguardians.io/4"",
      fontSize: 12,
    },
    address: ""0x3cd41ec039c1f2dd1f76144bb3722e7b503f50ab/4"",
  },
  {
    id: 5,
    images: ""images/myCryptoHeroesGeorgeWashington.png"",
    type: ""MyCryptoHeroes"",
    title: ""George Washington"",
    details: {
      info: ""Legendary / #50040004"",
      fontSize: 18,
    },
    directLink: {
      link: ""https://www.mycryptoheroes.net/heroes/50040004"",
      fontSize: 11,
    },
    address: ""0x273f7f8e6489682df756151f5525576e322d51a3/50040004"",
  },
]"
/* certified cryptokitty */,"// NFT picture frame
const entity = new Entity()
const shapeComponent = new NFTShape(
  'ethereum://0x06012c8cf97bead5deae237070f9587f8e7a266d/229795',
  { color: Color3.Blue(), style: PictureFrameStyle.Gold_Carved }
)
entity.addComponent(shapeComponent)
entity.addComponent(
  new Transform({
    position: new Vector3(4, 1.5, 4),
  })
)
engine.addEntity(entity)

// fixed wall
const wall1 = new Entity()
wall1.addComponent(
  new Transform({
    position: new Vector3(4.5, 1, 4.1),
    scale: new Vector3(4, 3, 0.05),
  })
)
wall1.addComponent(new BoxShape())
engine.addEntity(wall1)

// ground
const floor = new Entity()
floor.addComponent(new GLTFShape('models/FloorBaseGrass.glb'))
floor.addComponent(
  new Transform({
    position: new Vector3(8, 0, 8),
    scale: new Vector3(1.6, 0.1, 1.6),
  })
)
engine.addEntity(floor)"
/* paid lever */,"import * as crypto from '@dcl/crypto-scene-utils'

export const screenSpaceUI = new UICanvas()
screenSpaceUI.visible = true

const imageTexture = new Texture('images/Pay_UI.png')
const scale = 0.55

const paid_lever_Model = new GLTFShape('models/PaidLever/Lever_Stick.glb')
const base_Model = new GLTFShape('models/PaidLever/Base_Lever.glb')

const clickSound = new AudioClip('sounds/click.mp3')

export class PaidLever extends Entity {
  animationOn: AnimationState
  animationOff: AnimationState
  activated: boolean = false
  address: string
  paymentAmount: number
  background: UIImage
  donationInput: UIInputText
  actionOn: () => void
  actionOff: () => void
  constructor(
    pos: TranformConstructorArgs,
    address: string,
    paymentAmount: number,
    hoverText: string,
    actionOn: () => void,
    actionOff: () => void,
    activated?: boolean
  ) {
    super()
    engine.addEntity(this)

    this.addComponent(base_Model)
    this.addComponent(new Transform(pos))

    const stick = new Entity()
    stick.addComponent(paid_lever_Model)
    stick.setParent(this)

    stick.addComponent(new Animator())

    this.animationOn = new AnimationState('LeverOn_Action', { looping: false })
    stick.getComponent(Animator).addClip(this.animationOn)

    this.addComponent(new AudioSource(clickSound))

    this.animationOff = new AnimationState('LeverOff_Action', {
      looping: false,
    })
    stick.getComponent(Animator).addClip(this.animationOff)

    this.address = address
    this.paymentAmount = paymentAmount
    this.actionOn = actionOn
    this.actionOff = actionOff
    if (activated) {
      this.activated = activated
      this.animationOff.stop()
    }

    stick.addComponent(
      new OnPointerDown(
        () => {
          this.openUI()
        },
        { hoverText: hoverText }
      )
    )

    const background = new UIImage(screenSpaceUI, imageTexture)

    background.name = 'background'
    background.width = 1024 * scale
    background.height = 448 * scale
    background.hAlign = 'center'
    background.vAlign = 'center'
    background.positionY = 0
    background.sourceLeft = 0
    background.sourceTop = 0
    background.sourceWidth = 1024
    background.sourceHeight = 429
    background.visible = false
    background.isPointerBlocker = false

    this.background = background

    const currentPayment = new UIText(background)
    currentPayment.value = this.paymentAmount.toString() + ' MANA'
    currentPayment.name = 'currentPayment'
    currentPayment.width = 200 * scale
    currentPayment.height = 100 * scale
    currentPayment.hAlign = 'center'
    currentPayment.vAlign = 'center'
    currentPayment.positionY = 18
    currentPayment.positionX = -37 * scale
    currentPayment.fontSize = 35 * scale
    currentPayment.vTextAlign = 'center'
    currentPayment.hTextAlign = 'center'
    currentPayment.color = Color4.FromHexString('#FF0050FF')

    const AcceptButton = new UIImage(background, imageTexture)
    AcceptButton.name = 'AcceptButton'
    AcceptButton.width = 460 * scale
    AcceptButton.height = 80 * scale
    AcceptButton.hAlign = 'center'
    AcceptButton.vAlign = 'center'
    AcceptButton.positionY = -60
    AcceptButton.positionX = -130
    AcceptButton.sourceLeft = 475
    AcceptButton.sourceTop = 425
    AcceptButton.sourceWidth = 460
    AcceptButton.sourceHeight = 74
    AcceptButton.isPointerBlocker = true
    AcceptButton.onClick = new OnClick(() => {
      this.closeUI()
      this.payFee()
    })

    const CancelButton = new UIImage(background, imageTexture)
    CancelButton.name = 'AcceptButton'
    CancelButton.width = 460 * scale
    CancelButton.height = 80 * scale
    CancelButton.hAlign = 'center'
    CancelButton.vAlign = 'center'
    CancelButton.positionY = -60
    CancelButton.positionX = 130
    CancelButton.sourceLeft = 0
    CancelButton.sourceTop = 425
    CancelButton.sourceWidth = 460
    CancelButton.sourceHeight = 74
    CancelButton.isPointerBlocker = true
    CancelButton.onClick = new OnClick(() => {
      this.closeUI()
    })
  }
  public openUI(): void {
    //donatedMoney = 0.058
    this.background.visible = true
    this.background.isPointerBlocker = true
  }
  public closeUI(): void {
    this.background.visible = false
    this.background.isPointerBlocker = false
  }

  public payFee(): void {
    log('PAYING FEE', this.paymentAmount)
    crypto.mana
      .send(this.address, this.paymentAmount, true)
      .then(() => {
        this.activated = !this.activated
        if (!this.activated) {
          this.animationOn.stop()
          this.animationOff.stop()
          this.animationOff.play()
          this.actionOff()
        } else {
          this.animationOn.stop()
          this.animationOff.stop()
          this.animationOn.play()
          this.actionOn()
        }
        this.getComponent(AudioSource).playOnce()
      })
      .catch((error) => log(error))
  }
}"
/* paid button */,"import * as crypto from '@dcl/crypto-scene-utils'

export const screenSpaceUI = new UICanvas()
screenSpaceUI.visible = true

const imageTexture = new Texture('images/Pay_UI.png')
const scale = 0.55

const paid_button_Model = new GLTFShape('models/PaidButton/MANA_Button.glb')
const base_Model = new GLTFShape('models/PaidButton/Base.glb')

const clickSound = new AudioClip('sounds/click.mp3')

export class PaidButton extends Entity {
  animation: AnimationState
  address: string
  paymentAmount: number
  background: UIImage
  donationInput: UIInputText
  action: () => void
  constructor(
    pos: TranformConstructorArgs,
    address: string,
    paymentAmount: number,
    hoverText: string,
    action: () => void
  ) {
    super()
    engine.addEntity(this)

    this.addComponent(base_Model)
    this.addComponent(new Transform(pos))

    const button = new Entity()
    button.addComponent(paid_button_Model)
    button.setParent(this)

    button.addComponent(new Animator())

    this.animation = new AnimationState('Button_Action', { looping: false })
    button.getComponent(Animator).addClip(this.animation)

    this.addComponent(new AudioSource(clickSound))

    this.address = address
    this.paymentAmount = paymentAmount
    this.action = action

    button.addComponent(
      new OnPointerDown(
        () => {
          this.openUI()
        },
        { hoverText: hoverText }
      )
    )

    const background = new UIImage(screenSpaceUI, imageTexture)

    background.name = 'background'
    background.width = 1024 * scale
    background.height = 448 * scale
    background.hAlign = 'center'
    background.vAlign = 'center'
    background.positionY = 0
    background.sourceLeft = 0
    background.sourceTop = 0
    background.sourceWidth = 1024
    background.sourceHeight = 429
    background.visible = false
    background.isPointerBlocker = false

    this.background = background

    const currentPayment = new UIText(background)
    currentPayment.value = this.paymentAmount.toString() + ' MANA'
    currentPayment.name = 'currentPayment'
    currentPayment.width = 200 * scale
    currentPayment.height = 100 * scale
    currentPayment.hAlign = 'center'
    currentPayment.vAlign = 'center'
    currentPayment.positionY = 18
    currentPayment.positionX = -37 * scale
    currentPayment.fontSize = 35 * scale
    currentPayment.vTextAlign = 'center'
    currentPayment.hTextAlign = 'center'
    currentPayment.color = Color4.FromHexString('#FF0050FF')

    const AcceptButton = new UIImage(background, imageTexture)
    AcceptButton.name = 'AcceptButton'
    AcceptButton.width = 460 * scale
    AcceptButton.height = 80 * scale
    AcceptButton.hAlign = 'center'
    AcceptButton.vAlign = 'center'
    AcceptButton.positionY = -60
    AcceptButton.positionX = -130
    AcceptButton.sourceLeft = 475
    AcceptButton.sourceTop = 425
    AcceptButton.sourceWidth = 460
    AcceptButton.sourceHeight = 74
    AcceptButton.isPointerBlocker = true
    AcceptButton.onClick = new OnClick(() => {
      this.closeUI()
      this.payFee()
    })

    const CancelButton = new UIImage(background, imageTexture)
    CancelButton.name = 'AcceptButton'
    CancelButton.width = 460 * scale
    CancelButton.height = 80 * scale
    CancelButton.hAlign = 'center'
    CancelButton.vAlign = 'center'
    CancelButton.positionY = -60
    CancelButton.positionX = 130
    CancelButton.sourceLeft = 0
    CancelButton.sourceTop = 425
    CancelButton.sourceWidth = 460
    CancelButton.sourceHeight = 74
    CancelButton.isPointerBlocker = true
    CancelButton.onClick = new OnClick(() => {
      this.closeUI()
    })
  }
  public openUI(): void {
    this.background.visible = true
    this.background.isPointerBlocker = true
  }
  public closeUI(): void {
    this.background.visible = false
    this.background.isPointerBlocker = false
  }

  public payFee(): void {
    log('PAYING FEE', this.paymentAmount)

    crypto.mana.send(this.address, this.paymentAmount, true).then(
      () => {
        this.action()
        this.getComponent(AudioSource).playOnce()
        this.animation.stop()
        this.animation.play()
      },
      (error) => {
        log(error)
      }
    )
  }
}"
/* paid button game */,"import { PaidButton } from './paidButton'
import { buildScene } from './builderContent'
import Door from './door'

export const sceneMessageBus = new MessageBus()

buildScene()

const door = new Door(
  new GLTFShape('models/Door_Fantasy.glb'),
  {
    position: new Vector3(9.275432586669922, 0, 9.929542541503906),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1, 1, 1)
  },
  'Open',
  'Close'
)

const button = new PaidButton(
  { position: new Vector3(7, 0, 11), rotation: Quaternion.Euler(0, 0, 0) },
  '0xe2b6024873d218B2E83B462D3658D8D7C3f55a18',
  10,
  'Open Door',
  () => {
    sceneMessageBus.emit('openDoor', {})
  }
)

sceneMessageBus.on('openDoor', ({ sender }) => {
  if (!door.isOpen) {
    door.toggle(true)
  }
})
sceneMessageBus.on('closeDoor', ({ sender }) => {
  if (door.isOpen) {
    door.toggle(false)
  }
})"
/* paid button door */,"const invisibleMaterial = new Material()
invisibleMaterial.albedoColor = new Color4(0, 0, 0, 0)

export default class Door extends Entity {
  isOpen: boolean = false
  openAnim: AnimationState
  closeAnim: AnimationState
  invisibleWall: BoxShape
  openClip = new AudioClip('sounds/open.mp3')
  closeClip = new AudioClip('sounds/close.mp3')

  constructor(
    model: GLTFShape,
    pos: TranformConstructorArgs,
    openAnim: string,
    closeAnim: string,
    open?: boolean,
    invisibleWall?: boolean,
    invisibleWallTransform?: TranformConstructorArgs
  ) {
    super()
    this.addComponent(new Transform(pos))
    this.addComponent(model)
    engine.addEntity(this)

    const animator = new Animator()
    this.openAnim = new AnimationState(openAnim, { looping: false })
    this.closeAnim = new AnimationState(closeAnim, { looping: false })
    animator.addClip(this.closeAnim)
    animator.addClip(this.openAnim)
    this.addComponent(animator)
    this.openAnim.stop()

    if (open) {
      this.isOpen = open
      this.openAnim.play()
    }

    if (invisibleWall === true) {
      const invisibleWallEntity = new Entity()
      invisibleWallEntity.addComponent(new Transform(invisibleWallTransform))
      this.invisibleWall = new BoxShape()
      invisibleWallEntity.addComponent(this.invisibleWall)
      this.invisibleWall.isPointerBlocker = true
      this.invisibleWall.withCollisions = true
      invisibleWallEntity.addComponent(invisibleMaterial)
      engine.addEntity(invisibleWallEntity)
    }
  }

  toggle(value: boolean, playSound = true) {
    if (this.isOpen === value) return
    this.isOpen = value

    if (playSound) {
      const source = new AudioSource(value ? this.openClip : this.closeClip)
      this.addComponentOrReplace(source)
      source.playing = true
    }

    this.openAnim.stop()
    this.closeAnim.stop()
    const clip = value ? this.openAnim : this.closeAnim
    clip.play()

    if (this.invisibleWall) {
      this.invisibleWall.isPointerBlocker = !value
      this.invisibleWall.withCollisions = !value
    }
  }
}"
/* paid button builder content */,"import { createChannel } from '../node_modules/decentraland-builder-scripts/channel'
import Script1 from '../ed36149f-76c5-45c4-a678-d4b31c4ed9ca/src/item'
import Script2 from '../1dc0345a-f5dd-43b6-bf14-30e7752101b4/src/item'

export function buildScene() {
  const _scene = new Entity('_scene')
  engine.addEntity(_scene)
  const transform = new Transform({
    position: new Vector3(0, 0, 0),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1, 1, 1)
  })
  _scene.addComponentOrReplace(transform)

  const cornerStoneBrickWall = new Entity('cornerStoneBrickWall')
  engine.addEntity(cornerStoneBrickWall)
  cornerStoneBrickWall.setParent(_scene)
  const transform2 = new Transform({
    position: new Vector3(14.232542037963867, 0, 10.096558570861816),
    rotation: new Quaternion(
      4.440892627896218e-16,
      0.7071068286895752,
      -8.429369557916289e-8,
      -0.7071068286895752
    ),
    scale: new Vector3(1.0000152587890625, 1, 1.0000152587890625)
  })
  cornerStoneBrickWall.addComponentOrReplace(transform2)
  const gltfShape = new GLTFShape(
    'models/Module_Stone_Curve_01/Module_Stone_Curve_01.glb'
  )
  gltfShape.withCollisions = true
  gltfShape.isPointerBlocker = true
  gltfShape.visible = true
  cornerStoneBrickWall.addComponentOrReplace(gltfShape)

  const cornerStoneBrickWall2 = new Entity('cornerStoneBrickWall2')
  engine.addEntity(cornerStoneBrickWall2)
  cornerStoneBrickWall2.setParent(_scene)
  cornerStoneBrickWall2.addComponentOrReplace(gltfShape)
  const transform3 = new Transform({
    position: new Vector3(2.5367984771728516, 0, 10.069063186645508),
    rotation: new Quaternion(
      1.693082319850249e-14,
      0.9999898672103882,
      -1.1920805320642103e-7,
      -0.004503994714468718
    ),
    scale: new Vector3(1.0000159740447998, 1, 1.0000159740447998)
  })
  cornerStoneBrickWall2.addComponentOrReplace(transform3)

  const cornerStoneBrickWall3 = new Entity('cornerStoneBrickWall3')
  engine.addEntity(cornerStoneBrickWall3)
  cornerStoneBrickWall3.setParent(_scene)
  cornerStoneBrickWall3.addComponentOrReplace(gltfShape)
  const transform4 = new Transform({
    position: new Vector3(2.5367984771728516, 0, 2.069063186645508),
    rotation: new Quaternion(
      -9.888260508664334e-16,
      0.7071068286895752,
      -8.429368847373553e-8,
      0.7071068286895752
    ),
    scale: new Vector3(1.0000181198120117, 1, 1.0000181198120117)
  })
  cornerStoneBrickWall3.addComponentOrReplace(transform4)

  const cornerStoneBrickWall4 = new Entity('cornerStoneBrickWall4')
  engine.addEntity(cornerStoneBrickWall4)
  cornerStoneBrickWall4.setParent(_scene)
  cornerStoneBrickWall4.addComponentOrReplace(gltfShape)
  const transform5 = new Transform({
    position: new Vector3(14.232542037963867, 0, 2.0965585708618164),
    rotation: new Quaternion(
      4.56593745492141e-15,
      0,
      -3.238694636572572e-15,
      -1
    ),
    scale: new Vector3(1.0000114440917969, 1, 1.0000114440917969)
  })
  cornerStoneBrickWall4.addComponentOrReplace(transform5)

  const stoneBrickWall = new Entity('stoneBrickWall')
  engine.addEntity(stoneBrickWall)
  stoneBrickWall.setParent(_scene)
  const transform6 = new Transform({
    position: new Vector3(10.822892189025879, 0, 2.072402000427246),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1.122812271118164, 1, 0.9999998807907104)
  })
  stoneBrickWall.addComponentOrReplace(transform6)
  const gltfShape2 = new GLTFShape(
    'models/Module_Stone_Straight_01/Module_Stone_Straight_01.glb'
  )
  gltfShape2.withCollisions = true
  gltfShape2.isPointerBlocker = true
  gltfShape2.visible = true
  stoneBrickWall.addComponentOrReplace(gltfShape2)

  const stoneBrickThreshold = new Entity('stoneBrickThreshold')
  engine.addEntity(stoneBrickThreshold)
  stoneBrickThreshold.setParent(_scene)
  const transform8 = new Transform({
    position: new Vector3(10.5, 0, 9.413106918334961),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1, 1, 1)
  })
  stoneBrickThreshold.addComponentOrReplace(transform8)
  const gltfShape3 = new GLTFShape(
    'models/Module_Stone_Straight_Door_01/Module_Stone_Straight_Door_01.glb'
  )
  gltfShape3.withCollisions = true
  gltfShape3.isPointerBlocker = true
  gltfShape3.visible = true
  stoneBrickThreshold.addComponentOrReplace(gltfShape3)

  const towerRoof = new Entity('towerRoof')
  engine.addEntity(towerRoof)
  towerRoof.setParent(_scene)
  const transform9 = new Transform({
    position: new Vector3(
      8.370111465454102,
      3.3169188499450684,
      5.924097061157227
    ),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1.67344331741333, 1, 1.2725991010665894)
  })
  towerRoof.addComponentOrReplace(transform9)
  const gltfShape4 = new GLTFShape('models/Roof_01/Roof_01.glb')
  gltfShape4.withCollisions = true
  gltfShape4.isPointerBlocker = true
  gltfShape4.visible = true
  towerRoof.addComponentOrReplace(gltfShape4)

  const entity = new Entity('entity')
  engine.addEntity(entity)
  entity.setParent(_scene)
  const gltfShape5 = new GLTFShape(
    'models/FloorFantasyRocks_03/FloorFantasyRocks_03.glb'
  )
  gltfShape5.withCollisions = true
  gltfShape5.isPointerBlocker = true
  gltfShape5.visible = true
  entity.addComponentOrReplace(gltfShape5)
  const transform10 = new Transform({
    position: new Vector3(8, 0, 8),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1, 1, 1)
  })
  entity.addComponentOrReplace(transform10)

  const signpostGolden = new Entity('signpostGolden')
  engine.addEntity(signpostGolden)
  signpostGolden.setParent(_scene)
  const transform11 = new Transform({
    position: new Vector3(6.374037265777588, 0, 3.6893038749694824),
    rotation: new Quaternion(0, 0, 0, 1),
    scale: new Vector3(1, 1, 1)
  })
  signpostGolden.addComponentOrReplace(transform11)

  const channelId = Math.random().toString(16).slice(2)
  const channelBus = new MessageBus()

  const script1 = new Script1()
  const script2 = new Script2()
  script1.init()
  script2.init()
  script2.spawn(
    signpostGolden,
    { text: 'VIP Lounge', fontSize: 20 },
    createChannel(channelId, signpostGolden, channelBus)
  )
}"
/* piano floor game */,"import * as utils from '@dcl/ecs-scene-utils'
import { PianoKey, keys } from './pianoKey'
import resources from './resources'

// Base scene
const baseScene = new Entity()
baseScene.addComponent(resources.models.baseScene)
engine.addEntity(baseScene)

// For transforming the piano
const scene = new Entity()
scene.addComponent(
  new Transform({
    position: new Vector3(8, 0, 8),
    rotation: Quaternion.Euler(0, 0, 0)
  })
)
engine.addEntity(scene)

const keyShape = new PlaneShape()

// White keys
const whiteKeySounds: AudioClip[] = [
  resources.sounds.whiteKeys.c3,
  resources.sounds.whiteKeys.d3,
  resources.sounds.whiteKeys.e3,
  resources.sounds.whiteKeys.f3,
  resources.sounds.whiteKeys.g3,
  resources.sounds.whiteKeys.a3,
  resources.sounds.whiteKeys.b3,
  resources.sounds.whiteKeys.c4,
  resources.sounds.whiteKeys.d4,
  resources.sounds.whiteKeys.e4,
  resources.sounds.whiteKeys.f4,
  resources.sounds.whiteKeys.g4,
  resources.sounds.whiteKeys.a4,
  resources.sounds.whiteKeys.b4
]

let whiteKeyXPos = -5.55

for (let i = 0; i < whiteKeySounds.length; i++) {
  const key = new PianoKey(
    keyShape,
    new Transform({
      position: new Vector3(whiteKeyXPos, 0.11, 0),
      scale: new Vector3(0.7, 4, 0.5),
      rotation: Quaternion.Euler(90, 0, 0)
    }),
    Color3.White(),
    whiteKeySounds[i],
    resources.trigger.triggerWhitePianoKey,
    i
  )
  key.setParent(scene)
  keys.push(key)
  whiteKeyXPos += 0.8
}

// Black keys
const blackKeySounds: AudioClip[] = [
  resources.sounds.blackKeys.cSharp3,
  resources.sounds.blackKeys.dSharp3,
  resources.sounds.blackKeys.fSharp3,
  resources.sounds.blackKeys.gSharp3,
  resources.sounds.blackKeys.aSharp3,
  resources.sounds.blackKeys.cSharp4,
  resources.sounds.blackKeys.dSharp4,
  resources.sounds.blackKeys.fSharp4,
  resources.sounds.blackKeys.gSharp4,
  resources.sounds.blackKeys.aSharp4
]

let blackKeyXPos = -5.15
let skipKey = 1

for (let i = 0; i < blackKeySounds.length; i++) {
  const key = new PianoKey(
    keyShape,
    new Transform({
      position: new Vector3(blackKeyXPos, 0.12, 1),
      scale: new Vector3(0.45, 2, 0.5),
      rotation: Quaternion.Euler(90, 0, 0)
    }),
    Color3.Black(),
    blackKeySounds[i],
    resources.trigger.triggerBlackPianoKey,
    i + whiteKeySounds.length
  )
  key.setParent(scene)
  keys.push(key)

  // Skip key
  skipKey++
  skipKey % 3 !== 0 ? (blackKeyXPos += 0.8) : (blackKeyXPos += 1.6)
  if (skipKey === 6) skipKey = 1
}

// Modify player's trigger shape
utils.TriggerSystem.instance.setCameraTriggerShape(
  new utils.TriggerBoxShape(
    new Vector3(0.5, 0.25, 0.5),
    new Vector3(0, -0.5, 0)
  )
)"
/* piano floor piano key */,"import * as utils from '@dcl/ecs-scene-utils'

export const sceneMessageBus = new MessageBus()

export const keys: PianoKey[] = []

export class PianoKey extends Entity {
  material: Material = new Material()
  onColor: Color3 = new Color3(1.75, 1.25, 0.0) // Orange glow
  offColor: Color3 = Color3.Black() // To zero out emissive
  note: number

  constructor(
    shape: PlaneShape,
    transform: Transform,
    color: Color3,
    sound: AudioClip,
    trigger: utils.TriggerBoxShape,
    note: number
  ) {
    super()
    engine.addEntity(this)
    this.addComponent(shape)
    this.addComponent(transform)
    this.material.albedoColor = color
    this.material.metallic = 0.0
    this.material.roughness = 1.0
    this.addComponent(this.material)

    // note ID
    this.note = note

    // Sound
    this.addComponent(new AudioSource(sound))

    // Create trigger
    this.addComponent(
      new utils.TriggerComponent(trigger, {
        onCameraEnter: () => {
          log('enter trigger: ', sound.url)
          sceneMessageBus.emit('noteOn', { note: this.note })
        },
        onCameraExit: () => {
          sceneMessageBus.emit('noteOff', { note: this.note })
        }
      })
    )
  }
  public play(): void {
    this.getComponent(AudioSource).playOnce()
    this.material.emissiveColor = this.onColor
  }
  public end(): void {
    this.material.emissiveColor = this.offColor
  }
}

sceneMessageBus.on('noteOn', (e) => {
  keys[e.note].play()
})

sceneMessageBus.on('noteOff', (e) => {
  keys[e.note].end()
})"
/* piano floor resources */,"import * as utils from '@dcl/ecs-scene-utils'

export default {
  models: {
    baseScene: new GLTFShape('models/baseScene.glb')
  },
  sounds: {
    whiteKeys: {
      c3: new AudioClip('sounds/whiteKeys/c3.mp3'),
      d3: new AudioClip('sounds/whiteKeys/d3.mp3'),
      e3: new AudioClip('sounds/whiteKeys/e3.mp3'),
      f3: new AudioClip('sounds/whiteKeys/f3.mp3'),
      g3: new AudioClip('sounds/whiteKeys/g3.mp3'),
      a3: new AudioClip('sounds/whiteKeys/a3.mp3'),
      b3: new AudioClip('sounds/whiteKeys/b3.mp3'),
      c4: new AudioClip('sounds/whiteKeys/c4.mp3'),
      d4: new AudioClip('sounds/whiteKeys/d4.mp3'),
      e4: new AudioClip('sounds/whiteKeys/e4.mp3'),
      f4: new AudioClip('sounds/whiteKeys/f4.mp3'),
      g4: new AudioClip('sounds/whiteKeys/g4.mp3'),
      a4: new AudioClip('sounds/whiteKeys/a4.mp3'),
      b4: new AudioClip('sounds/whiteKeys/b4.mp3')
    },
    blackKeys: {
      cSharp3: new AudioClip('sounds/blackKeys/cSharp3.mp3'),
      dSharp3: new AudioClip('sounds/blackKeys/dSharp3.mp3'),
      fSharp3: new AudioClip('sounds/blackKeys/fSharp3.mp3'),
      gSharp3: new AudioClip('sounds/blackKeys/gSharp3.mp3'),
      aSharp3: new AudioClip('sounds/blackKeys/aSharp3.mp3'),
      cSharp4: new AudioClip('sounds/blackKeys/cSharp4.mp3'),
      dSharp4: new AudioClip('sounds/blackKeys/dSharp4.mp3'),
      fSharp4: new AudioClip('sounds/blackKeys/fSharp4.mp3'),
      gSharp4: new AudioClip('sounds/blackKeys/gSharp4.mp3'),
      aSharp4: new AudioClip('sounds/blackKeys/aSharp4.mp3')
    }
  },
  trigger: {
    triggerWhitePianoKey: new utils.TriggerBoxShape(
      new Vector3(0.35, 3, 2),
      new Vector3(0, 0, -1)
    ),
    triggerBlackPianoKey: new utils.TriggerBoxShape(
      new Vector3(0.35, 3, 2),
      Vector3.Zero()
    )
  }
}"
/* clap meter */,"import * as utils from ""@dcl/ecs-scene-utils""

// Config
const START_ANGLE = 350
const END_ANGLE = 190

// Cooldown config
@Component(""cooldownFlag"")
class CooldownFlag {}
const CLAP_COOLDOWN_TIME = 6000 // Clap animation length
const COOLDOWN_SPEED = 10
const ANGLE_INCREMENT = 1 // How many degrees does the needle move

const clapMeterNeedle = new Entity()

export class ClapMeter extends Entity {
  constructor(transform: Transform) {
    super()
    engine.addEntity(this)
    this.addComponent(new GLTFShape(""models/clapMeterBoard.glb""))
    this.addComponent(transform)

    // Clap meter needle
    clapMeterNeedle.addComponent(new GLTFShape(""models/clapMeterNeedle.glb""))
    clapMeterNeedle.addComponent(new Transform({ position: new Vector3(0, 0.05, 0) }))
    clapMeterNeedle.setParent(this)

    // Set needle to start angle
    clapMeterNeedle.getComponent(Transform).rotation.setEuler(0, 0, START_ANGLE)
  }
  updateCooldown(): void {
    clapMeterNeedle.addComponentOrReplace(new CooldownFlag())
    clapMeterNeedle.addComponentOrReplace(
      new utils.Delay(CLAP_COOLDOWN_TIME, () => {
        clapMeterNeedle.removeComponent(CooldownFlag)
      })
    )
  }
  updateNeedle(): void {
    let currentNeedleAngle = clapMeterNeedle.getComponent(Transform).rotation.eulerAngles.z
    let currentNeedleRotation = clapMeterNeedle.getComponent(Transform).rotation

    if (currentNeedleAngle >= END_ANGLE) {
      currentNeedleRotation.setEuler(0, 0, currentNeedleAngle - ANGLE_INCREMENT)
    }
  }
}

// Cooldown System
export class CooldownSystem implements ISystem {
  update(dt: number) {
    if (clapMeterNeedle.hasComponent(CooldownFlag)) return

    let currentNeedleAngle = clapMeterNeedle.getComponent(Transform).rotation.eulerAngles.z
    let currentNeedleRotation = clapMeterNeedle.getComponent(Transform).rotation

    if (currentNeedleAngle <= START_ANGLE) {
      currentNeedleRotation.setEuler(0, 0, currentNeedleAngle + COOLDOWN_SPEED * dt)
    }
  }
}

engine.addSystem(new CooldownSystem())"
/* clap meter game */ ,"import { ClapMeter } from ""./clapMeter""
import * as ui from ""@dcl/ui-scene-utils""

// Multiplayer (p2p)
const sceneMessageBus = new MessageBus()

// Setup scene
const base = new Entity()
base.addComponent(new GLTFShape(""models/baseDarkWithCollider.glb""))
engine.addEntity(base)

const clapMeterBoard = new ClapMeter(new Transform({ position: new Vector3(8, 0.05, 8) }))

// Listen for claps
onPlayerExpressionObservable.add(({ expressionId }) => {
  if (expressionId == ""clap"") {
    sceneMessageBus.emit(""updateClapMeter"", {})
  }
})

// Update the clap meter for all players
sceneMessageBus.on(""updateClapMeter"", () => {
  clapMeterBoard.updateCooldown()
  clapMeterBoard.updateNeedle()
})

// UI
const message = ""For the best experience, \nswitch to 3rd person view by \npressing 'V' key""
ui.displayAnnouncement(message, -1)

onCameraModeChangedObservable.add(({ cameraMode }) => {
  if (cameraMode == 0) ui.displayAnnouncement(message, -1)
  if (cameraMode == 1) ui.hideAnnouncements()
})"
/* button for entity */,"export class Button extends Entity {
  clickAnim: AnimationState
  constructor(
    model: string,
    transform: TranformConstructorArgs,
    animationName: string,
    parent?: Entity
  ) {
    super()
    engine.addEntity(this)

    this.addComponent(new GLTFShape(model))

    this.addComponentOrReplace(new Transform(transform))

    if (parent) {
      this.setParent(parent)
    }

    this.addComponent(new AudioSource(new AudioClip('sounds/click.mp3')))

    this.addComponent(new Animator())
    this.clickAnim = new AnimationState(animationName, { looping: false })
    this.getComponent(Animator).addClip(this.clickAnim)
  }

  public press(): void {
    this.clickAnim.play(true)
    this.getComponent(AudioSource).playOnce()
  }
}

export class Switch extends Entity {
  onAnim: AnimationState
  offAnim: AnimationState
  isClicked: boolean = false
  constructor(
    model: string,
    transform: TranformConstructorArgs,
    onAnim: string,
    offAnim: string,
    parent?: Entity
  ) {
    super()
    engine.addEntity(this)

    this.addComponent(new GLTFShape(model))

    if (parent) {
      this.setParent(parent)
    }

    this.addComponent(new Transform(transform))

    this.addComponent(new AudioSource(new AudioClip('sounds/click.mp3')))

    this.addComponent(new Animator())
    this.onAnim = new AnimationState(onAnim, { looping: false })
    this.offAnim = new AnimationState(offAnim, { looping: false })
    this.getComponent(Animator).addClip(this.onAnim)
    this.getComponent(Animator).addClip(this.offAnim)
    this.onAnim.stop()
  }

  public toggle(value: boolean): void {
    if (this.isClicked === value) return
    this.isClicked = value

    const clip = value ? this.onAnim : this.offAnim
    clip.play()

    this.getComponent(AudioSource).playOnce()
  }
}"
/* console */,"import { Button } from './button'

export class Console extends Entity {
  clickAnim: AnimationState
  constructor(
    transform: TranformConstructorArgs,
    parent: Entity,
    model: string,
    targetRing: number,
    button1Model: string,
    button1Anim: string,
    button2Model: string,
    button2Anim: string,
    button3Model: string,
    button3Anim: string,
    messagebus: MessageBus
  ) {
    super()
    engine.addEntity(this)
    this.setParent(parent)

    this.addComponent(new GLTFShape(model))
    this.addComponent(new Transform(transform))

    const button1 = new Button(button1Model, {}, button1Anim, this)
    const button2 = new Button(button2Model, {}, button2Anim, this)
    const button3 = new Button(button3Model, {}, button3Anim, this)

    button1.addComponent(
      new OnPointerDown(() => {
        button1.press()
        messagebus.emit('fountainAnim', { ring: targetRing, anim: 1 })
      })
    )

    button2.addComponent(
      new OnPointerDown(() => {
        button2.press()
        messagebus.emit('fountainAnim', { ring: targetRing, anim: 2 })
      })
    )

    button3.addComponent(
      new OnPointerDown(() => {
        button3.press()
        messagebus.emit('fountainAnim', { ring: targetRing, anim: 3 })
      })
    )
  }
}"
/* ring */,"export class Ring extends Entity {
  animation1: AnimationState
  animation2: AnimationState
  animation3: AnimationState

  constructor(
    transform: TranformConstructorArgs,
    model: string,
    animation1: string,
    animation2: string,
    animation3: string,
    parent: Entity
  ) {
    super()
    engine.addEntity(this)
    this.setParent(parent)

    this.addComponent(new GLTFShape(model))
    this.addComponent(new Transform(transform))

    this.addComponent(new Animator())

    this.animation1 = new AnimationState(animation1, { looping: false })
    this.getComponent(Animator).addClip(this.animation1)
    this.animation2 = new AnimationState(animation2, { looping: false })
    this.getComponent(Animator).addClip(this.animation2)
    this.animation3 = new AnimationState(animation3, { looping: false })
    this.getComponent(Animator).addClip(this.animation3)
  }
  public play1(): void {
    log('playing1')

    this.animation1.play(true)
  }
  public play2(): void {
    log('playing2')

    this.animation2.play(true)
  }
  public play3(): void {
    log('playing3')

    this.animation3.play(true)
  }
}"
/* randomizer */,"import { Ring } from './ring'

export class RandomFountain implements ISystem {
  ringOneActive: boolean = false
  ringTwoActive: boolean = false
  ringThreeActive: boolean = false
  ringFourActive: boolean = false
  animDuration: number
  timer1: number
  timer2: number
  timer3: number
  timer4: number
  mainTimer: number
  playingMode: number = 0
  rings: Ring[]

  constructor(rings: Ring[], animDuration: number) {
    this.animDuration = animDuration

    this.timer1 = 0
    this.timer2 = 0
    this.timer3 = 0
    this.timer4 = 0
    this.mainTimer = 0
    this.playingMode = 1
    this.rings = rings
  }
  update(dt: number) {
    if (this.playingMode === 0) {
      // in free control mode
      return
    }

    if (this.playingMode === 1) {
      // random mode

      if (this.ringOneActive) {
        this.timer1 -= dt
        if (this.timer1 < 0) {
          this.ringOneActive = false
        }
      }
      if (this.ringTwoActive) {
        this.timer2 -= dt
        if (this.timer2 < 0) {
          this.ringTwoActive = false
        }
      }
      if (this.ringThreeActive) {
        this.timer3 -= dt
        if (this.timer3 < 0) {
          this.ringThreeActive = false
        }
      }

      if (this.ringFourActive) {
        this.timer4 -= dt
        if (this.timer4 < 0) {
          this.ringFourActive = false
        }
      }

      this.mainTimer += dt

      if (this.mainTimer > this.animDuration / 2) {
        const randomIndex = Math.floor(Math.random() * 1500)
        //log(randomIndex)
        switch (randomIndex) {
          case 1:
            if (this.ringOneActive) break
            this.rings[0].play1()
            this.ringOneActive = true
            this.timer1 = this.animDuration
            this.mainTimer = 0
            break
          case 2:
            if (this.ringOneActive) break
            this.rings[0].play2()
            this.ringOneActive = true
            this.timer1 = this.animDuration
            this.mainTimer = 0
            break
          case 3:
            if (this.ringOneActive) break
            this.rings[0].play3()
            this.ringOneActive = true
            this.timer1 = this.animDuration
            this.mainTimer = 0
            break

          case 4:
            if (this.ringTwoActive) break
            this.rings[1].play1()
            this.ringTwoActive = true
            this.timer2 = this.animDuration
            this.mainTimer = 0
            break
          case 5:
            if (this.ringTwoActive) break
            this.rings[1].play2()
            this.ringTwoActive = true
            this.timer2 = this.animDuration
            this.mainTimer = 0
            break
          case 6:
            if (this.ringTwoActive) break
            this.rings[1].play3()
            this.ringTwoActive = true
            this.timer2 = this.animDuration
            this.mainTimer = 0
            break

          case 5:
            if (this.ringThreeActive) break
            this.rings[2].play1()
            this.ringThreeActive = true
            this.timer3 = this.animDuration
            this.mainTimer = 0
            break
          case 6:
            if (this.ringThreeActive) break
            this.rings[2].play2()
            this.ringThreeActive = true
            this.timer3 = this.animDuration
            this.mainTimer = 0
            break
          case 7:
            if (this.ringThreeActive) break
            this.rings[2].play3()
            this.ringThreeActive = true
            this.timer3 = this.animDuration
            this.mainTimer = 0
            break

          case 8:
            if (this.ringFourActive) break
            this.rings[3].play1()
            this.ringFourActive = true
            this.timer4 = this.animDuration
            this.mainTimer = 0
            break
          case 9:
            if (this.ringFourActive) break
            this.rings[3].play2()
            this.ringFourActive = true
            this.timer4 = this.animDuration
            this.mainTimer = 0
            break
          case 10:
            if (this.ringFourActive) break
            this.rings[3].play3()
            this.ringFourActive = true
            this.timer4 = this.animDuration
            this.mainTimer = 0
            break
        }
      }
    }
  }
}"
/* block fountain game */,"import * as utils from '@dcl/ecs-scene-utils'
import { Ring } from './ring'
import { Console } from './console'
import { RandomFountain } from './randomizer'

const sceneMessageBus = new MessageBus()

const rings: Ring[] = []

const base = new Entity()
base.addComponent(new GLTFShape('models/fountain/Base.glb'))
base.addComponent(
  new Transform({
    position: new Vector3(24, 0, 24)
  })
)
engine.addEntity(base)

const ring1 = new Ring(
  {
    position: new Vector3(0, -0.55, 0)
  },
  'models/fountain/FirstRing.glb',
  '1stRing_Action_01',
  '1stRing_Action_02',
  '1stRing_Action_03',
  base
)

rings.push(ring1)

const ring2 = new Ring(
  {
    position: new Vector3(0, -0.6, 0)
  },
  'models/fountain/SecondRing.glb',
  '2ndRing_Action_01',
  '2ndRing_Action_02',
  '2ndRing_Action_03',
  base
)

rings.push(ring2)

const ring3 = new Ring(
  {
    position: new Vector3(0, -0.8, 0)
  },
  'models/fountain/ThirdRing.glb',
  '3rdRing_Action_01',
  '3rdRing_Action_02',
  '3rdRing_Action_03',
  base
)
rings.push(ring3)

const ring4 = new Ring(
  {
    position: new Vector3(0, -0.8, 0)
  },
  'models/fountain/FourthRing.glb',
  '4thRing_Action_01',
  '4thRing_Action_02',
  '4thRing_Action_03',
  base
)
rings.push(ring4)

const cyanConsole = new Console(
  { position: new Vector3(-23, 0, 0) },
  base,
  'models/buttons/Cyan/Base/BaseCyan.glb',
  3,
  'models/buttons/Cyan/Buttons/ButtonA_Cyan.glb',
  'ButtonA_Action',
  'models/buttons/Cyan/Buttons/ButtonB_Cyan.glb',
  'ButtonB_Action',
  'models/buttons/Cyan/Buttons/ButtonC_Cyan.glb',
  'ButtonC_Action',
  sceneMessageBus
)

const redConsole = new Console(
  {
    position: new Vector3(0, 0, 23),
    rotation: Quaternion.Euler(0, 90, 0)
  },
  base,
  'models/buttons/Red/Base/BaseRed.glb',
  2,
  'models/buttons/Red/Buttons/ButtonA_Red.glb',
  'ButtonA_Action',
  'models/buttons/Red/Buttons/ButtonB_Red.glb',
  'ButtonB_Action',
  'models/buttons/Red/Buttons/ButtonC_Red.glb',
  'ButtonC_Action',
  sceneMessageBus
)

const violetConsole = new Console(
  {
    position: new Vector3(23, 0, 0),
    rotation: Quaternion.Euler(0, 180, 0)
  },
  base,
  'models/buttons/Violet/Base/BaseViolet.glb',
  1,
  'models/buttons/Violet/Buttons/ButtonA_Violet.glb',
  'ButtonA_Action',
  'models/buttons/Violet/Buttons/ButtonB_Violet.glb',
  'ButtonB_Action',
  'models/buttons/Violet/Buttons/ButtonC_Violet.glb',
  'ButtonC_Action',
  sceneMessageBus
)

const yellowConsole = new Console(
  { position: new Vector3(0, 0, -23), rotation: Quaternion.Euler(0, 270, 0) },
  base,
  'models/buttons/Yellow/Base/BaseYellow.glb',
  0,
  'models/buttons/Yellow/Buttons/ButtonA_Yellow.glb',
  'ButtonA_Action',
  'models/buttons/Yellow/Buttons/ButtonB_Yellow.glb',
  'ButtonB_Action',
  'models/buttons/Yellow/Buttons/ButtonC_Yellow.glb',
  'ButtonC_Action',
  sceneMessageBus
)

sceneMessageBus.on('fountainAnim', (e) => {
  fountainPlayer.playingMode = 0
  base.addComponentOrReplace(
    new utils.Delay(20000, () => {
      fountainPlayer.playingMode = 1
    })
  )
  switch (e.anim) {
    case 1:
      rings[e.ring].play1()
      break
    case 2:
      rings[e.ring].play2()
      break
    case 3:
      rings[e.ring].play3()
      break
  }
})

/// RANDOMIZER

const fountainPlayer = new RandomFountain(rings, 10)

engine.addSystem(fountainPlayer)"
/* danse area */,"import * as utils from '@dcl/ecs-scene-utils'
import { isPreviewMode } from '@decentraland/EnvironmentAPI'
import { triggerEmote, PredefinedEmote } from '@decentraland/RestrictedActions'

//// List of dance areas - add here the locations where you want dancing to happen

export const danceAreas: any = [
  {
    transform: {
      position: new Vector3(4, 0, 4),
      scale: new Vector3(4, 4, 4)
    },
    type: PredefinedEmote.ROBOT
  },
  {
    transform: {
      position: new Vector3(10, 0, 10),
      scale: new Vector3(4, 4, 4)
    },
    type: PredefinedEmote.DISCO
  }
]

////// DEBUG FLAG - Set to true to view all dance areas
const DEBUG_FLAG = false

///// This system acts on the danceAreas defined above

export class DanceSystem {
  length = 11
  timer = 2
  routine: any
  danceFunction: () => void = () => {
    //   log('pointer Up')
    this.dance()
  }

  routines: PredefinedEmote[] = [
    PredefinedEmote.ROBOT,
    PredefinedEmote.TIK,
    PredefinedEmote.TEKTONIK,
    PredefinedEmote.HAMMER,
    PredefinedEmote.HEAD_EXPLODDE,
    PredefinedEmote.HANDS_AIR,
    PredefinedEmote.DISCO,
    PredefinedEmote.DAB
  ]

  constructor(routine: PredefinedEmote) {
    this.routine = routine
  }

  update(dt: number) {
    if (this.timer > 0) {
      this.timer -= dt
    } else {
      this.dance()
    }
  }
  dance() {
    this.timer = this.length
    if (this.routine === 'all') {
      const rand = Math.floor(Math.random() * (this.routine.length - 0) + 0)
      void triggerEmote({ predefined: this.routines[rand] })
    } else {
      void triggerEmote({ predefined: this.routine })
    }
  }
  addEvents() {
    Input.instance.subscribe(
      'BUTTON_UP',
      ActionButton.FORWARD,
      false,
      this.danceFunction
    )

    Input.instance.subscribe(
      'BUTTON_UP',
      ActionButton.BACKWARD,
      false,
      this.danceFunction
    )

    Input.instance.subscribe(
      'BUTTON_UP',
      ActionButton.RIGHT,
      false,
      this.danceFunction
    )

    Input.instance.subscribe(
      'BUTTON_UP',
      ActionButton.LEFT,
      false,
      this.danceFunction
    )
  }
  removeEvents() {
    Input.instance.unsubscribe(
      'BUTTON_UP',
      ActionButton.FORWARD,
      this.danceFunction
    )

    Input.instance.unsubscribe(
      'BUTTON_UP',
      ActionButton.BACKWARD,
      this.danceFunction
    )

    Input.instance.unsubscribe(
      'BUTTON_UP',
      ActionButton.RIGHT,
      this.danceFunction
    )

    Input.instance.unsubscribe(
      'BUTTON_UP',
      ActionButton.LEFT,
      this.danceFunction
    )
  }
}

for (const i in danceAreas) {
  const area = new Entity('dance-' + i)
  area.addComponent(new Transform(danceAreas[i].transform))

  void executeTask(async () => {
    if (DEBUG_FLAG && (await isPreviewMode())) {
      area.addComponent(new BoxShape())
      area.getComponent(BoxShape).withCollisions = false
    }
  })

  engine.addEntity(area)
  const dsystem = new DanceSystem(danceAreas[i].type)

  area.addComponent(
    new utils.TriggerComponent(
      new utils.TriggerBoxShape(
        new Vector3(
          area.getComponent(Transform).scale.x,
          area.getComponent(Transform).scale.y,
          area.getComponent(Transform).scale.z
        ),
        new Vector3(0, 2.5, 0)
      ),
      {
        enableDebug: false,
        onCameraEnter: () => {
          engine.addSystem(dsystem)
          dsystem.addEvents()
        },
        onCameraExit: () => {
          dsystem.removeEvents()
          engine.removeSystem(dsystem)
        }
      }
    )
  )
}"
/* shooting range leaderboard entity */,"export class Leaderboard extends Entity {
  constructor(model: GLTFShape, position: Vector3, rotation: Quaternion, scale: Vector3) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Transform({ position, rotation, scale }))
    this.addComponent(new TextShape('Leaderboard\n\n1. Player 1\n2. Player 2\n3. Player 3')) // Display the leaderboard
  }
}"
/* auto danse area */ ,"const base = new Entity()
base.addComponent(new GLTFShape('models/baseLight.glb'))
engine.addEntity(base)

const platform1 = new Entity()
platform1.addComponent(new GLTFShape('models/platform.glb'))
platform1.addComponent(
  new Transform({
    position: new Vector3(4, -0.5, 4),
    scale: new Vector3(2, 1, 2)
  })
)
engine.addEntity(platform1)

const platform2 = new Entity()
platform2.addComponent(new GLTFShape('models/platform.glb'))
platform2.addComponent(
  new Transform({
    position: new Vector3(10, -0.5, 10),
    scale: new Vector3(2, 1, 2)
  })
)
engine.addEntity(platform2)"
/* tin can alley */,"import { Can, CanFlag } from ""./modules/can""
import { loadColliders } from ""./modules/colliderSetup""
import { Rifle, Cooldown } from ""./modules/rifle""
import { Sound } from ""./modules/sound""

// Sounds
const shotWoodSound = new Sound(new AudioClip(""sounds/shotWood.mp3""), false)

// Setup models
const base = new Entity()
base.addComponent(new GLTFShape(""models/baseLight.glb""))
engine.addEntity(base)

const tinCanAlley = new Entity()
tinCanAlley.addComponent(new GLTFShape(""models/tinCanAlley.glb""))
tinCanAlley.addComponent(new Transform())
engine.addEntity(tinCanAlley)

const gun = new Rifle(new GLTFShape(""models/rifle.glb""), new Transform())
gun.getComponent(Transform).position.set(0.075, -0.5, 0.2)
gun.getComponent(Transform).rotation = Quaternion.Euler(-5, 0, 0)
gun.setParent(Attachable.FIRST_PERSON_CAMERA)

// Setup our world
const world = new CANNON.World()
world.quatNormalizeSkip = 0
world.quatNormalizeFast = false
world.gravity.set(0, -9.82, 0) // m/sÂ²

// Load colliders
loadColliders(world)

// Setup ground material
const physicsMaterial = new CANNON.Material(""groundMaterial"")
const ballContactMaterial = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, { friction: 1, restitution: 0.5 })
world.addContactMaterial(ballContactMaterial)

// Setup cans
// Bottom row
const can1 = new Can(new Transform({ position: new Vector3(7.4, 1.42, 9.535) }), physicsMaterial, world)
const can2 = new Can(new Transform({ position: new Vector3(7.7, 1.42, 9.535) }), physicsMaterial, world)
const can3 = new Can(new Transform({ position: new Vector3(8, 1.42, 9.535) }), physicsMaterial, world)
const can4 = new Can(new Transform({ position: new Vector3(8.3, 1.42, 9.535) }), physicsMaterial, world)
const can5 = new Can(new Transform({ position: new Vector3(8.6, 1.42, 9.535) }), physicsMaterial, world)

// 2nd row
const can6 = new Can(new Transform({ position: new Vector3(7.55, 1.706, 9.535) }), physicsMaterial, world)
const can7 = new Can(new Transform({ position: new Vector3(7.85, 1.706, 9.535) }), physicsMaterial, world)
const can8 = new Can(new Transform({ position: new Vector3(8.15, 1.706, 9.535) }), physicsMaterial, world)
const can9 = new Can(new Transform({ position: new Vector3(8.45, 1.706, 9.535) }), physicsMaterial, world)

// 3rd row
const can10 = new Can(new Transform({ position: new Vector3(7.7, 1.992, 9.535) }), physicsMaterial, world)
const can11 = new Can(new Transform({ position: new Vector3(8, 1.992, 9.535) }), physicsMaterial, world)
const can12 = new Can(new Transform({ position: new Vector3(8.3, 1.992, 9.535) }), physicsMaterial, world)

// 4th row
const can13 = new Can(new Transform({ position: new Vector3(7.85, 2.278, 9.535) }), physicsMaterial, world)
const can14 = new Can(new Transform({ position: new Vector3(8.15, 2.278, 9.535) }), physicsMaterial, world)

// Top can
const can15 = new Can(new Transform({ position: new Vector3(8, 2.564, 9.535) }), physicsMaterial, world)

const cans: Can[] = [can1, can2, can3, can4, can5, can6, can7, can8, can9, can10, can11, can12, can13, can14, can15]

// Create a ground plane and apply physics material
const groundShape: CANNON.Plane = new CANNON.Plane()
const groundBody: CANNON.Body = new CANNON.Body({ mass: 0 })
groundBody.addShape(groundShape)
groundBody.material = physicsMaterial
groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2) // Reorient ground plane to be in the y-axis
groundBody.position.set(0, 0.05, 0)
world.addBody(groundBody) // Add ground body to world

// Set high to prevent tunnelling
const FIXED_TIME_STEPS = 1.0 / 60.0
const MAX_TIME_STEPS = 30

class PhysicsSystem implements ISystem {
  update(dt: number): void {
    world.step(FIXED_TIME_STEPS, dt, MAX_TIME_STEPS)
    for (let i = 0; i < cans.length; i++) {
      cans[i].getComponent(Transform).position.copyFrom(cans[i].body.position)
      cans[i].getComponent(Transform).rotation.copyFrom(cans[i].body.quaternion)
    }
  }
}
engine.addSystem(new PhysicsSystem())

// Controls
const input = Input.instance
input.subscribe(""BUTTON_DOWN"", ActionButton.POINTER, true, (event) => {
  if(gun.hasComponent(Cooldown)) return

  gun.playFireAnim()
  if (event.hit?.meshName == ""hit_collider"") {
    let forwardVector: Vector3 = Vector3.Forward().rotate(Camera.instance.rotation)
    let entity = engine.entities[event.hit?.entityId] as Can
    entity.hasComponent(CanFlag)? entity.hit(forwardVector, event.hit?.hitPoint) : shotWoodSound.getComponent(AudioSource).playOnce()
  }
})"
/* rifle tin can alley */,"import { Sound } from ""./sound""
import * as utils from ""@dcl/ecs-scene-utils""

// Cooldown for firing the rifle
@Component(""cooldown"")
export class Cooldown {}

// Sounds
const shotSound = new Sound(new AudioClip(""sounds/shotSilencer.mp3""), false)

export class Rifle extends Entity {
  constructor(model: GLTFShape, transform: Transform) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(transform)

    this.addComponent(new Animator())
    this.getComponent(Animator).addClip(new AnimationState(""Blank"", { looping: false }))
    this.getComponent(Animator).addClip(new AnimationState(""Fire"", { looping: false }))
    this.getComponent(Animator).getClip(""Blank"").play()
  }

  // Play gun fire animation
  playFireAnim() {
    shotSound.getComponent(AudioSource).playOnce()
    this.stopAnimations()
    this.getComponent(Animator).getClip(""Fire"").play()
    this.addComponent(new Cooldown())
    this.addComponent(
      new utils.Delay(333, () => {
        this.removeComponent(Cooldown)
      })
    )
  }

  // Bug workaround: otherwise the next animation clip won't play
  stopAnimations() {
    this.getComponent(Animator).getClip(""Blank"").stop()
    this.getComponent(Animator).getClip(""Fire"").stop()
  }
}"
/* collider setup tin can alley*/,"import { tinCanAlleyMeshVertices, tinCanAlleyMeshIndices } from ""./meshData/tinCanAlleyMesh""

export function loadColliders(cannonWorld: CANNON.World): void {
  // Trimesh for the tin can alley model
  let tinCanAlleyShape = new CANNON.Trimesh(tinCanAlleyMeshVertices, tinCanAlleyMeshIndices)
  const tinCanAlleyBody = new CANNON.Body({
    mass: 0,
    position: new CANNON.Vec3(16, 0, 0),
  })
  tinCanAlleyBody.addShape(tinCanAlleyShape)
  cannonWorld.addBody(tinCanAlleyBody)

  // Invisible walls
  //#region 
  const wallShape = new CANNON.Box(new CANNON.Vec3(8, 32, 0.5))
  const wallNorth = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(8, 0, 16.45),
  })
  cannonWorld.addBody(wallNorth)

  const wallSouth = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(8, 0, -0.45),
  })
  cannonWorld.addBody(wallSouth)

  const wallWest = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(-0.45, 0, 8),
  })
  wallWest.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2)
  cannonWorld.addBody(wallWest)

  const wallEast = new CANNON.Body({
    mass: 0,
    shape: wallShape,
    position: new CANNON.Vec3(16.45, 0, 8),
  })
  wallEast.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI / 2)
  cannonWorld.addBody(wallEast)
  //#endregion

  // Box colliders for the stand
  //#region
  const playerStand = new CANNON.Body({
    shape: new CANNON.Box(new CANNON.Vec3(1, 0.638, 0.061)),
    position: new CANNON.Vec3(8, 0.689, 6.75),
  })
  cannonWorld.addBody(playerStand)

  const playerStandLip = new CANNON.Body({
    shape: new CANNON.Box(new CANNON.Vec3(1, 0.045, 0.0265)),
    position: new CANNON.Vec3(8, 1.372, 6.835),
  })
  cannonWorld.addBody(playerStandLip)

  const mainStandBack= new CANNON.Body({
    shape: new CANNON.Box(new CANNON.Vec3(1.534, 1.5, 0.056)),
    position: new CANNON.Vec3(8, 2.212, 10),
  })
  cannonWorld.addBody(mainStandBack)

  const mainStandShelf = new CANNON.Body({
    shape: new CANNON.Box(new CANNON.Vec3(1.211, 0.0265, 0.1165)),
    position: new CANNON.Vec3(8, 1.245, 9.535),
  })
  cannonWorld.addBody(mainStandShelf)

  const mainStandShelfBase1 = new CANNON.Body({
    shape: new CANNON.Box(new CANNON.Vec3(0.0655, 0.323, 0.0225)),
    position: new CANNON.Vec3(6.887, 1.094, 9.921),
  })
  cannonWorld.addBody(mainStandShelfBase1)

  const mainStandShelfBase2 = new CANNON.Body({
    shape: new CANNON.Box(new CANNON.Vec3(0.0655, 0.323, 0.0225)),
    position: new CANNON.Vec3(9.107, 1.094, 9.921),
  })
  cannonWorld.addBody(mainStandShelfBase2)

  const mainStandShelfArm1 = new CANNON.Body({
    shape: new CANNON.Box(new CANNON.Vec3(0.039, 0.0255, 0.25)),
    position: new CANNON.Vec3(6.887, 1.195, 9.648),
  })
  cannonWorld.addBody(mainStandShelfArm1)

  const mainStandShelfArm2 = new CANNON.Body({
    shape: new CANNON.Box(new CANNON.Vec3(0.039, 0.0255, 0.25)),
    position: new CANNON.Vec3(9.107, 1.195, 9.648),
  })
  cannonWorld.addBody(mainStandShelfArm2)

  const mainStandFoot1 = new CANNON.Body({
    shape: new CANNON.Box(new CANNON.Vec3(0.1135, 0.056, 0.751)),
    position: new CANNON.Vec3(7, 0.106, 10.006),
  })
  cannonWorld.addBody(mainStandFoot1)

  const mainStandFoot2 = new CANNON.Body({
    shape: new CANNON.Box(new CANNON.Vec3(0.1135, 0.056, 0.751)),
    position: new CANNON.Vec3(9, 0.106, 10.006),
  })
  cannonWorld.addBody(mainStandFoot2)

  const mainStandLeg1 = new CANNON.Body({
    shape: new CANNON.Box(new CANNON.Vec3(0.1095, 0.274, 0.138)),
    position: new CANNON.Vec3(7, 0.437, 10),
  })
  cannonWorld.addBody(mainStandLeg1)

  const mainStandLeg2 = new CANNON.Body({
    shape: new CANNON.Box(new CANNON.Vec3(0.1095, 0.274, 0.138)),
    position: new CANNON.Vec3(9, 0.437, 10),
  })
  cannonWorld.addBody(mainStandLeg2)
  //#endregion
}"
/* sound tin can alley */,"export class Sound extends Entity {
  constructor(audio: AudioClip, loop: boolean, transform?: Vector3) {
    super()
    engine.addEntity(this)
    this.addComponent(new AudioSource(audio))
    this.getComponent(AudioSource).loop = loop
    this.addComponent(new Transform())
    if (transform) {
      this.getComponent(Transform).position = transform
    } else {
      this.getComponent(Transform).position = Camera.instance.position
    }
  }

  playAudioOnceAtPosition(transform: Vector3): void {
    this.getComponent(Transform).position = transform
    this.getComponent(AudioSource).playOnce()
  }

  playAudioAtPosition(transform: Vector3): void {
    this.getComponent(Transform).position = transform
    this.getComponent(AudioSource).playing = true
  }
}"
/* can tin can alley */,"import { Sound } from ""./sound""

const hitSound01 = new Sound(new AudioClip(""sounds/can01.mp3""), false)
const hitSound02 = new Sound(new AudioClip(""sounds/can02.mp3""), false)
const hitSound03 = new Sound(new AudioClip(""sounds/can03.mp3""), false)
const hitSounds: Sound[] = [hitSound01, hitSound02, hitSound03]
const shotTinSound = new Sound(new AudioClip(""sounds/shotTin.mp3""), false)

@Component(""canFlag"")
export class CanFlag {}

const IMPULSE_MULTIPLIER = 10

export class Can extends Entity {
  public body: CANNON.Body
  public world: CANNON.World

  constructor(transform: Transform, cannonMaterial: CANNON.Material, cannonWorld: CANNON.World) {
    super()
    engine.addEntity(this)
    this.addComponent(new GLTFShape(""models/can.glb""))
    this.addComponent(transform)
    this.addComponent(new CanFlag())
    this.world = cannonWorld

    // Create physics body for coconut
    this.body = new CANNON.Body({
      mass: 1, // kg
      position: new CANNON.Vec3(transform.position.x, transform.position.y, transform.position.z), // m
      shape: new CANNON.Cylinder(0.115, 0.115, 0.286, 28), // Create cylinder shaped body with a diameter of 0.23m
    })
    this.body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2)
    // Add material and dampening to stop the can rotating and moving continuously
    this.body.sleep()
    this.body.sleepSpeedLimit = 1 // Falls asleep when velocity falls below this threshold
    this.body.material = cannonMaterial
    this.body.linearDamping = 0.4
    this.body.angularDamping = 0.4
    this.world.addBody(this.body) // Add can body to the world

    // Coconut collision
    this.body.addEventListener(""collide"", (e: any) => {
      // Only play sound when impact is high enough
      let relativeVelocity = e.contact.getImpactVelocityAlongNormal()
      if (Math.abs(relativeVelocity) > 0.75) {
        let randomTrackNo = Math.floor(Math.random() * 2)
        hitSounds[randomTrackNo].playAudioOnceAtPosition(this.getComponent(Transform).position)
      }
    })

  }
  hit(forwardVector: Vector3, hitPoint: Vector3 ) : void {
    this.body.wakeUp()
    shotTinSound.getComponent(AudioSource).playOnce()
    this.body.applyImpulse(
      new CANNON.Vec3(forwardVector.x * IMPULSE_MULTIPLIER, forwardVector.y * IMPULSE_MULTIPLIER, forwardVector.z * IMPULSE_MULTIPLIER),
      new CANNON.Vec3(hitPoint.x, hitPoint.y, hitPoint.z) 
    )
  }
}"
/* tin can alley mesh data */,https://github.com/decentraland-scenes/tin-can-alley/blob/main/src/modules/meshData/tinCanAlleyMesh.ts
/* push box puzzle */,"import { Statue } from './statue'
import { statues, blocked } from './puzzleBuilder'

// Base
const base = new Entity()
base.addComponent(new GLTFShape('models/base.glb'))
engine.addEntity(base)

const room = new Entity()
room.addComponent(new GLTFShape('models/room.glb'))
engine.addEntity(room)

// Instance the input object
const input = Input.instance
const MAX_DISTANCE = 4

// Button down event
input.subscribe('BUTTON_DOWN', ActionButton.POINTER, true, (e) => {
  if (e.hit.meshName === 'statue_collider') {
    const statue = engine.entities[e.hit.entityId] as Statue
    const statuePos = statue.getComponent(Transform).position
    const distance = Vector3.Distance(statuePos, Camera.instance.position)
    if (distance < MAX_DISTANCE) {
      const currentPos = statue.getComponent(Transform).position
      const endPos = currentPos.subtract(e.hit.normal.multiplyByFloats(2, 2, 2))

      // Checks if anything is blocking the statue's path
      const isOverlapped = statues.some((statue) => {
        return endPos.equals(statue.getComponent(Transform).position)
      })
      const isBlocked = blocked.some((block) => {
        return endPos.equals(block)
      })

      // Check boundaries
      if (
        endPos.x >= 4 &&
        endPos.x <= 12 &&
        endPos.z >= 1 &&
        endPos.z >= 5 &&
        endPos.z <= 11 &&
        !isOverlapped &&
        !isBlocked
      ) {
        statue.moveStatue(currentPos, endPos)
      }
    }
  }
})"
/* push box puzzle builder */,"import { Statue } from './statue'
import * as utils from '@dcl/ecs-scene-utils'
import { Sound } from './sound'

// Sounds
const statueMoveSound = new Sound(new AudioClip('sounds/statueMove.mp3'), false)

// Setup coordinates
export const blocked: Vector3[] = [
  new Vector3(12, 0.16, 9),
  new Vector3(4, 0.16, 7)
]
export const solution: Vector3[] = [
  new Vector3(4, 0.16, 5),
  new Vector3(12, 0.16, 5),
  new Vector3(12, 0.16, 7),
  new Vector3(12, 0.16, 11)
]
export const restartPos: Vector3[] = [
  new Vector3(6, 0.16, 9),
  new Vector3(6, 0.16, 7),
  new Vector3(8, 0.16, 7),
  new Vector3(8, 0.16, 5)
]

// Statue
export const statues: Statue[] = []
const statueShape = new GLTFShape('models/statue.glb')

for (let i = 0; i < restartPos.length; i++) {
  const statue = new Statue(
    statueShape,
    new Transform({ position: new Vector3(6, 0.16, 9) })
  )
  statues.push(statue)
}

export function checkSolution(): boolean {
  let count = 0
  for (let i = 0; i < statues.length; i++) {
    for (let j = 0; j < solution.length; j++) {
      if (statues[i].getComponent(Transform).position.equals(solution[j])) {
        statues[i].toggleGlow(true)
        count++
        break
      } else {
        statues[i].toggleGlow(false)
      }
    }
  }
  log(count)
  if (count === 4) return true
  return false
}

// Create triggers for resetting the game
const exitGlow = new Entity()
exitGlow.addComponent(new GLTFShape('models/exitGlow.glb'))
engine.addEntity(exitGlow)

const resetFrontTrigger = new Entity()
engine.addEntity(resetFrontTrigger)
const resetBackTrigger = new Entity()
engine.addEntity(resetBackTrigger)

const resetTriggerFront = new utils.TriggerBoxShape(
  new Vector3(16, 3.5, 3.5),
  new Vector3(8, 1.75, 1.75)
)
const resetTriggerBack = new utils.TriggerBoxShape(
  new Vector3(16, 3.5, 3.5),
  new Vector3(8, 1.75, 14.25)
)

resetFrontTrigger.addComponent(
  new utils.TriggerComponent(resetTriggerFront, {
    onCameraEnter: () => {
      restartGame()
    }
  })
)
resetBackTrigger.addComponent(
  new utils.TriggerComponent(resetTriggerBack, {
    onCameraEnter: () => {
      restartGame()
    }
  })
)

export function restartGame() {
  statueMoveSound.getComponent(AudioSource).playOnce()
  for (let i = 0; i < statues.length; i++) {
    statues[i].getComponent(Transform).position = restartPos[i]
    statues[i].toggleGlow(false)
  }
}

export function finishGame() {
  engine.removeEntity(exitGlow)
  engine.removeEntity(resetFrontTrigger)
  engine.removeEntity(resetBackTrigger)
  log('You win')
}"
/* push box puzzle selector */,"// Selector
const selectorHand = new Entity()
selectorHand.addComponent(new GLTFShape('models/selectorHand.glb'))
selectorHand.addComponent(new Transform())
selectorHand.getComponent(Transform).scale.setAll(0)
engine.addEntity(selectorHand)

const selectorGlow = new Entity()
selectorGlow.addComponent(new GLTFShape('models/selectorGlow.glb'))
selectorGlow.addComponent(new Transform())
selectorGlow.getComponent(Transform).scale.setAll(0)
engine.addEntity(selectorGlow)

const MAX_DISTANCE = 3
const SELECTOR_HAND_Y_OFFSET = 1.35

// System that casts the rays to generate selector
class SelectorSystem implements ISystem {
  update() {
    // Ray from camera
    const rayFromCamera = PhysicsCast.instance.getRayFromCamera(MAX_DISTANCE)

    // For the camera ray, we cast a hit all
    PhysicsCast.instance.hitFirst(rayFromCamera, (raycastHitEntity) => {
      if (raycastHitEntity.entity.meshName === 'statue_collider') {
        const entityID = raycastHitEntity.entity.entityId
        selectorFace(engine.entities[entityID], raycastHitEntity)
      } else {
        selectorHand.getComponent(Transform).scale.setAll(0)
        selectorGlow.getComponent(Transform).scale.setAll(0)
      }
    })
  }
}

// Adds system to the engine
engine.addSystem(new SelectorSystem())

// Snaps the hand icon to discrete points on the selector
function selectorFace(entity: IEntity, raycastHitEntity: RaycastHitEntity) {
  const transform = entity.getComponent(Transform).position.clone() // Clone position of the statue
  selectorGlow.getComponent(Transform).position = transform.clone()
  selectorGlow.getComponent(Transform).position.y = transform.y + 0.035
  selectorGlow.getComponent(Transform).scale.setAll(1)

  selectorHand.getComponent(Transform).position = transform // Set selector transform to match the statue
  selectorHand.getComponent(Transform).position.y =
    transform.y + SELECTOR_HAND_Y_OFFSET
  selectorHand.getComponent(Transform).scale.setAll(1)

  let selectorRotation = selectorHand.getComponent(Transform).rotation
  if (raycastHitEntity.hitNormal.x > 0) {
    selectorRotation = Quaternion.Euler(0, 90, 0)
    selectorHand.getComponent(Transform).position.x = transform.x + 2 / 1.99
  } else if (raycastHitEntity.hitNormal.x < 0) {
    selectorRotation = Quaternion.Euler(0, -90, 0)
    selectorHand.getComponent(Transform).position.x = transform.x - 2 / 1.99
  }
  if (raycastHitEntity.hitNormal.z > 0) {
    selectorRotation = Quaternion.Euler(0, 0, 0)
    selectorHand.getComponent(Transform).position.z = transform.z + 2 / 1.99
  } else if (raycastHitEntity.hitNormal.z < 0) {
    selectorRotation = Quaternion.Euler(0, 180, 0)
    selectorHand.getComponent(Transform).position.z = transform.z - 2 / 1.99
  }
  selectorHand.getComponent(Transform).rotation = selectorRotation
}"
/* push box puzzle sound */,"export class Sound extends Entity {
  constructor(audio: AudioClip, loop: boolean, transform?: Vector3) {
    super()
    engine.addEntity(this)
    this.addComponent(new AudioSource(audio))
    this.getComponent(AudioSource).loop = loop
    this.addComponent(new Transform())
    if (transform) {
      this.getComponent(Transform).position = transform
    } else {
      this.setParent(Attachable.AVATAR)
    }
  }

  playAudioOnceAtPosition(transform: Vector3): void {
    this.getComponent(Transform).position = transform
    this.getComponent(AudioSource).playOnce()
  }

  playAudioAtPosition(transform: Vector3): void {
    this.getComponent(Transform).position = transform
    this.getComponent(AudioSource).playing = true
  }
}"
/* push box puzzle statue */,"import * as utils from '@dcl/ecs-scene-utils'
import { checkSolution, finishGame } from './puzzleBuilder'
import { Sound } from './sound'

// Sounds
const statueMoveSound = new Sound(new AudioClip('sounds/statueMove.mp3'), false)

export class Statue extends Entity {
  public symbol = new Entity()
  public symbolGlow = new Entity()

  constructor(statue: GLTFShape, transform: Transform) {
    super()
    engine.addEntity(this)
    this.addComponent(statue)
    this.addComponent(transform)

    this.symbol.addComponent(new GLTFShape('models/symbol.glb'))
    this.symbol.addComponent(new Transform())
    this.symbol.setParent(this)

    this.symbolGlow.addComponent(new GLTFShape('models/symbolGlow.glb'))
    this.symbolGlow.addComponent(new Transform())
    this.symbolGlow.getComponent(Transform).scale.setAll(0)
    this.symbolGlow.setParent(this)
  }

  toggleGlow(isOn: boolean): void {
    if (isOn) {
      this.symbol.getComponent(Transform).scale.setAll(0)
      this.symbolGlow.getComponent(Transform).scale.setAll(1)
    } else {
      this.symbol.getComponent(Transform).scale.setAll(1)
      this.symbolGlow.getComponent(Transform).scale.setAll(0)
    }
  }

  moveStatue(currentPos, endPos): void {
    // Slide the statue to its endPos over half a second
    if (!this.hasComponent(utils.MoveTransformComponent)) {
      statueMoveSound.getComponent(AudioSource).playOnce()
      this.addComponent(
        new utils.MoveTransformComponent(currentPos, endPos, 0.5, () => {
          if (checkSolution()) finishGame()
        })
      )
    }
  }
}"
/* workspace 1*/,"class RotatorSystem {
  // this group will contain every entity that has a Transform component
  group = engine.getComponentGroup(Transform)

  update(dt: number) {
    // iterate over the entities of the group
    for (const entity of this.group.entities) {
      // get the Transform component of the entity
      const transform = entity.getComponent(Transform)

      // mutate the rotation
      transform.rotate(Vector3.Up(), dt * 10)
    }
  }
}

// Add a new instance of the system to the engine
engine.addSystem(new RotatorSystem())

/// --- Spawner function ---

function spawnCube(x: number, y: number, z: number) {
  // create the entity
  const cube = new Entity()

  // add a transform to the entity
  cube.addComponent(new Transform({ position: new Vector3(x, y, z) }))

  // add a shape to the entity
  cube.addComponent(new BoxShape())

  // add the entity to the engine
  engine.addEntity(cube)

  return cube
}

/// --- Spawn a cube ---

const cube = spawnCube(8, 1, 8)

cube.addComponent(
  new OnPointerDown(() => {
    cube.getComponent(Transform).scale.z *= 1.1
    cube.getComponent(Transform).scale.x *= 0.9

    spawnCube(Math.random() * 8 + 1, Math.random() * 8, Math.random() * 8 + 1)
  })
)"
/* nfts */,"type NFTdata = {
  room: number
  id: number
  position: TransformConstructorArgs
  contract: string
  tokenId: string
}

export const nftCollection: NFTdata[] = [
  {
    room: 1,
    id: 1,
    position: {
      position: new Vector3(4, 2, 30),
      rotation: new Quaternion(0, 0, 0, 1),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '224'
  },
  {
    room: 1,
    id: 2,
    position: {
      position: new Vector3(2, 2, 26),
      rotation: Quaternion.Euler(0, -90, 0),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '223'
  },
  {
    room: 1,
    id: 3,
    position: {
      position: new Vector3(6.3, 2, 26),
      rotation: Quaternion.Euler(0, 90, 0),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '218'
  },
  {
    room: 2,
    id: 4,
    position: {
      position: new Vector3(4 + 12, 2, 30),
      rotation: new Quaternion(0, 0, 0, 1),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '100'
  },
  {
    room: 2,
    id: 5,
    position: {
      position: new Vector3(2 + 12, 2, 26),
      rotation: Quaternion.Euler(0, -90, 0),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '101'
  },
  {
    room: 2,
    id: 6,
    position: {
      position: new Vector3(6.3 + 12, 2, 26),
      rotation: Quaternion.Euler(0, 90, 0),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '102'
  },
  {
    room: 3,
    id: 7,
    position: {
      position: new Vector3(4 + 22, 2, 30),
      rotation: new Quaternion(0, 0, 0, 1),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '110'
  },
  {
    room: 3,
    id: 8,
    position: {
      position: new Vector3(2 + 22, 2, 26),
      rotation: Quaternion.Euler(0, -90, 0),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '111'
  },
  {
    room: 3,
    id: 9,
    position: {
      position: new Vector3(6.3 + 22, 2, 26),
      rotation: Quaternion.Euler(0, 90, 0),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '112'
  },
  {
    room: 4,
    id: 10,
    position: {
      position: new Vector3(4, 2, 22 - 18),
      rotation: Quaternion.Euler(0, 180, 0),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '113'
  },
  {
    room: 4,
    id: 11,
    position: {
      position: new Vector3(1.7, 2, 26 - 18),
      rotation: Quaternion.Euler(0, -90, 0),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '114'
  },
  {
    room: 4,
    id: 12,
    position: {
      position: new Vector3(6.3, 2, 26 - 18),
      rotation: Quaternion.Euler(0, 90, 0),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '115'
  },
  {
    room: 5,
    id: 13,
    position: {
      position: new Vector3(4 + 12, 2, 22 - 18),
      rotation: Quaternion.Euler(0, 180, 0),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '98'
  },
  {
    room: 5,
    id: 14,
    position: {
      position: new Vector3(1.7 + 12, 2, 26 - 18),
      rotation: Quaternion.Euler(0, -90, 0),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '87'
  },
  {
    room: 5,
    id: 15,
    position: {
      position: new Vector3(6.3 + 12, 2, 26 - 18),
      rotation: Quaternion.Euler(0, 90, 0),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '66'
  },
  {
    room: 6,
    id: 16,
    position: {
      position: new Vector3(4 + 22, 2, 22 - 18),
      rotation: Quaternion.Euler(0, 180, 0),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '3'
  },
  {
    room: 6,
    id: 17,
    position: {
      position: new Vector3(1.7 + 22, 2, 26 - 18),
      rotation: Quaternion.Euler(0, -90, 0),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '4'
  },
  {
    room: 6,
    id: 18,
    position: {
      position: new Vector3(6.3 + 22, 2, 26 - 18),
      rotation: Quaternion.Euler(0, 90, 0),
      scale: new Vector3(2.5, 2.5, 2.5)
    },
    contract: '0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2',
    tokenId: '8'
  }
]

export function createPainting(
  id: number,
  position: TransformConstructorArgs,
  contract: string,
  tokenId: string
) {
  const address: string = 'ethereum://' + contract + '/' + tokenId
  const entity = new Entity()

  const nftShape = new NFTShape(address, {
    style: PictureFrameStyle.Gold_Edges
  })

  entity.addComponent(new Transform(position))
  entity.addComponent(nftShape)

  engine.addEntity(entity)
  return entity
}"
/* gun */,"import * as utils from '@dcl/ecs-scene-utils'
export class Sound extends Entity {
  constructor(audio: AudioClip) {
    super()
    engine.addEntity(this)
    this.addComponent(new AudioSource(audio))
    this.addComponent(new Transform())
    this.setParent(Attachable.FIRST_PERSON_CAMERA) // Play the sound wherever the player is standing
  }
}
const gunPickupSound = new Sound(new AudioClip('sounds/gunPickup.mp3'))

export class Gun extends Entity {
  hasGun: boolean = false

  constructor(
    model: GLTFShape,
    transform: Transform,
    blueGlow: Entity,
    orangeGlow: Entity
  ) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(transform)
    this.addComponent(
      new utils.KeepRotatingComponent(Quaternion.Euler(0, 180, 0))
    )

    blueGlow.setParent(this)
    orangeGlow.setParent(this)

    // Create trigger for card
    this.addComponent(
      new utils.TriggerComponent(
        new utils.TriggerBoxShape(new Vector3(2, 2, 2)),

        {
          onCameraEnter: () => {
            this.pickUp()
          }
        }
      )
    )
  }
  pickUp() {
    this.hasGun = true
    this.setParent(Attachable.FIRST_PERSON_CAMERA)
    this.getComponent(Transform).position = new Vector3(0.45, -0.425, 0.9)
    this.getComponent(Transform).rotation.setEuler(0, 0, 0)
    this.getComponent(utils.KeepRotatingComponent).stop()
    gunPickupSound.getComponent(AudioSource).playOnce()
  }
}"
/*portal */,"// Config
export enum PortalColor {
  Blue = 0,
  Orange = 1
}

const HEIGHT_ABOVE_GROUND = 1.2 // In meters

export class Portal extends Entity {
  public cameraTarget: Vector3 = Vector3.Zero() // Direction the player should be facing after teleporting

  constructor(model: GLTFShape) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Animator())
    this.getComponent(Animator).addClip(
      new AnimationState('Expand', { looping: false })
    )
  }

  playAnimation() {
    this.getComponent(Animator).getClip('Expand').stop() // Bug workaround
    this.getComponent(Animator).getClip('Expand').play()
  }
  spawn(position: Vector3, rotation: Quaternion, cameraTarget: Vector3) {
    this.addComponentOrReplace(new Transform()) // Reset the Transform component
    const transform = this.getComponent(Transform)
    transform.rotation = rotation
    transform.position = position
    this.cameraTarget = cameraTarget

    this.playAnimation()
  }
}

export class DummyEnt extends Entity {
  cameraTarget: Vector3
  constructor(position: Vector3, hitNormal: Vector3) {
    super()
    engine.addEntity(this)

    this.addComponent(new Transform({}))

    this.getComponent(Transform).lookAt(hitNormal)

    this.getComponent(Transform).position = position

    if (this.getComponent(Transform).position.y <= HEIGHT_ABOVE_GROUND)
      this.getComponent(Transform).position.y = HEIGHT_ABOVE_GROUND // Make sure the portal is above ground height

    this.cameraTarget = this.getComponent(Transform).position.add(hitNormal)
    // this.getComponent(Transform).rotate(new Vector3(0, 0, 1), 180)
    // this.getComponent(Transform).rotate(new Vector3(0, 1, 0), 180)
  }
}"
/* card */ ,"import * as utils from '@dcl/ecs-scene-utils'

export class Sound extends Entity {
  constructor(audio: AudioClip) {
    super()
    engine.addEntity(this)
    this.addComponent(new AudioSource(audio))
    this.addComponent(new Transform())
    this.setParent(Attachable.FIRST_PERSON_CAMERA) // Play the sound wherever the player is standing
  }
}
/**
 * Sound is a separated from the card entity so that you can
 * still hear it even when the card is removed from the engine.
 */
const cardPickupSound = new Sound(new AudioClip('sounds/cardPickup.mp3'))

export class Card extends Entity {
  constructor(model: GLTFShape, transform: Transform) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(transform)

    // Create trigger for card
    this.addComponent(
      new utils.TriggerComponent(
        new utils.TriggerBoxShape(
          new Vector3(1, 1, 1),
          new Vector3(0, 0.75, 0)
        ),

        {
          onCameraEnter: () => {
            this.getComponent(Transform).scale.setAll(0)
            cardPickupSound.getComponent(AudioSource).playOnce()
          },
          onCameraExit: () => {
            engine.removeEntity(this)
          }
        }
      )
    )
  }
}"
/* debounce */ ,"/**
 * Returns a debounced function of a given callback
 * @param callback
 * @param ms
 * @returns
 */
export function debounce(callback: (...args: any[]) => any, ms: number) {
  let timeout: NodeJS.Timeout | null = null
  return (...args: any[]) => {
    if (timeout) {
      clearTimeout(timeout)
    }
    timeout = setTimeout(() => {
      timeout = null
      callback(...args)
    }, ms)
  }
}"
/* workspace */,"import * as vscode from 'vscode'
import fs from 'fs'
import path from 'path'
import { Scene } from '@dcl/schemas'
import { hasDependency } from './pkg'

/**
 * Returns the path to the workspace's current working directory
 * @returns The path to the workspace's current working directory
 */
export function getCwd() {
  const { workspaceFolders } = vscode.workspace
  if (workspaceFolders && workspaceFolders.length > 0) {
    const folder = workspaceFolders[0]
    return folder.uri.fsPath
  }
  throw new Error('getCwd(): Could not get workspace folder')
}

/**
 * Get scene json
 */
export function getScene() {
  const sceneJsonPath = path.join(getCwd(), 'scene.json')
  const scene = fs.readFileSync(sceneJsonPath, 'utf8')
  return JSON.parse(scene) as Scene & {
    worldConfiguration?: {
      name: string
    }
  }
}

/**
 * Returns whether or not the workspace's current working directory is a decentraland project or not
 */
export function isDCL() {
  try {
    getScene()
    return hasDependency('@dcl/sdk', true)
  } catch (error) {
    return false
  }
}

/**
 * Returns whether or not the workspace's current working directory is empty or not
 */
export function isEmpty() {
  try {
    const files = fs.readdirSync(getCwd())
    return files.length === 0
  } catch (error) {
    return false
  }
}

/**
 * Return whether or not the workspace's current working directory has a node_modules directory
 */
export function hasNodeModules() {
  try {
    const nodeModulesPath = path.join(getCwd(), 'node_modules')
    if (fs.existsSync(nodeModulesPath)) {
      return true
    } else {
      return false
    }
  } catch (error) {
    return false
  }
}"
/* pick */ ,"import * as vscode from 'vscode'

/**
 * Helper to pick an item from a list, by showing options to the user
 * @param items
 * @param labelKey
 * @param options
 * @returns
 */
export async function pick<T>(
  items: T[],
  labelKey: keyof T,
  options?: vscode.QuickPickOptions
) {
  const labels = items.map((item) => item[labelKey] as string)
  const selectedLabel = await vscode.window.showQuickPick(labels, options)
  const selectedItem = items.find((item) => item[labelKey] === selectedLabel)
  return selectedItem || null
}"
/* spawn */,"import { ChildProcess } from 'child_process'
import path from 'path'
import crossSpawn from 'cross-spawn'
import treeKill from 'tree-kill'
import future from 'fp-future'
import { Readable } from 'stream'
import isRunning from 'is-running'
import { bind, log } from './log'
import { getModuleBinPath, getNodeBinPath, joinEnvPaths } from './path'
import { getCwd } from './workspace'

export type SpanwedChild = {
  id: string
  process: ChildProcess
  on: (pattern: RegExp, handler: (data?: string) => ChildReponse) => number
  once: (pattern: RegExp, handler: (data?: string) => ChildReponse) => number
  off: (index: number) => void
  wait: () => Promise<void>
  waitFor: (resolvePattern: RegExp, rejectPattern?: RegExp) => Promise<string>
  kill: () => Promise<void>
  alive: () => boolean
}

export type SpawnOptions = {
  cwd?: string
  env?: Record<string, string>
}

export type ChildReponse = Thenable<string> | string[] | string | void

type Matcher = {
  pattern: RegExp
  handler: (data: string) => ChildReponse
  enabled: boolean
}

/**
 * Runs any command in a spanwed child process, provides helpers to wait for the process to finish, listen for outputs, send reponses, etc
 * @param command The command
 * @param args The arguments for the command
 * @param options Options for the child process spawned
 * @returns SpanwedChild
 */
export function spawn(
  id: string,
  command: string,
  args: string[] = [],
  options: SpawnOptions = {}
): SpanwedChild {
  const { cwd = getCwd(), env = { ...process.env } } = options

  // status
  let isKilling = false
  let alive = true

  const promise = future<void>()

  const matchers: Matcher[] = []

  const nodePath = path.dirname(getNodeBinPath())
  const npmPath = path.dirname(getModuleBinPath('npm', 'npm'))
  const newEnv = {
    ...env,
    PATH: joinEnvPaths(env.PATH, nodePath, npmPath),
  }

  const child = crossSpawn(command, args, {
    shell: true,
    cwd,
    env: newEnv,
  })

  log(`Spawning child process ""${id}"" with pid=${child.pid}`)

  child.stdout!.pipe(process.stdout)
  child.stderr!.pipe(process.stderr)

  child.on('close', (code) => {
    alive = false
    log(
      `Process ""${id}"" with pid=${child.pid} closed with exit code=${code || 0}`
    )
    if (code !== 0 && code !== null) {
      promise.reject(
        new Error(
          `Error: process ""${id}"" with pid=${child.pid} exited with code=${code}`
        )
      )
    } else {
      promise.resolve(void 0)
    }
  })

  function handleStream(stream: Readable) {
    stream.on('data', (data: Buffer) => handleData(data, matchers, child))
  }

  handleStream(child.stdout!)
  handleStream(child.stderr!)

  const spawned: SpanwedChild = {
    id,
    process: child,
    on: (pattern, handler) => {
      if (alive) {
        return matchers.push({ pattern, handler, enabled: true }) - 1
      }
      throw new Error('Process has been killed')
    },
    once: (pattern, handler) => {
      const index = spawned.on(pattern, (data) => {
        handler(data)
        spawned.off(index)
      })
      return index
    },
    off: (index) => {
      if (matchers[index]) {
        matchers[index].enabled = false
      }
    },
    wait: () => promise,
    waitFor: (resolvePattern, rejectPattern) =>
      new Promise((resolve, reject) => {
        spawned.once(resolvePattern, (data) => resolve(data!))
        if (rejectPattern) {
          spawned.once(rejectPattern, (data) => reject(new Error(data)))
        }
      }),
    kill: async () => {
      log(`Killing process ""${id}"" with pid=${child.pid}...`)
      // if child is being killed or already killed then return
      if (isKilling || !alive) return
      isKilling = true

      // create promise to kill child
      const promise = future<void>()

      // kill child gracefully
      treeKill(child.pid!)

      // child succesfully killed
      const die = (force: boolean = false) => {
        isKilling = false
        alive = false
        clearInterval(interval)
        clearTimeout(timeout)
        if (!child.killed) {
          const signal = force ? 'SIGKILL' : 'SIGTERM'
          log(
            `Sending signal=${signal} to process ""${id}"" with pid=${child.pid}`
          )
          treeKill(child.pid!, signal)
        }
        for (const matcher of matchers) {
          matcher.enabled = false
        }
        log(
          `Process ""${id}"" with pid=${child.pid} ${
            force ? 'forcefully' : 'gracefully'
          } killed`
        )
        promise.resolve()
      }

      // interval to check if child still running and flag it as dead when is not running anymore
      const interval = setInterval(() => {
        if (!child.pid || !isRunning(child.pid)) {
          die()
        }
      }, 100)

      // timeout to stop checking if child still running, kill it with fire
      const timeout = setTimeout(() => {
        if (alive) {
          die(true)
        }
      }, 5000)

      // return promise
      return promise
    },
    alive: () => alive,
  }

  // bind logs to output channel
  bind(spawned)

  return spawned
}

async function handleData(
  buffer: Buffer,
  matchers: Matcher[],
  child: ChildProcess
) {
  const data = buffer.toString('utf8')
  for (const { pattern, handler, enabled } of matchers) {
    if (!enabled) continue
    pattern.lastIndex = 0 // reset regexp
    if (pattern.test(data)) {
      const response = handler(data)
      switch (typeof response) {
        case 'string':
          child.stdin!.write(response)
          break
        case 'object': {
          if ('then' in response) {
            const value = await response
            child.stdin!.write(value)
          } else if (Array.isArray(response)) {
            for (const res of response) {
              child.stdin!.write(res)
            }
          }
          break
        }
        default: {
          break
        }
      }
    }
  }
}"
/* rollbar */,"import Rollbar from 'rollbar'
import { ExtensionMode } from 'vscode'
import { log } from './log'

let rollbar: Rollbar | null = null

export function activateRollbar(mode: ExtensionMode, key?: string) {
  if (rollbar) {
    console.warn('Rollbar already initialized')
    return
  }

  if (!key) {
    log(`Reporting disabled`)
    return
  }

  rollbar = new Rollbar({
    accessToken: key,
    captureUncaught: true,
    captureUnhandledRejections: true,
    environment:
      mode === ExtensionMode.Development
        ? 'development'
        : mode === ExtensionMode.Production
        ? 'production'
        : 'test',
  })
}

export function getRollbar() {
  if (!rollbar) {
    throw new Error('Rollbar has not been initialized yet')
  }
  return rollbar
}

export function report(error: Error) {
  try {
    getRollbar().error(error)
  } catch (e) {
    // Error reporting disabled
  }
}

export function deactivateRollbar() {
  if (rollbar) {
    rollbar = null
  }
}"
/* particles */,"import { engine, Material, MeshRenderer, PBMaterial_PbrMaterial, Schemas, Transform } from '@dcl/sdk/ecs'
import { Color3, Quaternion, Vector3 } from '@dcl/sdk/math'

// @Component('particle')
// export class Particle {
//   life = Math.random()
//   seed = Math.random() * this.width
//   constructor(public width: number, public height: number, public speed: number, public parentTransform: Entity) {}
// }

// Particles
export const Particle = engine.defineComponent(
  {
    life: Schemas.Float,
    seed: Schemas.Float,
    width: Schemas.Number,
    height: Schemas.Number,
    speed: Schemas.Number
  },
  3004
)

export function particleSystem(dt: number) {
  for (const [entity] of engine.getEntitiesWith(Particle, Transform)) {
    const particle = Particle.getMutable(entity)

    particle.life += dt * particle.speed // Particle speed
    particle.life %= 1 // Reset particle life

    const transform = Transform.getMutable(entity)
    transform.position = Vector3.create(0, particle.life * particle.height, 0 - particle.seed)
  }
}

// Setup particles
const material: PBMaterial_PbrMaterial = {
  metallic: 1,
  albedoColor: Color3.create(0.5, 1.5, 2),
  emissiveColor: Color3.create(0.5, 1.5, 2)
}

// Position particles with a
const particleParentEntity = engine.addEntity()
Transform.create(particleParentEntity, {
  position: Vector3.create(16, 0, 10),
  rotation: Quaternion.fromEulerDegrees(0, 90, 0)
})

// Initialise particles
const MAX_PARTICLES = 256

for (let i = 0; i < MAX_PARTICLES; i++) {
  const particleEntity = engine.addEntity()
  MeshRenderer.setPlane(particleEntity)
  Material.setPbrMaterial(particleEntity, material)
  Particle.create(particleEntity, {
    life: Math.random(),
    seed: 16 * Math.random(),
    height: 7,
    speed: 0.25
  })

  Transform.create(particleEntity, {
    rotation: Quaternion.fromEulerDegrees(0, 90, 0),
    scale: Vector3.create(0.01, 0.1, 1),
    parent: particleParentEntity
  })
}"
/* sounds */ ,"import { AudioSource, AvatarAttach, engine, Transform } from '@dcl/sdk/ecs'

export function createSound(src: string) {
  const entity = engine.addEntity()
  Transform.create(entity)
  AudioSource.create(entity, { audioClipUrl: src, playing: false })
  return entity
}"
/* Player Data */ ,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""
export let userId: undefined | string = undefined

executeTask(async () => {
  userId = (await getUserData({})).data?.userId
})"
/* sleep */,"/**
 * Returns a promise that resolves in a given amount of milliseconds
 * @param ms amount of milliseconds
 * @returns
 */
export const sleep = (ms: number) =>
  new Promise((resolve) => setTimeout(resolve, ms))"
/* webview */ ,"import * as vscode from 'vscode'
import mitt from 'mitt'
import future from 'fp-future'
import { getContext } from './context'
import { waitForServer } from './server'

export type Message<
  MessageType extends string,
  MessagePayload extends Record<MessageType, unknown>
> = {
  type: MessageType
  payload: MessagePayload[MessageType]
}

export class Webview<
  InboundMessageType extends string = never,
  InboundMessagePayload extends Record<InboundMessageType, unknown> = never,
  OutboundMessageType extends string = never,
  OutboundMessagePayload extends Record<OutboundMessageType, unknown> = never
> {
  private events = mitt<{
    message: Message<OutboundMessageType, OutboundMessagePayload>
    dispose: any
  }>()

  didDispose = false

  constructor(public url: string, public panel: vscode.WebviewPanel) {
    this.panel.webview.onDidReceiveMessage((event: any) => {
      if (event && 'type' in event && 'payload' in event) {
        const message = event as Message<
          OutboundMessageType,
          OutboundMessagePayload
        >
        this.events.emit('message', message)
      }
    })
    this.panel.onDidDispose(() => {
      this.events.emit('dispose')
    })
    this.events.on('dispose', () => {
      this.didDispose = true
    })
  }

  async load() {
    this.panel.webview.html = this.getLoadingHtml()
    await waitForServer(this.url)
    this.panel.webview.html = this.getIframeHtml()
  }

  async loadOrDispose() {
    const dispose = future<void>()
    this.onDispose(dispose.resolve)
    return Promise.race([this.load(), dispose])
  }

  private getLoadingHtml() {
    return this.getHtml(`<div class=""loading"">Loading&hellip;<div>`)
  }

  private getIframeHtml() {
    const id = getNonce()
    const nonce = getNonce()
    return this.getHtml(
      `
    <iframe 
      id=""${id}"" 
      src=""${this.url}"" 
      width=""100%""
      height=""100%""
      frameBorder=""0""
    ></iframe>
    <script nonce=""${nonce}"">
      /* This is necessary to be able to find the iframe from the script.js */
      window.iframeId = ""${id}"";
    </script>`,
      nonce
    )
  }

  dispose() {
    if (!this.didDispose) {
      this.panel.dispose()
    }
  }

  onDispose(handler: () => void) {
    return this.events.on('dispose', handler)
  }

  onMessage(
    handler: (
      message: Message<OutboundMessageType, OutboundMessagePayload>
    ) => void
  ) {
    return this.events.on('message', handler)
  }

  postMessage(
    type: InboundMessageType,
    payload: InboundMessagePayload[InboundMessageType]
  ): void {
    const message: Message<InboundMessageType, InboundMessagePayload> = {
      type,
      payload,
    }
    this.panel.webview.postMessage(message)
  }

  private getHtml(body: string, nonce = getNonce()) {
    // resources
    const resourcesDirectory = 'resources/webview'

    // Local path to script and css for the webview
    const scriptUri = this.panel.webview.asWebviewUri(
      vscode.Uri.joinPath(
        getContext().extensionUri,
        resourcesDirectory,
        'script.js'
      )
    )
    const styleUri = this.panel.webview.asWebviewUri(
      vscode.Uri.joinPath(
        getContext().extensionUri,
        resourcesDirectory,
        'style.css'
      )
    )

    const url = new URL(this.url)
    const cspUrl = `${url.protocol}//${url.hostname}:${url.port}`

    return /* html */ `
			<!DOCTYPE html>
			<html lang=""en"">
			<head>
				<meta charset=""UTF-8"">
				<!--
				Use a content security policy to only allow loading images from https or from our extension directory,
				and only allow scripts that have a specific nonce.
				-->
				<meta http-equiv=""Content-Security-Policy"" content=""default-src 'none'; child-src 'self' ${cspUrl}; img-src ${this.panel.webview.cspSource} blob:; style-src ${this.panel.webview.cspSource}; script-src 'nonce-${nonce}';"">
				<meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
				<link href=""${styleUri}"" rel=""stylesheet"" />
				<title>${this.panel.title}</title>
			</head>
			<body>
				${body}
			<script nonce=""${nonce}"" src=""${scriptUri}""></script>
			</body>
			</html>`
  }
}

/**
 * Get a nonce for a script tag or an iframe id
 */
export function getNonce() {
  let text = ''
  const possible =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
  for (let i = 0; i < 32; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length))
  }
  return text
}"
/* storage */ ,"import { getContext } from './context'

export function getLocalValue<T>(key: string) {
  const context = getContext()
  return context.workspaceState.get<T>(key)
}

export function setLocalValue<T>(key: string, value: T) {
  const context = getContext()
  context.workspaceState.update(key, value)
}

export function getGlobalValue<T>(key: string) {
  const context = getContext()
  return context.globalState.get<T>(key)
}

export function setGlobalValue<T>(key: string, value: T) {
  const context = getContext()
  context.globalState.update(key, value)
}"
/*dispose */,"import * as vscode from 'vscode'

/**
 * Loops over and disposes all disposables in a list
 * @param disposables List of disposables
 */
export function disposeAll(disposables: vscode.Disposable[]): void {
  while (disposables.length) {
    const item = disposables.pop()
    if (item) {
      item.dispose()
    }
  }
}

/**
 * An abstract class that implements the disposable logic
 */
export abstract class Disposable {
  private _isDisposed = false

  protected _disposables: vscode.Disposable[] = []

  public dispose(): any {
    if (this._isDisposed) {
      return
    }
    this._isDisposed = true
    disposeAll(this._disposables)
  }

  protected _register<T extends vscode.Disposable>(value: T): T {
    if (this._isDisposed) {
      value.dispose()
    } else {
      this._disposables.push(value)
    }
    return value
  }

  public get isDisposed(): boolean {
    return this._isDisposed
  }
}"
/* server */ ,"import http from 'http'
import fetch from 'node-fetch'
import express from 'express'
import future from 'fp-future'
import { clearPort, getPort } from './port'
import { sleep } from './sleep'
import { log } from './log'
import { getMessage } from './error'

export abstract class Server {
  constructor(public name: string) {}

  isStarting = false
  isStopping = false
  isRunning = false

  async getPort() {
    return getPort(this.name)
  }

  async start(...args: any[]) {
    try {
      await this.stop()
      if (this.isStarting) {
        return
      }
      this.isStarting = true
      await this.onStart(...args)
      this.isStarting = false
      this.isRunning = true
      log(`${this.name} server started on port=${await this.getPort()}`)
    } catch (error) {
      this.isStarting = false
      log(`Error starting ${this.name} server: ${getMessage(error)}`)
    }
  }

  async stop() {
    try {
      if (this.isStopping || !this.isRunning) {
        return
      }
      this.isStopping = true
      await this.onStop()
      this.isStopping = false
      this.isRunning = false
      clearPort(this.name)
      log(`${this.name} server stopped`)
    } catch (error) {
      this.isStopping = false
      log(`Error stopping ${this.name} server: ${getMessage(error)}`)
    }
  }

  async restart() {
    await this.stop()
    await this.start()
  }

  abstract onStart(...args: any[]): Promise<void>
  abstract onStop(): Promise<void>
}

export class StaticServer extends Server {
  public app = express()
  server: http.Server | null = null
  private isRouted = false

  constructor(public name: string, public directory: string | (() => string)) {
    super(name)
  }

  async onStart() {
    if (!this.isRouted) {
      this.app.use(
        express.static(
          typeof this.directory === 'function'
            ? this.directory()
            : this.directory
        )
      )
      this.isRouted = true
    }
    const port = await this.getPort()
    const promise = future<void>()
    this.server = this.app.listen(port, promise.resolve)
    return promise
  }

  async onStop() {
    if (this.server) {
      this.server.close()
      this.server = null
    }
  }
}

/**
 * Waits for a server to be ready
 * @param server The name of the server
 * @returns Promise that resolves when the server is up
 */
export async function waitForServer(url: string) {
  while (true) {
    try {
      await fetch(url)
      return
    } catch (error) {
      await sleep(500)
    }
  }
}"
/* node */ ,"import fs from 'fs'
import path from 'path'
import semver, { SemVer } from 'semver'
import rimraf from 'rimraf'
import fetch from 'node-fetch'
import Progress from 'node-fetch-progress'
import tar from 'tar-fs'
import zip from 'unzip-stream'
import gunzip from 'gunzip-maybe'
import future from 'fp-future'
import { getGlobalBinPath, getNodeBinPath, getNodeCmdPath } from './path'
import { log } from './log'
import { getPackageJson } from './pkg'
import { sleep } from './sleep'
import { track } from './analytics'
import { getMessage } from './error'
import { link } from './bin'

/**
 * Returns the node version that will be used to run binaries
 * @returns node version
 */
let version: string | null = null
export function getVersion() {
  if (version === null) {
    throw new Error(`Node version not set`)
  }
  return version
}

export function setVersion(_version: string | null) {
  version = _version
}

/**
 * Fetches the latest supported node version
 */
export async function resolveVersion() {
  const pkg = getPackageJson()
  if (!pkg.engines.node) {
    throw new Error(`Node engine is not defined`)
  }

  let min: SemVer
  try {
    min = semver.minVersion(pkg.engines.node)!
  } catch (error) {
    throw new Error('Node engine is not valid')
  }
  log(`Node engine required: ${pkg.engines.node}`)

  const installed = await getLatestFromInstalled(min.major)
  if (installed) {
    log(`Latest node version installed: ${installed}`)
  }

  const latest = await getLatestFromGithub(min.major)
  if (latest) {
    log(`Latest node version available: ${latest}`)
  }

  const version = latest || installed || min.version
  log(`Using node version: v${version}`)
  return version
}

/**
 * Extracts the version from the distribution
 * @param distribution
 * @returns
 */
function extractVersion(distribution: string) {
  return distribution.split('node-v').pop()?.split('-')[0]!
}

/**
 * Get the latest version of node installed
 * @returns
 */
async function getLatestFromInstalled(major: number) {
  const distributions = await getInstalledDistributions()
  return distributions
    .map(extractVersion)
    .reduce<string | null>(
      (latest, version) =>
        !latest ||
        (semver.gt(version, latest) &&
          semver.satisfies(version, `^${major}.0.0`))
          ? version
          : latest,
      null
    )
}

/**
 * Get the list of installed distributions
 * @returns
 */
async function getInstalledDistributions() {
  const versions = future<string[]>()
  fs.readdir(getGlobalBinPath(), (error, result) =>
    error ? versions.resolve([]) : versions.resolve(result)
  )
  return versions.then((versions) =>
    versions.filter((version) => version.startsWith('node-v'))
  )
}

/**
 * Returns the latest version for a given major, fetching data from GitHub
 * @param major
 * @param page
 * @returns
 */
async function getLatestFromGithub(
  major: number,
  page = 1
): Promise<string | null> {
  try {
    const versions = await getAvailableVersions(page)

    let latest: string | null = null
    for (const version of versions) {
      const inRange = semver.satisfies(version, `^${major}.0.0`)
      const isNewer = !latest || semver.gt(version, latest)
      if (inRange && isNewer) {
        latest = version
      }
    }

    // if no version found in this page, look in the next one
    if (latest === null) {
      return getLatestFromGithub(major, page + 1)
    }

    // if the latest version was found in this page, we use that one
    return latest
  } catch (error: any) {
    log(`Could not look for newer versions...`)
    return null
  }
}

/**
 * Returns available Node versions using the GitHub API to fetch releases
 * @param page
 * @returns
 */
async function getAvailableVersions(page: number) {
  const resp = await fetch(
    `https://api.github.com/repos/nodejs/node/tags?per_page=10&page=${page}`
  )
  if (!resp.ok) {
    throw new Error(
      `Error fetching available node versions: ${await resp.text()}`
    )
  }
  const tags: { name: string }[] = await resp.json()
  return tags.map(({ name }) => semver.clean(name)!)
}

/**
 * Returns the platform + arch needed for the binaries
 * @returns
 */
export function getPlatform() {
  const platform: string[] = []
  switch (process.platform) {
    case 'darwin':
      platform.push('darwin')
      break
    case 'win32':
      platform.push('win')
      break
    case 'linux':
      platform.push('linux')
      break
    default:
      throw new Error(`Unsupported platform: ""${process.platform}""`)
  }

  switch (process.arch) {
    case 'arm64':
      platform.push(platform[0] === 'win' ? 'x64' : 'arm64')
      break
    case 'arm':
      platform.push('armv71')
      break
    case 'x64':
      platform.push('x64')
      break
    case 'ia32':
      platform.push('x86')
      break
    case 'ppc64':
      platform.push('ppc64le')
      break
    case 's390x':
      platform.push('s390x')
      break
    default:
      throw new Error(`Unsupported architecture: ""${process.arch}""`)
  }

  return platform.join('-')
}

/**
 * Returns the distribution name
 * @returns
 */
export function getDistribution() {
  return `node-v${getVersion()}-${getPlatform()}`
}

/**
 * Returns the extension for a given distribution
 * @param distribution
 * @returns
 */
export function getExtension(distribution: string) {
  if (isWindows(distribution)) {
    return '.zip'
  }
  return '.tar.gz'
}

/**
 * Returns the extension for a given distribution
 * @param distribution
 * @returns
 */
export function getStream(binPath: string, distribution: string) {
  const extension = getExtension(distribution)
  const stream: NodeJS.WritableStream =
    extension === '.tar.gz'
      ? tar.extract(binPath)
      : zip.Extract({ path: binPath })
  return stream
}

/**
 * Util to detect if a distribution is for Windows
 * @param distribution
 * @returns
 */
export function isWindows(distribution: string) {
  const [_node, _version, platform, _arch] = distribution.split('-')
  return platform === 'win'
}

/**
 * Installs a given distribution
 * @param distribution
 */
async function installNode(distribution: string) {
  try {
    track(`node.install:request`, { distribution })
    const binPath = getGlobalBinPath()
    const extension = getExtension(distribution)
    log(`Distribution: ${distribution}`)
    const url = `https://nodejs.org/dist/v${extractVersion(
      distribution
    )}/${distribution}${extension}`
    log(`Downloading from: ${url}`)
    log(`Installation directory: ${binPath}`)
    const resp = await fetch(url)
    if (!resp.ok) {
      let error = `Could not download ""${distribution}""`
      try {
        error += `: ${await resp.text()}`
      } catch (error) {}
      log(error)
      throw new Error(error)
    }
    const progress = new Progress(resp)
    let lastPercentage = 0
    progress.on('progress', (data) => {
      const percentage = (data.done / data.total) * 100
      // Report progress every 5% or more
      if (!lastPercentage || percentage > lastPercentage + 5) {
        const line = `Installing... ${percentage.toFixed(0)}%`
        log(line)
        lastPercentage = percentage
      }
    })
    const save = future()
    const stream = getStream(binPath, distribution)
    resp.body.pipe(gunzip()).pipe(stream)
    resp.body.on('end', save.resolve)
    stream.on('error', save.reject)
    await save
    log('Installing... 100%')
    await sleep(1000)
    log('Done!')
    log(`Node binaries installed: ${getNodeBinPath()}`)
    track(`node.install:success`, { distribution })
  } catch (error) {
    track(`node.install:error`, {
      message: getMessage(error),
    })
    throw error
  }
}

/**
 * Uninstalls a given distribution
 * @param distribution
 */
async function uninstallNode(distribution: string) {
  try {
    track(`node.uninstall:request`, { distribution })
    log(`Uninstalling ${distribution}...`)
    const directory = path.join(getGlobalBinPath(), distribution)
    const clear = future<void>()
    rimraf(directory, (error) =>
      error ? clear.reject(error) : clear.resolve()
    )
    await clear
    log(`Done!`)
    track(`node.uninstall:success`, { distribution })
  } catch (error) {
    track(`node.uninstall:error`, {
      message: getMessage(error),
    })
    throw error
  }
}

/**
 * This checks if the necessary binaries are installed. If not, it proceeds to uninstall older distributions and install the expected one.
 * @returns
 */
export async function checkNodeBinaries() {
  try {
    const distribution = getDistribution()
    const nodeBinPath = getNodeBinPath()
    const isNodeInstalled = fs.existsSync(nodeBinPath)
    track(`node.check:request`, {
      distribution,
      installed: isNodeInstalled,
    })

    if (!isNodeInstalled) {
      log(`The required node binaries are not installed`)

      // Check if global /bin dir exists, if not, creates it
      const globalBinPath = getGlobalBinPath()
      const hasBinDir = fs.existsSync(globalBinPath)
      if (!hasBinDir) {
        fs.mkdirSync(globalBinPath, { recursive: true })
      }

      // Uninstall and unlink older distributions
      const distributions = await getInstalledDistributions()
      for (const distribution of distributions) {
        await uninstallNode(distribution)
      }
      if (distributions.length > 0) {
        await unlinkNode()
      }

      // Install the current distribution
      const distribution = getDistribution()
      await installNode(distribution)
    }

    if (!isLinked()) {
      await linkNode()
    }

    log(`Node command path: ""${getNodeCmdPath()}""`)
    log(`Node bin path: ""${nodeBinPath}""`)

    track(`node.check:success`, { distribution, wasInstalled: isNodeInstalled })
  } catch (error) {
    track(`node.check:error`, {
      message: getMessage(error),
    })
    throw error
  }
}

/**
 * Link the current distribution
 * @returns
 */
async function linkNode() {
  track(`node.link:request`)
  try {
    const cmdPath = getNodeCmdPath()
    const binPath = getNodeBinPath()
    if (!isLinked()) {
      await link(cmdPath, binPath)
    }
    track(`node.link:success`)
  } catch (error) {
    track(`node.link:error`, {
      message: getMessage(error),
    })
    throw error
  }
}

/**
 * Unlink the current distribution
 * @returns
 */
async function unlinkNode() {
  track(`node.unlink:request`)
  try {
    const promise = future<void>()
    const cmdPath = getNodeCmdPath()
    log(`Unlinking ${cmdPath}`)
    rimraf(cmdPath, (error) =>
      error ? promise.reject(error) : promise.resolve()
    )
    await promise
    log(`Done!`)
    track(`node.unlink:success`)
  } catch (error) {
    track(`node.unlink:error`, {
      message: getMessage(error),
    })
    throw error
  }
}

/**
 * Utils to check if a distribution is linked or not
 * @returns
 */
function isLinked() {
  return fs.existsSync(getNodeCmdPath())
}"
/* matching cube systems */ ,"import {
  engine,
  MeshRenderer,
  Transform,
  PointerHoverFeedback,
  InputAction,
  PointerEventType,
  Schemas,
  inputSystem
} from '@dcl/sdk/ecs'
import { Quaternion, Vector3 } from '@dcl/sdk/math'
import { createCube } from './factory'

/**
 * BounceScaling is the flag-component with the time elapsed since creation.
 */
const BounceScalingComponentID = 2000
export const BounceScaling = engine.defineComponent({ t: Schemas.Number }, BounceScalingComponentID)

/**
 * All cubes rotating behavior
 */
export function circularSystem(dt: number) {
  const entitiesWithMeshRenderer = engine.getEntitiesWith(MeshRenderer, Transform)
  for (const [entity, _meshRenderer, _transform] of entitiesWithMeshRenderer) {
    const mutableTransform = Transform.getMutable(entity)

    mutableTransform.rotation = Quaternion.multiply(
      mutableTransform.rotation,
      Quaternion.fromAngleAxis(dt * 10, Vector3.Up())
    )
  }
}

/**
 * The spawner system is listening for entities with hover feedback, when a input is emitted
 * just spawn a new cube randomly and animate the spawner with a bounce.
 */
export function spawnerSystem() {
  const clickedCubes = engine.getEntitiesWith(PointerHoverFeedback)
  for (const [entity] of clickedCubes) {
    if (inputSystem.isTriggered(InputAction.IA_PRIMARY, PointerEventType.PET_DOWN, entity)) {
      createCube(1 + Math.random() * 8, Math.random() * 8, 1 + Math.random() * 8, false)
      BounceScaling.createOrReplace(entity)
    }
  }
}

/**
 * Add this system and every entity with BounceScaling will bounce for 5 seconds
 * @param dt - detal time in seconds
 */
export function bounceScalingSystem(dt: number) {
  const clickedCubes = engine.getEntitiesWith(BounceScaling, Transform)
  for (const [entity] of clickedCubes) {
    const m = BounceScaling.getMutable(entity)
    m.t += dt

    if (m.t > 5) {
      Transform.getMutable(entity).scale = Vector3.One()
      BounceScaling.deleteFrom(entity)
    } else {
      const factor = 0.9 + 0.2 * Math.exp(-1.5 * m.t) * Math.sin(10 * m.t)
      Transform.getMutable(entity).scale = Vector3.scale(Vector3.One(), factor)
    }
  }
}"
/* single box */ ,"<!DOCTYPE html>
<html>
  <head>
    <title>My Decentraland Scene</title>
    <script src=""https://sdk.decentraland.org/7.0.0/decentraland-ecs.min.js""></script>
  </head>
  <body>
    <div id=""gameContainer""></div>
    <script>
      // Define the scene
      const scene = new Entity();
      engine.addEntity(scene);

      // Add a box to the scene
      const myBox = new BoxShape();
      const boxEntity = new Entity();
      boxEntity.addComponent(myBox);
      scene.addChild(boxEntity);

      // Define the camera
      const camera = new Camera();
      camera.position.set(0, 1.6, -4);
      camera.rotation.set(0, 0, 0);
      engine.addEntity(camera);

      // Render the scene
      const engine = new Engine();
      engine.addSystem(new RenderSystem());
      engine.start();
    </script>
  </body>
</html>"
/* skybox */ ,"// Create a new Skybox
const skybox = new Skybox();

// Set the URL for the skybox image
skybox.texture = new Texture('https://decentraland.org/images/skybox.png');

// Add the Skybox to the scene
engine.addEntity(skybox);"
/* text label */ ,"// Create a new TextShape
const textShape = new TextShape();

// Set the text and font size
textShape.value = ""Hello, World!"";
textShape.fontSize = 3;

// Create a new Entity for the TextShape
const textEntity = new Entity();
textEntity.addComponent(textShape);

// Set the position of the Text Entity
textEntity.position.set(0, 2, 0);

// Add the Text Entity to the scene
engine.addEntity(textEntity);"
/* animated object */,"// Create a new Entity for the Animated Object
const animatedEntity = new Entity();

// Add a GLTFShape component for the 3D model
const model = new GLTFShape('https://decentraland.org/models/male.glb');
animatedEntity.addComponent(model);

// Add an Animator component for the animation
const animator = new Animator();
animatedEntity.addComponent(animator);

// Define the animation clip
const clip = new AnimationClip('idle', 0, 30);
const curve = new AnimationCurve();
curve.addKey(new AnimationKeyframe(0, 0));
curve.addKey(new AnimationKeyframe(30, 360));
clip.addChannel(new AnimationChannel('rotation', curve));

// Add the animation clip to the Animator component
animator.addClip(clip);

// Set the position of the Animated Entity
animatedEntity.position.set(0, 0, 0);

// Add the Animated Entity to the scene
engine.addEntity(animatedEntity);"
/* create a material and apply it to an object */,"// Create a new Material
const material = new Material();

// Set the color of the material
material.albedoColor = new Color4(1, 0, 0, 1);

// Create a new Entity for the Object
const objectEntity = new Entity();

// Add a BoxShape component for the 3D model
const objectShape = new BoxShape();
objectEntity.addComponent(objectShape);

// Add a Material component for the material
objectEntity.addComponent(material);

// Set the position of the Object Entity
objectEntity.position.set(0, 1, 0);

// Add the Object Entity to the scene
engine.addEntity(objectEntity);"
/* create a basic user interface */,"// Create a new UI Container
const uiContainer = new UIContainer();

// Set the position and size of the UI Container
uiContainer.positionX = 20;
uiContainer.positionY = 20;
uiContainer.width = 200;
uiContainer.height = 100;

// Create a new UI Text Label
const uiLabel = new UIText();

// Set the text and font size for the label
uiLabel.value = ""Hello, World!"";
uiLabel.fontSize = 20;

// Add the label to the UI Container
uiContainer.addChild(uiLabel);

// Add the UI Container to the scene
engine.addEntity(uiContainer);"
/* add user interface to an object */ ,"// Create a new Entity for the Object
const interactiveEntity = new Entity();

// Add a SphereShape component for the 3D model
const interactiveShape = new SphereShape();
interactiveEntity.addComponent(interactiveShape);

// Add an Interactive component for user interaction
const interactiveComponent = new Interactive();
interactiveEntity.addComponent(interactiveComponent);

// Define the actions to take when the user clicks the object
interactiveComponent.onClick = new OnClick(() => {
    // Change the color of the object
    const material = interactiveEntity.getComponent(Material);
    material.albedoColor = new Color4(0, 1, 0, 1);
});

// Set the position of the Object Entity
interactiveEntity.position.set(0, 1, 0);

// Add the Interactive Entity to the scene
engine.addEntity(interactiveEntity);"
/* create an entity with multiple components */ ,"// Create a new Entity for the Object
const entity = new Entity();

// Add a GLTFShape component for the 3D model
const shape = new GLTFShape('https://decentraland.org/models/male.glb');
entity.addComponent(shape);

// Add a Material component for the texture
const material = new Material();
material.albedoTexture = new Texture('https://decentraland.org/images/texture.png');
entity.addComponent(material);

// Add a Transform component for the position and rotation
const transform = new Transform();
transform.position.set(1, 1, 0);
transform.rotation.setEuler(0, 90, 0);
entity.addComponent(transform);

// Add the Entity to the scene
engine.addEntity(entity);"
/* create a custom shader */,"// Define the Custom Shader code
const customShaderCode = `
    precision mediump float;

    uniform vec4 u_color;

    void main() {
        gl_FragColor = u_color;
    }
`;

// Create a new ShaderMaterial
const customShaderMaterial = new ShaderMaterial();
customShaderMaterial.addFragmentShader(customShaderCode);

// Set the color of the shader material
customShaderMaterial.setUniform('u_color', new Color4(1, 1, 0, 1));

// Create a new Entity for the Object
const shaderEntity = new Entity();

// Add a BoxShape component for the 3D model
const shaderShape = new BoxShape();
shaderEntity.addComponent(shaderShape);

// Add the custom shader material to the entity
shaderEntity.addComponent(customShaderMaterial);

// Set the position of the Object Entity
shaderEntity.position.set(0, 1, 0);

// Add the Object Entity to the scene
engine.addEntity(shaderEntity);"
/* create a custom component */ ,"// Define the Custom Component
class CustomComponent {
    constructor() {
        this.value = 0;
    }

    update() {
        this.value++;
        log(this.value);
    }
}

// Create a new Entity for the Object
const customEntity = new Entity();

// Add the custom component to the entity
customEntity.addComponent(new CustomComponent());

// Set the position of the Object Entity
customEntity.position.set(0, 1, 0);

// Add the Object Entity to the scene
engine.addEntity(customEntity);"
/* add physics to an object */ ,"// Create a new Entity for the Object
const physicsEntity = new Entity();

// Add a BoxShape component for the 3D model
const physicsShape = new BoxShape();
physicsEntity.addComponent(physicsShape);

// Add a RigidBody component for physics simulation
const physicsBody = new RigidBody();
physicsEntity.addComponent(physicsBody);

// Add a Collider component for collision detection
const physicsCollider = new Collider();
physicsEntity.addComponent(physicsCollider);

// Set the position and rotation of the Object Entity
physicsEntity.position.set(0, 1, 0);
physicsEntity.rotation.setEuler(0, 45, 0);

// Add the Object Entity to the scene
engine.addEntity(physicsEntity);"
/* add sound to a scene */,"// Create a new Entity for the Sound
const soundEntity = new Entity();

// Add an AudioSource component for the sound
const soundSource = new AudioSource(new AudioClip('https://decentraland.org/sounds/sound.mp3'));
soundEntity.addComponent(soundSource);

// Set the position of the Sound Entity
soundEntity.position.set(0, 1, 0);

// Add the Sound Entity to the scene
engine.addEntity(soundEntity);

// Play the sound
soundSource.playing = true;"
/* create an animation */ ,"// Create a new Entity for the Object
const animationEntity = new Entity();

// Add a GLTFShape component for the 3D model
const animationShape = new GLTFShape('https://decentraland.org/models/animation.glb');
animationEntity.addComponent(animationShape);

// Add an Animator component for the animation
const animationAnimator = new Animator();
animationEntity.addComponent(animationAnimator);

// Define the animation clip
const animationClip = new AnimationClip('animation', 1, [
    new AnimationTrack(
        'rotation.y',
        AnimationTrackType.Number,
        [0, 1],
        [0, 360]
    )
]);

// Add the animation clip to the Animator
animationAnimator.addClip(animationClip);

// Set the position of the Object Entity
animationEntity.position.set(0, 1, 0);

// Add the Object Entity to the scene
engine.addEntity(animationEntity);

// Play the animation
animationAnimator.getClip('animation').play();"
/* create a test entity */,"// Create a new Entity for the Text
const textEntity = new Entity();

// Add a TextShape component for the text
const textShape = new TextShape('Hello, World!');
textEntity.addComponent(textShape);

// Set the position and rotation of the Text Entity
textEntity.position.set(0, 1, 0);
textEntity.rotation.setEuler(0, 45, 0);

// Add the Text Entity to the scene
engine.addEntity(textEntity);"
/* create a UI button */,"// Create a new Entity for the Button
const buttonEntity = new Entity();

// Add a UIImage component for the button image
const buttonImage = new UIImage('https://decentraland.org/images/button.png');
buttonImage.width = '100px';
buttonImage.height = '50px';
buttonEntity.addComponent(buttonImage);

// Add a UIContainerRect component for the button hitbox
const buttonHitbox = new UIContainerRect();
buttonHitbox.width = '100px';
buttonHitbox.height = '50px';
buttonHitbox.isPointerBlocker = true;
buttonEntity.addComponent(buttonHitbox);

// Add a Clickable component for the button click event
const buttonClickable = new Clickable();
buttonClickable.onClick = new OnClick(() => log('Button clicked!'));
buttonEntity.addComponent(buttonClickable);

// Set the position of the Button Entity
buttonEntity.position.set(0, 1, 0);

// Add the Button Entity to the scene
engine.addEntity(buttonEntity);"
/* create a path for  movement */,"// Define the Path points
const pathPoints = [    new Vector3(0, 1, 0),    new Vector3(1, 1, 1),    new Vector3(2, 1, 0),    new Vector3(1, 1, -1)];

// Create a new Entity for the Object
const pathEntity = new Entity();

// Add a BoxShape component for the 3D model
const pathShape = new BoxShape();
pathEntity.addComponent(pathShape);

// Add a Transform component for the initial position and rotation
const pathTransform = new Transform();
pathTransform.position.copyFrom(pathPoints[0]);
pathEntity.addComponent(pathTransform);

// Add a PathFollower component for the movement
const pathFollower = new PathFollower(pathPoints, 2);
pathEntity.addComponent(pathFollower);

// Set the position of the Object Entity
pathEntity.position.set(0, 1, 0);

// Add the Object Entity to the scene
engine.addEntity(pathEntity);"
/* create a video entity */,"// Create a new Entity for the Video
const videoEntity = new Entity();

// Add a VideoTexture component for the video
const videoClip = new VideoClip('https://decentraland.org/videos/video.mp4');
const videoTexture = new VideoTexture(videoClip);
const videoMaterial = new Material();
videoMaterial.albedoTexture = videoTexture;
const videoShape = new PlaneShape();
videoShape.withCollisions = false;
videoEntity.addComponentOrReplace(videoShape);
videoEntity.addComponentOrReplace(videoMaterial);

// Set the position of the Video Entity
videoEntity.position.set(0, 1, 0);

// Play the video clip
videoClip.play();

// Add the Video Entity to the scene
engine.addEntity(videoEntity);"
/* create a particle effect entity */ ,"// Create a new Entity for the Particle Effect
const particleEntity = new Entity();

// Add a ParticleSystem component for the particle effect
const particleShape = new SphereShape();
particleShape.withCollisions = false;
const particleSystem = new ParticleSystem(particleShape, {
    position: new Vector3(0, 1, 0),
    lifetime: 3,
    size: 0.5,
    colorStart: new Color4(1, 1, 0, 1),
    colorEnd: new Color4(1, 0, 0, 0),
    maxEmission: 50,
    emissionRate: 20,
    speed: 0.1,
    acceleration: new Vector3(0, -0.05, 0),
    shapeType: ParticleSystemShapeType.Sphere,
    sizeRange: 0.5,
    sizeCurve: [[0, 1], [1, 0]]
});
particleEntity.addComponent(particleSystem);

// Add a Transform component for the initial position and rotation
const particleTransform = new Transform();
particleTransform.position.set(0, 1, 0);
particleEntity.addComponent(particleTransform);

// Set the position of the Particle Effect Entity
particleEntity.position.set(0, 1, 0);

// Add the Particle Effect Entity to the scene
engine.addEntity(particleEntity);"
/* create light entity */,"// Create a new Entity for the Light
const lightEntity = new Entity();

// Add a light component to the entity
const light = new PointLight();
light.color = new Color3(1, 1, 1);
light.intensity = 2;
light.range = 10;
lightEntity.addComponent(light);

// Set the position of the Light Entity
lightEntity.position.set(0, 2, 0);

// Add the Light Entity to the scene
engine.addEntity(lightEntity);"
/* create a camera entity */,"// Create a new Entity for the Camera
const cameraEntity = new Entity();

// Add a Camera component to the entity
const camera = new Camera();
cameraEntity.addComponent(camera);

// Set the position of the Camera Entity
cameraEntity.position.set(0, 2, 5);

// Add the Camera Entity to the scene
engine.addEntity(cameraEntity);"
/* create a particle system */,"// Create a new Entity for the Particle System
const particleEntity = new Entity();

// Add a ParticleSystem component to the entity
const particleSystem = new ParticleSystem();
particleSystem.mesh = new PlaneShape();
particleSystem.texture = 'textures/particle-texture.png';
particleSystem.color1 = new Color4(0.3, 0.5, 1, 1);
particleSystem.color2 = new Color4(0.3, 0.5, 1, 0.5);
particleSystem.color3 = new Color4(0.3, 0.5, 1, 0);
particleSystem.color4 = new Color4(0.3, 0.5, 1, 0);
particleSystem.minSize = 0.1;
particleSystem.maxSize = 0.5;
particleSystem.playing = true;
particleEntity.addComponentOrReplace(particleSystem);

// Set the position of the Particle Entity
particleEntity.position.set(0, 2, 0);

// Add the Particle Entity to the scene
engine.addEntity(particleEntity);"
/* create a billboard entity */ ,"// Create a new Entity for the Billboard
const billboardEntity = new Entity();

// Add a Billboard component to the entity
const billboard = new Billboard();
billboardEntity.addComponentOrReplace(billboard);

// Add a Texture component for the billboard image
const texture = new Texture('textures/billboard-image.png');
const material = new Material();
material.albedoTexture = texture;
billboardEntity.addComponentOrReplace(material);

// Set the position of the Billboard Entity
billboardEntity.position.set(0, 2, 0);

// Add the Billboard Entity to the scene
engine.addEntity(billboardEntity);
I hope you find these examples helpful in your development with the Decentraland SDK7.


"
/* create a flying entity */ ,"// Create a new Entity for the Flying Object
const flyingEntity = new Entity();

// Add a Transform component to the entity
const transform = new Transform();
flyingEntity.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model
const shape = new GLTFShape('models/flying-object.glb');
flyingEntity.addComponentOrReplace(shape);

// Add a Rigidbody component to make the object ""fly""
const rigidbody = new Rigidbody();
rigidbody.mass = 1;
rigidbody.useGravity = false;
rigidbody.isKinematic = false;
rigidbody.isCollidable = true;
rigidbody.freezeRotation = true;
flyingEntity.addComponentOrReplace(rigidbody);

// Set the initial position of the Flying Entity
flyingEntity.position.set(0, 5, 0);

// Add the Flying Entity to the scene
engine.addEntity(flyingEntity);"
/* create a dancing entity */,"// Create a new Entity for the Dancing Character
const dancingEntity = new Entity();

// Add a Transform component to the entity
const transform = new Transform();
dancingEntity.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model
const shape = new GLTFShape('models/dancing-character.glb');
dancingEntity.addComponentOrReplace(shape);

// Add an Animator component to make the character dance
const animator = new Animator();
const animation = new AnimationState('dance');
animation.speed = 2;
animator.addClip(animation);
dancingEntity.addComponentOrReplace(animator);

// Set the initial position of the Dancing Entity
dancingEntity.position.set(0, 0, 0);

// Add the Dancing Entity to the scene
engine.addEntity(dancingEntity);"
/* create a talking entity */,"// Create a new Entity for the Talking Head
const talkingEntity = new Entity();

// Add a Transform component to the entity
const transform = new Transform();
talkingEntity.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model
const shape = new GLTFShape('models/talking-head.glb');
talkingEntity.addComponentOrReplace(shape);

// Add an AudioSource component for the talking sound
const sound = new AudioClip('sounds/talking-sound.mp3');
const source = new AudioSource(sound);
talkingEntity.addComponentOrReplace(source);

// Add an Interval component to make the head move and talk
const interval = new Interval(1000, () => {
  transform.rotate(Vector3.Up(), 45);
  source.playOnce();
});
interval.start();
talkingEntity.addComponentOrReplace(interval);

// Set the initial position of the Talking Entity
talkingEntity.position.set(0, 2, 0);

// Add the Talking Entity to the scene
engine.addEntity(talkingEntity);"
/* create a silly entity */,"// Create a new Entity for the Silly Object
const sillyEntity = new Entity();

// Add a Transform component to the entity
const transform = new Transform();
sillyEntity.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model
const shape = new GLTFShape('models/silly-object.glb');
sillyEntity.addComponentOrReplace(shape);

// Add a Rotation component to make the object spin
const rotation = new Rotation();
rotation.value = Quaternion.Euler(0, 45, 0);
sillyEntity.addComponentOrReplace(rotation);

// Add a Scale component to make the object grow and shrink
const scale = new Scale();
scale.value = new Vector3(1, 1, 1);
sillyEntity.addComponentOrReplace(scale);

// Add an Interval component to change the rotation and scale of the object
const interval = new Interval(1000, () => {
  transform.rotate(Vector3.Up(), 45);
  scale.value = new Vector3(Math.random() * 2, Math.random() * 2, Math.random() * 2);
});
interval.start();
sillyEntity.addComponentOrReplace(interval);

// Set the initial position of the Silly Entity
sillyEntity.position.set(0, 2, 0);

// Add the Silly Entity to the scene
engine.addEntity(sillyEntity);"
/* create a floating entity */,"// Create a new Entity for the Floating Object
const floatingEntity = new Entity();

// Add a Transform component to the entity
const transform = new Transform();
floatingEntity.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model
const shape = new GLTFShape('models/floating-object.glb');
floatingEntity.addComponentOrReplace(shape);

// Add a Rigidbody component to make the object ""float""
const rigidbody = new Rigidbody();
rigidbody.mass = 0;
rigidbody.useGravity = false;
rigidbody.isKinematic = true;
rigidbody.isCollidable = true;
rigidbody.freezeRotation = true;
floatingEntity.addComponentOrReplace(rigidbody);

// Add a Pulse component to make the object ""pulse""
const pulse = new Pulse();
pulse.minScale = new Vector3(0.5, 0.5, 0.5);
pulse.maxScale = new Vector3(1.5, 1.5, 1.5);
pulse.duration = 1000;
pulse.pingPong = true;
floatingEntity.addComponentOrReplace(pulse);

// Set the initial position of the Floating Entity
floatingEntity.position.set(0, 2, 0);

// Add the Floating Entity to the scene
engine.addEntity(floatingEntity);"
"/* create a new class ""Collectible"" that represents collectible items in a game */","export class Collectible extends Entity {
  constructor(model: GLTFShape, position: Vector3) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Transform({ position: position }))
    this.addComponent(new Animator())
    this.getComponent(Animator).addClip(new AnimationState(""Spin"", { looping: true }))
    this.setParent(scene)
  }

  collect() {
    this.destroy()
  }
}
"
/* create a disco ball entity */,"// Create a new Entity for the Disco Ball
const discoEntity = new Entity();

// Add a Transform component to the entity
const transform = new Transform();
discoEntity.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model
const shape = new GLTFShape('models/disco-ball.glb');
discoEntity.addComponentOrReplace(shape);

// Add an Animator component to make the ball rotate
const animator = new Animator();
const animation = new AnimationState('rotate');
animation.speed = 1;
animator.addClip(animation);
discoEntity.addComponentOrReplace(animator);

// Add a PointLight component to create a disco light effect
const light = new PointLight();
light.intensity = 2;
light.range = 10;
light.color = Color3.Random();
discoEntity.addComponentOrReplace(light);

// Set the initial position of the Disco Entity
discoEntity.position.set(0, 5, 0);

// Add the Disco Entity to the scene
engine.addEntity(discoEntity);"
/* farting entity */,"// Create a new Entity for the Farting Character
const fartEntity = new Entity();

// Add a Transform component to the entity
const transform = new Transform();
fartEntity.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model
const shape = new GLTFShape('models/farting-character.glb');
fartEntity.addComponentOrReplace(shape);

// Add an AudioSource component for the fart sound
const sound = new AudioClip('sounds/fart-sound.mp3');
const source = new AudioSource(sound);
fartEntity.addComponentOrReplace(source);

// Add an Interval component to make the character fart
const interval = new Interval(3000, () => {
  source.playOnce();
});
interval.start();
fartEntity.addComponentOrReplace(interval);

// Set the initial position of the Farting Entity
fartEntity.position.set(0, 0, 0);

// Add the Farting Entity to the scene
engine.addEntity(fartEntity);"
/* drunk entity */ ,"// Create a new Entity for the Drunk Character
const drunkEntity = new Entity();

// Add a Transform component to the entity
const transform = new Transform();
drunkEntity.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model
const shape = new GLTFShape('models/drunk-character.glb');
drunkEntity.addComponentOrReplace(shape);

// Add an Animator component to make the character stagger
const animator = new Animator();
const animation = new AnimationState('stagger');
animation.speed = 1;
animator.addClip(animation);
drunkEntity.addComponentOrReplace(animator);

// Add a Rigidbody component to make the character fall down
const rigidbody = new Rigidbody();
rigidbody.mass = 1;
rigidbody.useGravity = true;
rigidbody.isKinematic = false;
rigidbody.isCollidable = true;
rigidbody.freezeRotation = true;
drunkEntity.addComponentOrReplace(rigidbody);

// Set the initial position of the Drunk Entity
drunkEntity.position.set(0, 0, 0);

// Add the Drunk Entity to the scene
engine.addEntity(drunkEntity);"
/* basket ball court */,"// Create a new Entity for the Basketball Court
const courtEntity = new Entity();

// Add a Transform component to the entity
const transform = new Transform();
courtEntity.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model
const shape = new GLTFShape('models/basketball-court.glb');
courtEntity.addComponentOrReplace(shape);

// Set the initial position of the Basketball Court
courtEntity.position.set(0, 0, 0);

// Add the Basketball Court Entity to the scene
engine.addEntity(courtEntity);

// Add a click event listener to the court to start a game
courtEntity.addComponent(
  new OnClick(() => {
    startGame();
  })
);

// Function to start the game
function startGame() {
  // Create a new Entity for the Basketball
  const ballEntity = new Entity();

  // Add a Transform component to the entity
  const transform = new Transform();
  ballEntity.addComponentOrReplace(transform);

  // Add a GLTFShape component for the 3D model
  const shape = new GLTFShape('models/basketball.glb');
  ballEntity.addComponentOrReplace(shape);

  // Add a Rigidbody component to the ball to make it bounce
  const rigidbody = new Rigidbody();
  rigidbody.mass = 0.5;
  rigidbody.useGravity = true;
  rigidbody.isKinematic = false;
  rigidbody.isCollidable = true;
  rigidbody.freezeRotation = true;
  ballEntity.addComponentOrReplace(rigidbody);

  // Set the initial position of the Basketball
  ballEntity.position.set(0, 1, 0);

  // Add the Basketball Entity to the scene
  engine.addEntity(ballEntity);

  // Add a click event listener to the ball to shoot it
  ballEntity.addComponent(
    new OnClick(() => {
      shootBall();
    })
  );

  // Function to shoot the ball
  function shootBall() {
    const force = new Vector3(0, 5, 10);
    rigidbody.applyImpulse(force);
  }
}"
/* tennis court */,"// Create a new Entity for the Tennis Court
const courtEntity = new Entity();

// Add a Transform component to the entity
const transform = new Transform();
courtEntity.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model
const shape = new GLTFShape('models/tennis-court.glb');
courtEntity.addComponentOrReplace(shape);

// Set the initial position of the Tennis Court
courtEntity.position.set(0, 0, 0);

// Add the Tennis Court Entity to the scene
engine.addEntity(courtEntity);

// Add a click event listener to the court to start a game
courtEntity.addComponent(
  new OnClick(() => {
    startGame();
  })
);

// Function to start the game
function startGame() {
  // Create a new Entity for the Tennis Ball
  const ballEntity = new Entity();

  // Add a Transform component to the entity
  const transform = new Transform();
  ballEntity.addComponentOrReplace(transform);

  // Add a GLTFShape component for the 3D model
  const shape = new GLTFShape('models/tennis-ball.glb');
  ballEntity.addComponentOrReplace(shape);

  // Add a Rigidbody component to the ball to make it bounce
  const rigidbody = new Rigidbody();
  rigidbody.mass = 0.1;
  rigidbody.useGravity = true;
  rigidbody.isKinematic = false;
  rigidbody.isCollidable = true;
  rigidbody.freezeRotation = true;
  ballEntity.addComponentOrReplace(rigidbody);

  // Set the initial position of the Tennis Ball
  ballEntity.position.set(0, 1, 0);

  // Add the Tennis Ball Entity to the scene
  engine.addEntity(ballEntity);

  // Add a click event listener to the ball to hit it
  ballEntity.addComponent(
    new OnClick(() => {
      hitBall();
    })
  );

  // Function to hit the ball
  function hitBall() {
    const force = new Vector3(0, 5, 10);
    rigidbody.applyImpulse(force);
  }
}"
/* golf course */,"// Create a new Entity for the Golf Course
const courseEntity = new Entity();

// Add a Transform component to the entity
const transform = new Transform();
courseEntity.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model
const shape = new GLTFShape('models/golf-course.glb');
courseEntity.addComponentOrReplace(shape);

// Set the initial position of the Golf Course
courseEntity.position.set(0, 0, 0);

// Add the Golf Course Entity to the scene
engine.addEntity(courseEntity);

// Add a click event listener to the course to start a game
courseEntity.addComponent(
  new OnClick(() => {
    startGame();
  })
);

// Function to start the game
function startGame() {
  // Create a new Entity for the Golf Ball
  const ballEntity = new Entity();

  // Add a Transform component to the entity
  const transform = new Transform();
  ballEntity.addComponentOrReplace(transform);

  // Add a GLTFShape component for the 3D model
  const shape = new GLTFShape('models/golf-ball.glb');
  ballEntity.addComponentOrReplace(shape);

  // Add a Rigidbody component to the ball to make it bounce
  const rigidbody = new Rigidbody();
  rigidbody.mass = 0.05;
  rigidbody.useGravity = true;
  rigidbody.isKinematic = false;
  rigidbody.isCollidable = true;
  rigidbody.freezeRotation = true;
  ballEntity.addComponentOrReplace(rigidbody);

  // Set the initial position of the Golf Ball
  ballEntity.position.set(0, 1, 0);

  // Add the Golf Ball Entity to the scene
  engine.addEntity(ballEntity);

  // Add a click event listener to the ball to hit it
  ballEntity.addComponent(
    new OnClick(() => {
      hitBall();
    })
  );

  // Function to hit the ball
  function hitBall() {
    const force = new Vector3(0, 5, 10);
    rigidbody.applyImpulse(force);
  }
}"
/* add background music */,"// Create a new Entity for the music player
const musicEntity = new Entity();

// Add an AudioSource component to the entity
const audioSource = new AudioSource(new AudioClip('sounds/background-music.mp3'));
musicEntity.addComponentOrReplace(audioSource);

// Set the volume of the music
audioSource.volume = 0.5;

// Set the loop property to true so the music plays continuously
audioSource.loop = true;

// Add the music Entity to the scene
engine.addEntity(musicEntity);

// Play the music
audioSource.playing = true;"
/* triggering sound effect with button press */,"// Create a new Entity for the button
const buttonEntity = new Entity();

// Add a Transform component to the entity
const transform = new Transform();
buttonEntity.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the button
const shape = new GLTFShape('models/button.glb');
buttonEntity.addComponentOrReplace(shape);

// Set the initial position of the button
buttonEntity.position.set(0, 0, 0);

// Add the button Entity to the scene
engine.addEntity(buttonEntity);

// Add a click event listener to the button to trigger the sound effect
buttonEntity.addComponent(
  new OnClick(() => {
    playSoundEffect();
  })
);

// Function to play the sound effect
function playSoundEffect() {
  // Create a new Entity for the sound effect player
  const soundEntity = new Entity();

  // Add an AudioSource component to the entity
  const audioSource = new AudioSource(new AudioClip('sounds/sound-effect.mp3'));
  soundEntity.addComponentOrReplace(audioSource);

  // Set the volume of the sound effect
  audioSource.volume = 1;

  // Add the sound effect Entity to the scene
  engine.addEntity(soundEntity);

  // Play the sound effect
  audioSource.playing = true;

  // Remove the sound effect Entity after it finishes playing
  audioSource.onEnded = () => {
    engine.removeEntity(soundEntity);
  }
}"
/* cat */,"// Create a new Entity for the cat
const catEntity = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  scale: new Vector3(0.1, 0.1, 0.1)
});
catEntity.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the cat
const shape = new GLTFShape('models/cat.glb');
catEntity.addComponentOrReplace(shape);

// Add the cat Entity to the scene
engine.addEntity(catEntity);"
/* fish */,"// Create a new Entity for the fish
const fishEntity = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  scale: new Vector3(0.1, 0.1, 0.1)
});
fishEntity.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the fish
const shape = new GLTFShape('models/fish.glb');
fishEntity.addComponentOrReplace(shape);


// Add the fish Entity to the scene
engine.addEntity(fishEntity);"
"/* create a new class ""Explosion"" that shows explosions in a game */",
"/* create a new class ""Platform"" that represents moving platforms in a game */","export class Explosion extends Entity {
  constructor(model: GLTFShape, position: Vector3) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Transform({ position: position }))
    this.addComponent(new Animator())
    this.getComponent(Animator).addClip(new AnimationState(""Explode"", { looping: false }))
    this.setParent(scene)
  }

  explode() {
    this.getComponent(Animator).getClip(""Explode"").stop() // Bug workaround
    this.getComponent(Animator).getClip(""Explode"").play()
  }
}
"
/* basketball hoop */,"// Create a new Entity for the basketball hoop
const basketballHoop = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  rotation: Quaternion.Euler(0, 45, 0),
  scale: new Vector3(0.5, 0.5, 0.5)
});
basketballHoop.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the basketball hoop
const shape = new GLTFShape('models/basketball_hoop.glb');
basketballHoop.addComponentOrReplace(shape);

// Add a Clickable component to the entity to detect clicks on the basketball hoop
const clickable = new Clickable();
clickable.onClick = () => {
  // Code to handle a click on the basketball hoop
};
basketballHoop.addComponentOrReplace(clickable);

// Add the basketball hoop Entity to the scene
engine.addEntity(basketballHoop);"
/* soccer ball */,"// Create a new Entity for the soccer ball
const soccerBall = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  scale: new Vector3(0.1, 0.1, 0.1)
});
soccerBall.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the soccer ball
const shape = new GLTFShape('models/soccer_ball.glb');
soccerBall.addComponentOrReplace(shape);

// Add a RigidBody component to the entity to make it affected by physics
const rigidBody = new RigidBody();
soccerBall.addComponentOrReplace(rigidBody);

// Add the soccer ball Entity to the scene
engine.addEntity(soccerBall);"
/* fish tank */,"// Create a new Entity for the fish tank
const fishTank = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  scale: new Vector3(0.3, 0.3, 0.3)
});
fishTank.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the fish tank
const shape = new GLTFShape('models/fish_tank.glb');
fishTank.addComponentOrReplace(shape);

// Add an AudioSource component to the entity to play water sounds
const audioSource = new AudioSource(new AudioClip('sounds/water.mp3'));
audioSource.playing = true;
audioSource.loop = true;
fishTank.addComponentOrReplace(audioSource);

// Add the fish tank Entity to the scene
engine.addEntity(fishTank);"
/* bird */,"// Create a new Entity for the bird
const bird = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 2, 5),
  scale: new Vector3(0.2, 0.2, 0.2)
});
bird.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the bird
const shape = new GLTFShape('models/bird.glb');
bird.addComponentOrReplace(shape);

// Add an Animator component to the entity to animate the bird's wings
const animator = new Animator();
const clip = new AnimationState('Armature|Fly');
animator.addClip(clip);
clip.play();
bird.addComponentOrReplace(animator);

// Add the bird Entity to the scene
engine.addEntity(bird);"
/* piano */,"// Create a new Entity for the piano
const piano = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  rotation: Quaternion.Euler(0, 90, 0),
  scale: new Vector3(0.5, 0.5, 0.5)
});
piano.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the piano
const shape = new GLTFShape('models/piano.glb');
piano.addComponentOrReplace(shape);

// Add an AudioSource component to the entity to play piano sounds
const audioSource = new AudioSource(new AudioClip('sounds/piano.mp3'));
piano.addComponentOrReplace(audioSource);

// Add the piano Entity to the scene
engine.addEntity(piano);"
/* drum set */,"// Create a new Entity for the drum set
const drumSet = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  rotation: Quaternion.Euler(0, 90, 0),
  scale: new Vector3(0.5, 0.5, 0.5)
});
drumSet.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the drum set
const shape = new GLTFShape('models/drum_set.glb');
drumSet.addComponentOrReplace(shape);

// Add an AudioSource component to the entity to play drum sounds
const audioSource = new AudioSource(new AudioClip('sounds/drum.mp3'));
drumSet.addComponentOrReplace(audioSource);

// Add the drum set Entity to the scene
engine.addEntity(drumSet);"
/* guitar */,"// Create a new Entity for the guitar
const guitar = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  rotation: Quaternion.Euler(0, 90, 0),
  scale: new Vector3(0.5, 0.5, 0.5)
});
guitar.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the guitar
const shape = new GLTFShape('models/guitar.glb');
guitar.addComponentOrReplace(shape);

// Add an AudioSource component to the entity to play guitar sounds
const audioSource = new AudioSource(new AudioClip('sounds/guitar.mp3'));
guitar.addComponentOrReplace(audioSource);

// Add the guitar Entity to the scene
engine.addEntity(guitar);"
/* stove */,"// Create a new Entity for the stove
const stove = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  rotation: Quaternion.Euler(0, 90, 0),
  scale: new Vector3(0.5, 0.5, 0.5)
});
stove.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the stove
const shape = new GLTFShape('models/stove.glb');
stove.addComponentOrReplace(shape);

// Add the stove Entity to the scene
engine.addEntity(stove);"
/* frying pan ,"// Create a new Entity for the frying pan
const fryingPan = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  rotation: Quaternion.Euler(0, 90, 0),
  scale: new Vector3(0.5, 0.5, 0.5)
});
fryingPan.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the frying pan
const shape = new GLTFShape('models/frying_pan.glb');
fryingPan.addComponentOrReplace(shape);

// Add the frying pan Entity to the scene
engine.addEntity(fryingPan);"
/* cutting board */,"// Create a new Entity for the cutting board
const cuttingBoard = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  rotation: Quaternion.Euler(0, 90, 0),
  scale: new Vector3(0.5, 0.5, 0.5)
});
cuttingBoard.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the cutting board
const shape = new GLTFShape('models/cutting_board.glb');
cuttingBoard.addComponentOrReplace(shape);

// Add the cutting board Entity to the scene
engine.addEntity(cuttingBoard);"
/* refrigerator */,"// Create a new Entity for the refrigerator
const refrigerator = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  rotation: Quaternion.Euler(0, 90, 0),
  scale: new Vector3(0.5, 0.5, 0.5)
});
refrigerator.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the refrigerator
const shape = new GLTFShape('models/refrigerator.glb');
refrigerator.addComponentOrReplace(shape);

// Add the refrigerator Entity to the scene
engine.addEntity(refrigerator);"
/* kitchen island */,"// Create a new Entity for the kitchen island
const kitchenIsland = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  rotation: Quaternion.Euler(0, 90, 0),
  scale: new Vector3(0.5, 0.5, 0.5)
});
kitchenIsland.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the kitchen island
const shape = new GLTFShape('models/kitchen_island.glb');
kitchenIsland.addComponentOrReplace(shape);

// Add the kitchen island Entity to the scene
engine.addEntity(kitchenIsland);"
/* kitchen sink */,"// Create a new Entity for the kitchen sink
const kitchenSink = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  rotation: Quaternion.Euler(0, 90, 0),
  scale: new Vector3(0.5, 0.5, 0.5)
});
kitchenSink.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the kitchen sink
const shape = new GLTFShape('models/kitchen_sink.glb');
kitchenSink.addComponentOrReplace(shape);

// Add the kitchen sink Entity to the scene
engine.addEntity(kitchenSink);"
/* t shirt */ ,"// Create a new Entity for the T-shirt
const tshirt = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  rotation: Quaternion.Euler(0, 90, 0),
  scale: new Vector3(0.5, 0.5, 0.5)
});
tshirt.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the T-shirt
const shape = new GLTFShape('models/tshirt.glb');
tshirt.addComponentOrReplace(shape);

// Add the T-shirt Entity to the scene
engine.addEntity(tshirt);"
/* pair of jeans */,"// Create a new Entity for the jeans
const jeans = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  rotation: Quaternion.Euler(0, 90, 0),
  scale: new Vector3(0.5, 0.5, 0.5)
});
jeans.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the jeans
const shape = new GLTFShape('models/jeans.glb');
jeans.addComponentOrReplace(shape);

// Add the jeans Entity to the scene
engine.addEntity(jeans);"
/* pair of sneakers */,"// Create a new Entity for the sneakers
const sneakers = new Entity();

// Add a Transform component to the entity
const transform = new Transform({
  position: new Vector3(5, 0, 5),
  rotation: Quaternion.Euler(0, 90, 0),
  scale: new Vector3(0.5, 0.5, 0.5)
});
sneakers.addComponentOrReplace(transform);

// Add a GLTFShape component for the 3D model of the sneakers
const shape = new GLTFShape('models/sneakers.glb');
sneakers.addComponentOrReplace(shape);

// Add the sneakers Entity to the scene
engine.addEntity(sneakers);"
/* create maze */,"// Create the maze using boxes and ramps
const mazeBox = new BoxShape()
mazeBox.withDimensions(4, 1, 4)
const mazeRamp = new BoxShape()
mazeRamp.withDimensions(4, 1, 1)
mazeRamp.withRotation(new Quaternion(0, 0.707, 0, 0.707))
const maze = new Entity()
maze.addComponent(new Transform({ position: new Vector3(8, 0, 8) }))
maze.addComponent(mazeBox)
engine.addEntity(maze)
const mazePlatforms = []
mazePlatforms.push(maze)"
/* banana peels */,"// Create the banana peels and sprinkle them throughout the maze
const bananaPeel = new GLTFShape(""models/banana_peel.glb"")
for (let i = 0; i < 10; i++) {
  const banana = new Entity()
  banana.addComponent(new Transform({ position: new Vector3(12, 0.5, i * 2 + 2) }))
  banana.addComponent(bananaPeel)
  engine.addEntity(banana)
}"
/* pie throwing game */,"// Create the booth with a target
const booth = new BoxShape()
booth.withDimensions(4, 6, 1)
const boothEntity = new Entity()
boothEntity.addComponent(new Transform({ position: new Vector3(10, 3, 10) }))
boothEntity.addComponent(booth)
engine.addEntity(boothEntity)

const target = new GLTFShape(""models/target.glb"")
const targetEntity = new Entity()
targetEntity.addComponent(new Transform({ position: new Vector3(10, 6, 9.5) }))
targetEntity.addComponent(target)
engine.addEntity(targetEntity)

// Create the pies and give them physics properties
const pie = new GLTFShape(""models/pie.glb"")
for (let i = 0; i < 10; i++) {
  const pieEntity = new Entity()
  pieEntity.addComponent(new Transform({ position: new Vector3(8 + i, 2, 12) }))
  pieEntity.addComponent(pie)
  pieEntity.addComponent(new BoxCollider())
  pieEntity.addComponent(new RigidBody())
  engine.addEntity(pieEntity)
}"
/* giant whoopee cushion */,"// Create the whoopee cushion object
const cushion = new GLTFShape(""models/whoopee_cushion.glb"")
const cushionEntity = new Entity()
cushionEntity.addComponent(new Transform({ position: new Vector3(10, 0.5, 10) }))
cushionEntity.addComponent(cushion)
engine.addEntity(cushionEntity)

// Add a click event to the cushion so that it makes a fart noise when clicked
cushionEntity.addComponent(
  new OnPointerDown(() => {
    log(""Fart noise!"")
  })
)"
/* earth */,"const sphere = new Entity();
sphere.addComponent(new SphereShape());
sphere.addComponent(new Transform({ position: new Vector3(2, 1, 2) }));
sphere.addComponent(new Material());
sphere.getComponent(Material).albedoTexture = new Texture('textures/earth.png');
engine.addEntity(sphere);"
/* cylinder with colour and rotation */,"const cylinder = new Entity();
cylinder.addComponent(new CylinderShape());
cylinder.addComponent(new Transform({ position: new Vector3(8, 1, 8), rotation: Quaternion.Euler(0, 45, 0) }));
cylinder.addComponent(new Material());
cylinder.getComponent(Material).albedoColor = Color3.Blue();
engine.addEntity(cylinder);"
/* snowman */,"const base = new Entity();
base.addComponent(new SphereShape());
base.addComponent(new Transform({ scale: new Vector3(1.5, 1.5, 1.5), position: new Vector3(5, 0, 5) }));
base.addComponent(new Material());
base.getComponent(Material).albedoColor = Color3.White();
engine.addEntity(base);

const mid = new Entity();
mid.addComponent(new SphereShape());
mid.addComponent(new Transform({ scale: new Vector3(1.2, 1.2, 1.2), position: new Vector3(5, 2.5, 5) }));
mid.addComponent(new Material());
mid.getComponent(Material).albedoColor = Color3.White();
engine.addEntity(mid);

const head = new Entity();
head.addComponent(new SphereShape());
head.addComponent(new Transform({ scale: new Vector3(0.9, 0.9, 0.9), position: new Vector3(5, 4.5, 5) }));
head.addComponent(new Material());
head.getComponent(Material).albedoColor = Color3.White();
engine.addEntity(head);

const hat = new Entity();
hat.addComponent(new BoxShape());
hat.addComponent(new Transform({ scale: new Vector3(1.2, 0.2, 1.2), position: new Vector3(5, 5.8, 5) }));
hat.addComponent(new Material());
hat.getComponent(Material).albedoColor = Color3.Black();
engine.addEntity(hat);

const nose = new Entity();
nose.addComponent(new ConeShape());
nose.addComponent(new Transform({ scale: new Vector3(0.2, 0.5, 0.2), position: new Vector3(5, 4.5, 5.8), rotation: Quaternion.Euler(180, 0, 0) }));
nose.addComponent(new Material());
nose.getComponent(Material).albedoColor = Color3.Orange();
engine.addEntity(nose);"
/* soccer field */,"import { Scene } from 'decentraland-api'
import { createMaterial } from './materials'

const scene = new Scene()

const fieldLength = 20
const fieldWidth = 10
const fieldHeight = 0.2
const fieldColor = createMaterial('green', { roughness: 1, metallic: 0 })

const goalPostHeight = 2
const goalPostWidth = 0.1
const goalPostDepth = 0.1
const goalPostColor = createMaterial('white', { roughness: 1, metallic: 0 })

// Create the field surface
const field = new BoxShape()
field.withCollisions = false
field.withoutDetails = true
field.color = fieldColor
field.position.set(0, 0, 0)
field.scale.set(fieldLength, fieldHeight, fieldWidth)
scene.addEntity(field)

// Create the center circle
const centerCircleRadius = 1
const centerCircle = new CircleShape()
centerCircle.withCollisions = false
centerCircle.withoutDetails = true
centerCircle.color = fieldColor
centerCircle.position.set(0, 0.01, 0)
centerCircle.scale.set(centerCircleRadius, 1, centerCircleRadius)
scene.addEntity(centerCircle)

// Create the penalty box
const penaltyBoxLength = 6
const penaltyBoxWidth = 2.5
const penaltyBoxHeight = 0.1
const penaltyBoxColor = createMaterial('white', { roughness: 1, metallic: 0 })

const leftPenaltyBox = new BoxShape()
leftPenaltyBox.withCollisions = false
leftPenaltyBox.withoutDetails = true
leftPenaltyBox.color = penaltyBoxColor
leftPenaltyBox.position.set(-(fieldLength/2), 0.05, 0)
leftPenaltyBox.scale.set(penaltyBoxLength, penaltyBoxHeight, penaltyBoxWidth)
scene.addEntity(leftPenaltyBox)

const rightPenaltyBox = new BoxShape()
rightPenaltyBox.withCollisions = false
rightPenaltyBox.withoutDetails = true
rightPenaltyBox.color = penaltyBoxColor
rightPenaltyBox.position.set((fieldLength/2), 0.05, 0)
rightPenaltyBox.scale.set(-penaltyBoxLength, penaltyBoxHeight, penaltyBoxWidth)
scene.addEntity(rightPenaltyBox)

// Create the goal posts
const leftGoalPost = new BoxShape()
leftGoalPost.withCollisions = false
leftGoalPost.withoutDetails = true
leftGoalPost.color = goalPostColor
leftGoalPost.position.set(-(fieldLength/2), goalPostHeight/2, 0)
leftGoalPost.scale.set(goalPostWidth, goalPostHeight, goalPostDepth)
scene.addEntity(leftGoalPost)

const rightGoalPost = new BoxShape()
rightGoalPost.withCollisions = false
rightGoalPost.withoutDetails = true
rightGoalPost.color = goalPostColor
rightGoalPost.position.set((fieldLength/2), goalPostHeight/2, 0)
rightGoalPost.scale.set(-goalPostWidth, goalPostHeight, goalPostDepth)
scene.addEntity(rightGoalPost)"
/* smiley */ ,"// create the circle shape for the face
const faceShape = new CircleShape()
faceShape.withCollisions = false
faceShape.radius = 1

// create the two eyes using rectangle shapes
const eyeShape = new PlaneShape()
eyeShape.withCollisions = false
eyeShape.width = 0.2
eyeShape.height = 0.2

// create the mouth using a rectangle shape
const mouthShape = new PlaneShape()
mouthShape.withCollisions = false
mouthShape.width = 0.5
mouthShape.height = 0.1

// create the entities for the face, eyes, and mouth
const face = new Entity()
face.addComponent(faceShape)
face.addComponent(new Transform({
  position: new Vector3(5, 1, 5)
}))
engine.addEntity(face)

const leftEye = new Entity()
leftEye.addComponent(eyeShape)
leftEye.addComponent(new Transform({
  position: new Vector3(4.5, 1.2, 5.5)
}))
engine.addEntity(leftEye)

const rightEye = new Entity()
rightEye.addComponent(eyeShape)
rightEye.addComponent(new Transform({
  position: new Vector3(5.5, 1.2, 5.5)
}))
engine.addEntity(rightEye)

const mouth = new Entity()
mouth.addComponent(mouthShape)
mouth.addComponent(new Transform({
  position: new Vector3(5, 0.8, 5.5),
  rotation: Quaternion.Euler(0, 0, 45)
}))
engine.addEntity(mouth)"
/* ground plane */,"// create the ground plane
const groundShape = new PlaneShape()
groundShape.withCollisions = false
const ground = new Entity()
ground.addComponent(groundShape)
ground.addComponent(new Transform({
  position: new Vector3(5, 0, 5),
  rotation: Quaternion.Euler(-90, 0, 0),
  scale: new Vector3(10, 10, 1)
}))
ground.addComponent(new Material())
ground.getComponent(Material).albedoColor = Color3.Green()
engine.addEntity(ground)"
/* trees */,"// create the trees using cylinder shapes
const treeShape = new CylinderShape()
treeShape.withCollisions = false
treeShape.radiusTop = 0.1
treeShape.radiusBottom = 0.5
treeShape.height = 1

// create the first tree
const tree1 = new Entity()
tree1.addComponent(treeShape)
tree1.addComponent(new Transform({
  position: new Vector3(4, 0.5, 4)
}))
tree1.getComponent(Transform).rotation = Quaternion.Euler(0, 45, 0)
tree1.addComponent(new Material())
tree1.getComponent(Material).albedoColor = Color3.Brown()
engine.addEntity(tree1)

// create the second tree
const tree2 = new Entity()
tree2.addComponent(treeShape)
tree2.addComponent(new Transform({
  position: new Vector3(6, 0.5, 6)
}))
tree2.getComponent(Transform).rotation = Quaternion.Euler(0, -45, 0)
tree2.addComponent(new Material())
tree2.getComponent(Material).albedoColor = Color3.Brown()
engine.addEntity(tree2)"
/* animated text */,"const textEntity = new Entity()
const transform = new Transform({
  position: new Vector3(5, 2, 5)
})
textEntity.addComponent(transform)
textEntity.addComponent(new TextShape(""Hello, Decentraland!""))
engine.addEntity(textEntity)

class TextAnimationSystem implements ISystem {
  elapsed: number = 0
  speed: number = 1

  update(dt: number) {
    this.elapsed += dt * this.speed
    transform.position.y = Math.sin(this.elapsed) + 2
  }
}

engine.addSystem(new TextAnimationSystem())"
/* coloured spheres */,"const sphere1 = new Entity()
sphere1.addComponent(new SphereShape())
sphere1.addComponent(
  new Transform({
    position: new Vector3(5, 1, 5)
  })
)
sphere1.addComponent(new Material())
sphere1.getComponent(Material).albedoColor = Color3.FromHexString(""#FF0000"")
engine.addEntity(sphere1)

const sphere2 = new Entity()
sphere2.addComponent(new SphereShape())
sphere2.addComponent(
  new Transform({
    position: new Vector3(7, 1, 5)
  })
)
sphere2.addComponent(new Material())
sphere2.getComponent(Material).albedoColor = Color3.FromHexString(""#00FF00"")
engine.addEntity(sphere2)

const sphere3 = new Entity()
sphere3.addComponent(new SphereShape())
sphere3.addComponent(
  new Transform({
    position: new Vector3(5, 3, 5)
  })
)
sphere3.addComponent(new Material())
sphere3.getComponent(Material).albedoColor = Color3.FromHexString(""#0000FF"")
engine.addEntity(sphere3)"
/* interactive button */,"const button = new Entity()
button.addComponent(new BoxShape())
button.addComponent(
  new Transform({
    position: new Vector3(5, 1, 5)
  })
)
button.addComponent(new Material())
button.getComponent(Material).albedoColor = Color3.FromHexString(""#FF0000"")
button.addComponent(
  new OnClick(() => {
    log(""Button clicked!"")
    button.getComponent(Material).albedoColor = Color3.FromHexString(""#00FF00"")
  })
)
engine.addEntity(button)"
/* simple teleport */,"const teleportTrigger = new Entity()
teleportTrigger.addComponent(
  new BoxShape()
)
teleportTrigger.addComponent(
  new Transform({
    position: new Vector3(5, 1, 5)
  })
)
teleportTrigger.addComponent(
  new OnClick(() => {
    executeTask(async () => {
      const player = await getUserData()
      if (player) {
        player.position = new Vector3(10, 1, 10)
      }
    })
  })
)
engine.addEntity(teleportTrigger)"
/* rainbow */,"const rainbowColors = [Color3.Red(), Color3.Orange(), Color3.Yellow(), Color3.Green(), Color3.Blue(), Color3.Purple()];

for (let i = 0; i < rainbowColors.length; i++) {
  let color = rainbowColors[i];
  for (let j = 0; j < 10; j++) {
    const cube = new Entity();
    cube.addComponent(new Transform({ position: new Vector3(-20 + (i * 4), j, 0) }));
    cube.addComponent(new BoxShape());
    cube.addComponent(new Material());
    cube.getComponent(Material).albedoColor = color;
    engine.addEntity(cube);
  }
}"
/* bunch of balloons */,"const balloonColors = [Color3.Red(), Color3.Orange(), Color3.Yellow(), Color3.Green(), Color3.Blue(), Color3.Purple()];

for (let i = 0; i < balloonColors.length; i++) {
  let color = balloonColors[i];
  const balloon = new Entity();
  balloon.addComponent(new Transform({ position: new Vector3(-10 + (i * 3), 1.5, 0) }));
  balloon.addComponent(new SphereShape());
  balloon.addComponent(new Material());
  balloon.getComponent(Material).albedoColor = color;
  engine.addEntity(balloon);

  const ribbon = new Entity();
  ribbon.addComponent(new Transform({ position: new Vector3(-10 + (i * 3), 0.75, 0) }));
  ribbon.addComponent(new CylinderShape());
  ribbon.addComponent(new Material());
  ribbon.getComponent(Material).albedoColor = Color3.White();
  engine.addEntity(ribbon);
}"
/* chess board */,"for (let i = 0; i < 8; i++) {
  for (let j = 0; j < 8; j++) {
    const square = new Entity();
    square.addComponent(new Transform({ position: new Vector3(i, 0, j) }));
    square.addComponent(new BoxShape());
    square.addComponent(new Material());
    if ((i + j) % 2 === 0) {
      square.getComponent(Material).albedoColor = Color3.White();
    } else {
      square.getComponent(Material).albedoColor = Color3.Black();
    }
    engine.addEntity(square);
  }
}"
/* traffic light */,"const trafficLightColors = [Color3.Red(), Color3.Yellow(), Color3.Green()];

for (let i = 0; i < trafficLightColors.length; i++) {
  let color = trafficLightColors[i];
  const light = new Entity();
  light.addComponent(new Transform({ position: new Vector3(0, i * 2, 0) }));
  light.addComponent(new BoxShape());
  light.addComponent(new Material());
  light.getComponent(Material).albedoColor = color;
  engine.addEntity(light);
}"
/* simple table */ ,"const table = new Entity()
table.addComponent(new BoxShape())
table.addComponent(new Transform({
  position: new Vector3(5, 0, 5),
  scale: new Vector3(2, 0.1, 1)
}))
engine.addEntity(table)"
/* traffic cone */,"const cone = new Entity()
cone.addComponent(new ConeShape())
cone.addComponent(new Transform({
  position: new Vector3(10, 0, 10),
  scale: new Vector3(0.5, 1, 0.5)
}))
engine.addEntity(cone)"
/* television */,"const tv = new Entity()
tv.addComponent(new BoxShape())
tv.addComponent(new Transform({
  position: new Vector3(15, 1.5, 15),
  scale: new Vector3(2, 1, 0.1)
}))
engine.addEntity(tv)"
/* pencil */,"const pencil = new Entity()
const pencilTip = new BoxShape()
pencil.addComponent(new ConeShape())
pencil.addComponent(new Transform({
  position: new Vector3(20, 1, 20),
  rotation: Quaternion.Euler(0, 90, 0),
  scale: new Vector3(0.1, 1, 0.1)
}))
pencilTip.withCollisions = false
pencilTip.withClickAction = false
pencilTip.withTransform = false
pencilTip.position.set(0, 0.5, 0)
pencil.addChild(pencilTip)
engine.addEntity(pencil)"
/* chair */,"const chair = new Entity()
chair.addComponent(new BoxShape())
chair.addComponent(new Transform({
  position: new Vector3(25, 0.5, 25),
  scale: new Vector3(0.5, 1, 0.5)
}))
engine.addEntity(chair)"
/*pizza */,"const pizza = new Entity()
pizza.addComponent(new PlaneShape())
pizza.addComponent(new Material())
pizza.getComponent(Material).albedoTexture = new Texture('https://upload.wikimedia.org/wikipedia/commons/thumb/a/a3/Eq_it-na_pizza-margherita_sep2005_sml.jpg/320px-Eq_it-na_pizza-margherita_sep2005_sml.jpg')
pizza.addComponent(new Transform({
  position: new Vector3(30, 0.1, 30),
  rotation: Quaternion.Euler(-90, 0, 0),
  scale: new Vector3(1, 1, 0.01)
}))
engine.addEntity(pizza)"
/* newspaper */,"const newspaper = new Entity()
newspaper.addComponent(new PlaneShape())
newspaper.addComponent(new Material())
newspaper.getComponent(Material).albedoTexture = new Texture('https://www.publicdomainpictures.net/pictures/170000/nahled/newspaper.jpg')
newspaper.addComponent(new Transform({
  position: new Vector3(35, 0.1, 35),
  rotation: Quaternion.Euler(-90, 0, 0),
  scale: new Vector3(1, 1, 0.01)
}))
engine.addEntity(newspaper)"
/* beach ball */,"const beachBall = new Entity()
beachBall.addComponent(new SphereShape())
beachBall.addComponent(new Transform({
  position: new Vector3(40, 0.5, 40),
  scale: new Vector3(0.5, 0.5, 0.5)
}))
engine.addEntity(beachBall)"
/* candle */,"// create candle entity
const candle = new Entity()

// create candle holder
const holderShape = new ConeShape()
const holderMaterial = new Material()
holderMaterial.albedoColor = Color3.FromHexString('#8b4513ff')
holderMaterial.metallic = 0.8
holderMaterial.roughness = 0.2
const holder = new Entity()
holder.addComponent(holderShape)
holder.addComponent(holderMaterial)
holder.addComponent(new Transform({
  position: new Vector3(5, 0.5, 5),
  rotation: Quaternion.Euler(90, 0, 0)
}))
engine.addEntity(holder)

// create candle wick
const wickShape = new CylinderShape()
const wickMaterial = new Material()
wickMaterial.albedoColor = Color3.Yellow()
wickMaterial.metallic = 0.8
wickMaterial.roughness = 0.2
const wick = new Entity()
wick.addComponent(wickShape)
wick.addComponent(wickMaterial)
wick.addComponent(new Transform({
  position: new Vector3(5, 0.7, 5)
}))
wick.addComponent(new utils.Delay(1000, () => {
  wick.setParent(candle)
}))
engine.addEntity(wick)

// create candle flame
const flameShape = new SphereShape()
const flameMaterial = new Material()
flameMaterial.emissiveColor = Color3.Yellow()
const flame = new Entity()
flame.addComponent(flameShape)
flame.addComponent(flameMaterial)
flame.addComponent(new Transform({
  position: new Vector3(5, 0.9, 5)
}))
flame.addComponent(new utils.Delay(2000, () => {
  flame.setParent(candle)
}))
engine.addEntity(flame)

// add light to candle flame
const light = new PointLight()
light.intensity = 3
light.range = 3
light.color = Color3.Yellow()
light.addComponent(new utils.Delay(3000, () => {
  light.setParent(flame)
}))
flame.addComponent(light)

// add candle to holder
candle.addComponent(new Transform({
  position: new Vector3(0, 0.2, 0)
}))
holder.addChild(candle)"
/* create 3D text */,"// Creating a simple 3D text
const textEntity = new Entity()
textEntity.addComponent(new Transform({ position: new Vector3(5, 0, 5) }))
textEntity.addComponent(new TextShape('Hello, Decentraland!'))
textEntity.getComponent(TextShape).fontSize = 3
engine.addEntity(textEntity)"
/* spinning cube */,"// Creating a spinning cube with an animated material
const spinningCube = new Entity()
spinningCube.addComponent(new Transform({ position: new Vector3(8, 0, 8) }))

// Create the cube geometry
const cubeShape = new BoxShape()

// Create the material and add an animation to it
const material = new Material()
material.metallic = 1
material.roughness = 0.2
material.emissiveColor = Color3.Yellow()
material.emissiveIntensity = 0.5
material.addTexture('emissiveTexture', new Texture('https://www.decentraland.org/images/sun.png'))
material.emissiveTexture.uOffset = 0
material.emissiveTexture.vOffset = 0
material.emissiveTexture.uScale = 5
material.emissiveTexture.vScale = 5
material.emissiveTexture.wrapU = 1
material.emissiveTexture.wrapV = 1
material.emissiveTexture.coordinatesMode = 1
const animation = new AnimationState(new AnimationClip('rotation', 0, [
  new AnimationKeyframe(0, Quaternion.Euler(0, 0, 0)),
  new AnimationKeyframe(1, Quaternion.Euler(0, 360, 0))
]))
animation.looping = true
material.addTextureAnimation('emissiveTexture', animation)

// Attach the cube and material to the entity
spinningCube.addComponent(cubeShape)
spinningCube.addComponent(material)

// Add the entity to the scene and start the animation
engine.addEntity(spinningCube)
animation.play()"
/* create text label above an entity */,"// Creating a text label above an entity
const labelEntity = new Entity()
labelEntity.addComponent(new Transform({ position: new Vector3(10, 0, 10) }))

// Create the text shape component
const textShape = new TextShape()
textShape.value = 'Hello, world!'
textShape.fontSize = 3
textShape.color = Color3.White()

// Attach the text shape to the entity
labelEntity.addComponent(textShape)

// Set the position of the text above the entity
const labelTransform = new Transform({ position: new Vector3(0, 3, 0) })
labelEntity.addComponent(labelTransform)

// Add the entity to the scene
engine.addEntity(labelEntity)"
/* script for arcade game */ ,"// Import the necessary modules
import { GLTFShape, Entity, engine } from 'decentraland-ecs'

// Create a new entity for the arcade game
const arcadeGame = new Entity()

// Load a 3D model of an arcade game, such as Pac-Man or Donkey Kong
const gameShape = new GLTFShape('models/arcade-game.glb')

// Add the game shape to the arcade game entity
arcadeGame.addComponentOrReplace(gameShape)

// Set the position of the arcade game entity
arcadeGame.addComponentOrReplace(
  new Transform({
    position: new Vector3(5, 0, 5)
  })
)

// Add the arcade game entity to the scene
engine.addEntity(arcadeGame)"
/* script for petting zoo */,"// Import the necessary modules
import { GLTFShape, Entity, engine } from 'decentraland-ecs'

// Create a new entity for the petting zoo
const pettingZoo = new Entity()

// Load a 3D model of an animal, such as a puppy or kitten
const animalShape = new GLTFShape('models/animal.glb')

// Add the animal shape to the petting zoo entity
pettingZoo.addComponentOrReplace(animalShape)

// Set the position of the petting zoo entity
pettingZoo.addComponentOrReplace(
  new Transform({
    position: new Vector3(5, 0, 5)
  })
)

// Add the petting zoo entity to the scene
engine.addEntity(pettingZoo)"
/* script for police officer */,"// Import the necessary modules
import { GLTFShape, Entity, engine } from 'decentraland-ecs'

// Create a new entity for the human avatar
const humanAvatar = new Entity()

// Load a 3D model of the human avatar
const humanShape = new GLTFShape('models/human.glb')

// Add the human shape to the human avatar entity
humanAvatar.addComponentOrReplace(humanShape)

// Set the position of the human avatar entity
humanAvatar.addComponentOrReplace(
  new Transform({
    position: new Vector3(5, 0, 5)
  })
)

// Add the human avatar entity to the scene
engine.addEntity(humanAvatar)

// Create a new entity for the uniform
const uniform = new Entity()

// Load a 3D model of the uniform, such as a police officer uniform, a firefighter uniform, or a doctor uniform
const uniformShape = new GLTFShape('models/police-uniform.glb')

// Add the uniform shape to the uniform entity
uniform.addComponentOrReplace(uniformShape)

// Set the position of the uniform entity
uniform.addComponentOrReplace(
  new Transform({
    position: new Vector3(5, 0, 5)
  })
)

// Add the uniform entity as a child of the human avatar entity
humanAvatar.addChild(uniform)"
/* script for dish */,"// Import the necessary modules
import { Entity, engine, BoxShape, Color3 } from 'decentraland-ecs'

// Create a new entity for the dish
const dish = new Entity()

// Create a box shape to represent the dish
const dishShape = new BoxShape()

// Set the size and color of the dish shape to resemble a pizza
dishShape.withCollisions = false
dishShape.withoutMaterials = true
dishShape.visible = true
dishShape.width = 2
dishShape.height = 0.1
dishShape.depth = 2
dishShape.color = Color3.Red()

// Add the dish shape to the dish entity
dish.addComponentOrReplace(dishShape)

// Set the position of the dish entity
dish.addComponentOrReplace(
  new Transform({
    position: new Vector3(5, 0, 5)
  })
)

// Add the dish entity to the scene
engine.addEntity(dish)"
/* script for boxshape */,"// Import the necessary modules
import { Entity, engine, BoxShape, Color3 } from 'decentraland-ecs'

// Create a new entity for the scene
const scene = new Entity()

// Set the position of the scene entity
scene.addComponentOrReplace(
  new Transform({
    position: new Vector3(20, 0, 20)
  })
)

// Create a grid of boxes to represent a city skyline
for (let i = 0; i < 5; i++) {
  for (let j = 0; j < 5; j++) {
    // Create a new entity for each box
    const box = new Entity()

    // Create a box shape to represent the building
    const boxShape = new BoxShape()

    // Set the size and color of the box shape to resemble a building
    boxShape.withCollisions = false
    boxShape.withoutMaterials = true
    boxShape.visible = true
    boxShape.width = 1
    boxShape.height = Math.random() * 10 + 5
    boxShape.depth = 1
    boxShape.color = Color3.Gray()

    // Add the box shape to the box entity
    box.addComponentOrReplace(boxShape)

    // Set the position of the box entity
    box.addComponentOrReplace(
      new Transform({
        position: new Vector3(i * 4, boxShape.height / 2, j * 4)
      })
    )

    // Add the box entity to the scene
    scene.addChild(box)
  }
}

// Add the scene entity to the scene
engine.addEntity(scene)"
/* script for planet surface */,"// Import the necessary modules
import { Entity, engine, SphereShape, Color3, Vector3 } from 'decentraland-ecs'

// Create a new entity for the scene
const scene = new Entity()

// Set the position of the scene entity
scene.addComponentOrReplace(
  new Transform({
    position: new Vector3(20, 0, 20)
  })
)

// Create a grid of spheres to represent a planet surface
for (let i = 0; i < 10; i++) {
  for (let j = 0; j < 10; j++) {
    // Create a new entity for each sphere
    const sphere = new Entity()

    // Create a sphere shape to represent the terrain
    const sphereShape = new SphereShape()

    // Set the size and color of the sphere shape to resemble terrain
    sphereShape.withCollisions = false
    sphereShape.withoutMaterials = true
    sphereShape.visible = true
    sphereShape.radius = Math.random() * 2 + 1
    sphereShape.color = new Color3(
      Math.random(),
      Math.random(),
      Math.random()
    )

    // Add the sphere shape to the sphere entity
    sphere.addComponentOrReplace(sphereShape)

    // Set the position of the sphere entity
    sphere.addComponentOrReplace(
      new Transform({
        position: new Vector3(
          i * 3 - 15 + Math.random() * 2,
          Math.random() * 2,
          j * 3 - 15 + Math.random() * 2
        )
      })
    )

    // Add the sphere entity to the scene
    scene.addChild(sphere)
  }
}

// Add the scene entity to the scene
engine.addEntity(scene)"
/* script for city skyline */,"// Import the necessary modules
import { Entity, engine, BoxShape, Color3, Vector3 } from 'decentraland-ecs'

// Create a new entity for the scene
const scene = new Entity()

// Set the position of the scene entity
scene.addComponentOrReplace(
  new Transform({
    position: new Vector3(10, 0, 10)
  })
)

// Create a grid of cubes to represent a city skyline
for (let i = 0; i < 10; i++) {
  // Create a new entity for each cube row
  const row = new Entity()

  // Set the position of the cube row entity
  row.addComponentOrReplace(
    new Transform({
      position: new Vector3(0, i * 3, 0)
    })
  )

  // Create a row of cubes to represent a city skyline
  for (let j = 0; j < 10; j++) {
    // Create a new entity for each cube
    const cube = new Entity()

    // Create a cube shape to represent a building
    const cubeShape = new BoxShape()

    // Set the size and color of the cube shape to resemble a building
    cubeShape.withCollisions = false
    cubeShape.withoutMaterials = true
    cubeShape.visible = true
    cubeShape.width = Math.random() * 2 + 1
    cubeShape.height = Math.random() * 4 + 4
    cubeShape.depth = Math.random() * 2 + 1
    cubeShape.color = new Color3(
      Math.random(),
      Math.random(),
      Math.random()
    )

    // Add the cube shape to the cube entity
    cube.addComponentOrReplace(cubeShape)

    // Set the position of the cube entity
    cube.addComponentOrReplace(
      new Transform({
        position: new Vector3(
          j * 3 - 15 + Math.random() * 2,
          0,
          0
        )
      })
    )

    // Add the cube entity to the cube row entity
    row.addChild(cube)
  }

  // Add the cube row entity to the scene entity
  scene.addChild(row)
}

// Add the scene entity to the scene
engine.addEntity(scene)"
/* script for mountains */,"// Import the necessary modules
import { Entity, engine, SphereShape, Color3, Vector3 } from 'decentraland-ecs'

// Create a new entity for the scene
const scene = new Entity()

// Set the position of the scene entity
scene.addComponentOrReplace(
  new Transform({
    position: new Vector3(5, 1, 5)
  })
)

// Create a grid of spheres to represent a planet surface
for (let i = 0; i < 10; i++) {
  // Create a new entity for each sphere row
  const row = new Entity()

  // Set the position of the sphere row entity
  row.addComponentOrReplace(
    new Transform({
      position: new Vector3(0, 0, i * 3)
    })
  )

  // Create a row of spheres to represent a planet surface
  for (let j = 0; j < 10; j++) {
    // Create a new entity for each sphere
    const sphere = new Entity()

    // Create a sphere shape to represent a mountain
    const sphereShape = new SphereShape()

    // Set the radius and color of the sphere shape to resemble a mountain
    sphereShape.withCollisions = false
    sphereShape.withoutMaterials = true
    sphereShape.visible = true
    sphereShape.radius = Math.random() * 1.5 + 0.5
    sphereShape.color = new Color3(
      0.5 + Math.random() * 0.5,
      0.5 + Math.random() * 0.5,
      0.5 + Math.random() * 0.5
    )

    // Add the sphere shape to the sphere entity
    sphere.addComponentOrReplace(sphereShape)

    // Set the position of the sphere entity
    sphere.addComponentOrReplace(
      new Transform({
        position: new Vector3(
          j * 3 - 15 + Math.random() * 2,
          Math.random() * 2,
          0
        )
      })
    )

    // Add the sphere entity to the sphere row entity
    row.addChild(sphere)
  }

  // Add the sphere row entity to the scene entity
  scene.addChild(row)
}

// Add the scene entity to the scene
engine.addEntity(scene)"
/* script for castle blocks */,"// Import the necessary modules
import { Entity, engine, BoxShape, Color3, Vector3 } from 'decentraland-ecs'

// Create a new entity for the scene
const scene = new Entity()

// Set the position of the scene entity
scene.addComponentOrReplace(
  new Transform({
    position: new Vector3(5, 1, 5)
  })
)

// Create a wall of boxes to represent a castle
for (let i = 0; i < 10; i++) {
  // Create a new entity for each box row
  const row = new Entity()

  // Set the position of the box row entity
  row.addComponentOrReplace(
    new Transform({
      position: new Vector3(0, i * 2, 0)
    })
  )

  // Create a row of boxes to represent a castle wall
  for (let j = 0; j < 10; j++) {
    // Create a new entity for each box
    const box = new Entity()

    // Create a box shape to represent a castle block
    const boxShape = new BoxShape()

    // Set the size and color of the box shape to resemble a castle block
    boxShape.withCollisions = false
    boxShape.withoutMaterials = true
    boxShape.visible = true
    boxShape.size = new Vector3(1, 2, 0.2)
    boxShape.color = new Color3(0.8, 0.5, 0.2)

    // Add the box shape to the box entity
    box.addComponentOrReplace(boxShape)

    // Set the position of the box entity
    box.addComponentOrReplace(
      new Transform({
        position: new Vector3(
          j * 2 - 10 + Math.random() * 0.5,
          Math.random() * 0.5,
          0
        )
      })
    )

    // Add the box entity to the box row entity
    row.addChild(box)
  }

  // Add the box row entity to the scene entity
  scene.addChild(row)
}

// Create a gate for the castle
const gate = new Entity()

// Create a box shape to represent the castle gate
const gateShape = new BoxShape()

// Set the size and color of the box shape to resemble a castle gate
gateShape.withCollisions = false
gateShape.withoutMaterials = true
gateShape.visible = true
gateShape.size = new Vector3(2, 4, 0.2)
gateShape.color = new Color3(0.8, 0.5, 0.2)

// Add the box shape to the gate entity
gate.addComponentOrReplace(gateShape)

// Set the position of the gate entity
gate.addComponentOrReplace(
  new Transform({
    position: new Vector3(0, 10, -1)
  })
)

// Add the gate entity to the scene entity
scene.addChild(gate)

// Add the scene entity to the scene
engine.addEntity(scene)"
/* script for table with plates and ustensils */,"// Import the necessary modules
import { Entity, engine, BoxShape, Color3, Vector3, Material, StandardMaterial } from 'decentraland-ecs'

// Create a new entity for the scene
const scene = new Entity()

// Set the position of the scene entity
scene.addComponentOrReplace(
  new Transform({
    position: new Vector3(5, 1, 5)
  })
)

// Create a table with plates and utensils using box shapes
const table = new Entity()

// Set the position of the table entity
table.addComponentOrReplace(
  new Transform({
    position: new Vector3(0, 0, 0)
  })
)

// Create a table top
const tableTop = new Entity()

// Create a box shape to represent the table top
const tableTopShape = new BoxShape()

// Set the size and color of the box shape to resemble a table top
tableTopShape.withCollisions = false
tableTopShape.withoutMaterials = false
tableTopShape.visible = true
tableTopShape.size = new Vector3(6, 0.2, 3)
tableTopShape.material = new Material()

// Set the texture of the table top to a wood texture
tableTopShape.material.albedoTexture = new Texture('https://decentraland.org/images/textures/wood.png')

// Add the box shape to the table top entity
tableTop.addComponentOrReplace(tableTopShape)

// Set the position of the table top entity
tableTop.addComponentOrReplace(
  new Transform({
    position: new Vector3(0, 0.1, 0)
  })
)

// Add the table top entity to the table entity
table.addChild(tableTop)

// Create plates and utensils on the table
for (let i = 0; i < 4; i++) {
  // Create a new entity for each plate and utensil
  const entity = new Entity()

  // Create a box shape to represent the plate or utensil
  const boxShape = new BoxShape()

  // Set the size and color of the box shape to resemble a plate or utensil
  boxShape.withCollisions = false
  boxShape.withoutMaterials = false
  boxShape.visible = true
  boxShape.size = new Vector3(0.5, 0.05, 0.5)
  boxShape.material = new StandardMaterial()

  // Set the texture of the plate or utensil to a solid color
  boxShape.material.albedoColor = new Color3(Math.random(), Math.random(), Math.random())

  // Add the box shape to the entity
  entity.addComponentOrReplace(boxShape)

  // Set the position of the entity
  entity.addComponentOrReplace(
    new Transform({
      position: new Vector3(
        -1.5 + i * 1.2 + Math.random() * 0.2,
        0.25,
        0.75 + Math.random() * 0.2
      ),
      rotation: Quaternion.Euler(0, Math.random() * 360, 0)
    })
  )

  // Add the entity to the table entity
  table.addChild(entity)
}

// Add the table entity to the scene entity
scene.addChild(table)

// Add the scene entity to the engine to display the scene in Decentraland
engine.addEntity(scene)"
/* script for a maze with walls and soccer ball */,"// Import the necessary modules
import { Entity, engine, BoxShape, Color3, Vector3, Material, StandardMaterial, Quaternion } from 'decentraland-ecs'

// Create a new entity for the scene
const scene = new Entity()

// Set the position of the scene entity
scene.addComponentOrReplace(
  new Transform({
    position: new Vector3(5, 1, 5)
  })
)

// Create a maze using BoxShapes
const maze = new Entity()

// Set the position of the maze entity
maze.addComponentOrReplace(
  new Transform({
    position: new Vector3(0, 0, 0)
  })
)

// Create walls using BoxShapes
for (let i = -5; i <= 5; i++) {
  for (let j = -5; j <= 5; j++) {
    if (i === -5 || i === 5 || j === -5 || j === 5) {
      const wall = new Entity()

      // Create a box shape to represent the wall
      const wallShape = new BoxShape()

      // Set the size and color of the box shape to resemble a wall
      wallShape.withCollisions = true
      wallShape.withoutMaterials = false
      wallShape.visible = true
      wallShape.size = new Vector3(1, 1, 1)
      wallShape.material = new StandardMaterial()

      // Set the texture of the wall to a brick texture
      wallShape.material.albedoTexture = new Texture('https://decentraland.org/images/textures/brick_wall.png')

      // Add the box shape to the wall entity
      wall.addComponentOrReplace(wallShape)

      // Set the position of the wall entity
      wall.addComponentOrReplace(
        new Transform({
          position: new Vector3(i, 0.5, j)
        })
      )

      // Add the wall entity to the maze entity
      maze.addChild(wall)
    }
  }
}

// Add the maze entity to the scene entity
scene.addChild(maze)

// Create a ball using a BoxShape
const ball = new Entity()

// Create a box shape to represent the ball
const ballShape = new BoxShape()

// Set the size and color of the box shape to resemble a ball
ballShape.withCollisions = true
ballShape.withoutMaterials = false
ballShape.visible = true
ballShape.size = new Vector3(0.5, 0.5, 0.5)
ballShape.material = new StandardMaterial()

// Set the texture of the ball to a soccer ball texture
ballShape.material.albedoTexture = new Texture('https://decentraland.org/images/textures/soccer_ball.png')

// Add the box shape to the ball entity
ball.addComponentOrReplace(ballShape)

// Set the position of the ball entity
ball.addComponentOrReplace(
  new Transform({
    position: new Vector3(-5, 0.5, -5),
    rotation: Quaternion.Euler(45, 45, 0)
  })
)

// Add the ball entity to the scene entity
scene.addChild(ball)

// Add the scene entity to the engine to display the scene in Decentraland
engine.addEntity(scene)"
/* script for house with walls roof and door */,"// Import the necessary modules
import { Entity, engine, BoxShape, Color3, Vector3, Material, StandardMaterial } from 'decentraland-ecs'

// Create a new entity for the scene
const scene = new Entity()

// Set the position of the scene entity
scene.addComponentOrReplace(
  new Transform({
    position: new Vector3(5, 1, 5)
  })
)

// Create a house using BoxShapes
const house = new Entity()

// Set the position of the house entity
house.addComponentOrReplace(
  new Transform({
    position: new Vector3(0, 0, 0)
  })
)

// Create walls using BoxShapes
const wallHeight = 4
const wallThickness = 0.2
const wallColor = Color3.FromHexString('#FFFFFF')
const doorWidth = 1
const doorHeight = 2

// Front wall
const frontWall = new BoxShape()
frontWall.withCollisions = true
frontWall.withoutMaterials = false
frontWall.visible = true
frontWall.size = new Vector3(6, wallHeight, wallThickness)
frontWall.material = new StandardMaterial()
frontWall.material.albedoColor = wallColor

const frontWallEntity = new Entity()
frontWallEntity.addComponentOrReplace(frontWall)
frontWallEntity.addComponentOrReplace(
  new Transform({
    position: new Vector3(0, wallHeight / 2, -3)
  })
)
house.addChild(frontWallEntity)

// Side walls
const sideWall = new BoxShape()
sideWall.withCollisions = true
sideWall.withoutMaterials = false
sideWall.visible = true
sideWall.size = new Vector3(wallThickness, wallHeight, 4)
sideWall.material = new StandardMaterial()
sideWall.material.albedoColor = wallColor

const leftWallEntity = new Entity()
leftWallEntity.addComponentOrReplace(sideWall)
leftWallEntity.addComponentOrReplace(
  new Transform({
    position: new Vector3(-3, wallHeight / 2, 0)
  })
)
house.addChild(leftWallEntity)

const rightWallEntity = new Entity()
rightWallEntity.addComponentOrReplace(sideWall)
rightWallEntity.addComponentOrReplace(
  new Transform({
    position: new Vector3(3, wallHeight / 2, 0)
  })
)
house.addChild(rightWallEntity)

// Back wall
const backWall = new BoxShape()
backWall.withCollisions = true
backWall.withoutMaterials = false
backWall.visible = true
backWall.size = new Vector3(6, wallHeight, wallThickness)
backWall.material = new StandardMaterial()
backWall.material.albedoColor = wallColor

const backWallEntity = new Entity()
backWallEntity.addComponentOrReplace(backWall)
backWallEntity.addComponentOrReplace(
  new Transform({
    position: new Vector3(0, wallHeight / 2, 3)
  })
)
house.addChild(backWallEntity)

// Roof
const roof = new BoxShape()
roof.withCollisions = true
roof.withoutMaterials = false
roof.visible = true
roof.size = new Vector3(6, wallThickness, 6)
roof.material = new StandardMaterial()
roof.material.albedoColor = Color3.Black()

const roofEntity = new Entity()
roofEntity.addComponentOrReplace(roof)
roofEntity.addComponentOrReplace(
  new Transform({
    position: new Vector3(0, wallHeight, 0)
  })
)
house.addChild(roofEntity)

// Door
const door = new BoxShape()
door.withCollisions = true
door.withoutMaterials = false
// Create the door material
const doorMaterial = new Material()
doorMaterial.albedoColor = Color3.FromHexString('#523A00')
doorMaterial.metallic = 0.2
doorMaterial.roughness = 0.8

const doorEntity = new Entity()
doorEntity.addComponentOrReplace(door)
doorEntity.addComponentOrReplace(
new Transform({
position: new Vector3(0, doorHeight / 2, -3.01),
scale: new Vector3(doorWidth, doorHeight, wallThickness)
})
)
doorEntity.addComponentOrReplace(doorMaterial)

house.addChild(doorEntity)

// Add the house entity to the scene entity
scene.addChild(house)

// Add the scene entity to the engine
engine.addEntity(scene)

"
/* script for player */,"// Create the player entity
const playerEntity = new Entity()
playerEntity.addComponentOrReplace(new GLTFShape('models/player.glb'))
playerEntity.addComponentOrReplace(new Transform({ position: new Vector3(5, 0, 5) }))
playerEntity.addComponentOrReplace(new Animator())
engine.addEntity(playerEntity)"
/* script for coin */,"// Create the coin entity
const coinEntity = new Entity()
coinEntity.addComponentOrReplace(new GLTFShape('models/coin.glb'))
coinEntity.addComponentOrReplace(new Transform({ position: new Vector3(10, 0, 10) }))
engine.addEntity(coinEntity)"
/* script for camera */,"// Create the camera entity
const cameraEntity = new Entity()
cameraEntity.addComponentOrReplace(new Camera())
cameraEntity.addComponentOrReplace(new Transform({ position: new Vector3(5, 2, 5) }))
engine.addEntity(cameraEntity)"
/* script to listen for keyboard input */,"// Listen for keyboard input
let moveDirection = Vector3.Zero()
Input.instance.subscribe('BUTTON_DOWN', ActionButton.PRIMARY, false, (e) => {
  if (e.hit.length > 0) {
    const hitEntity = e.hit[0].entity
    if (hitEntity === coinEntity) {
      engine.removeEntity(coinEntity)
    } else {
      moveDirection.copyFrom(e.hit[0].face.getNormal())
      moveDirection.y = 0
    }
  }
})
Input.instance.subscribe('BUTTON_UP', ActionButton.PRIMARY, false, () => {
  moveDirection.copyFrom(Vector3.Zero())
})"
/* script to move player and camera entities based on keyboard input */,"// Move the player and camera entities based on keyboard input
const playerSpeed = 2
const cameraOffset = new Vector3(0, 1, 0)
const cameraFollowSpeed = 0.1
const playerAnimator = playerEntity.getComponent(Animator)

engine.addSystem(new OnBeforeRender(() => {
  const deltaTime = engine.getDeltaTime()

  playerEntity.getComponent(Transform).translate(moveDirection.scale(playerSpeed * deltaTime))

  const cameraTargetPosition = playerEntity.getComponent(Transform).position.add(cameraOffset)
  const cameraCurrentPosition = cameraEntity.getComponent(Transform).position
  cameraEntity.getComponent(Transform).position = Vector3.Lerp(cameraCurrentPosition, cameraTargetPosition, cameraFollowSpeed * deltaTime)

  if (moveDirection.lengthSquared() > 0) {
    playerAnimator.getClip('Walk').play()
    playerAnimator.getClip('Idle').stop()
    playerAnimator.getClip('Run').stop()
    playerAnimator.getClip('Jump').stop()
    playerAnimator.getClip('Die').stop()
  } else {
    playerAnimator.getClip('Idle').play()
    playerAnimator.getClip('Walk').stop()
    playerAnimator.getClip('Run').stop()
    playerAnimator.getClip('Jump').stop()
    playerAnimator.getClip('Die').stop()
  }
}))"
/* script to teleport to random location */,"import random
from dcl import teleport_local_player

def on_teleporter_used(evt):
    x = random.uniform(-10, 10)
    y = random.uniform(0, 10)
    z = random.uniform(-10, 10)
    teleport_local_player(x, y, z)

scene.create_entity(
    entity_type=""nftShape"",
    position=(0, 0, 0),
    rotation=(0, 0, 0, 1),
    nft={""assetId"": ""urn:decentraland:matic:collections-v2:0x60f80121c31a0d46b5279700f9df786054aa5ee5:10""},
    on_use=on_teleporter_used,
)"
/* script that creates a platform moving back and forth between two positions */,"import math
from dcl import move_entity

def on_update(dt):
    t = math.sin(scene.time / 1000)
    x = math.lerp(-5, 5, (t + 1) / 2)
    y = 2
    z = math.lerp(0, -10, (t + 1) / 2)
    move_entity(entity_id, position=(x, y, z))

entity_id = scene.create_entity(
    entity_type=""box"",
    position=(-5, 2, 0),
    scale=(2, 0.1, 2),
    color=(0, 1, 0),
)

scene.register_update_callback(on_update)
This script creates a green platform (a box) that moves back and forth between two positions. The on_update() function is called every frame, and calculates the platform's new position based on the current time using the math.sin() and math.lerp() functions. The move_entity() function is used to update the platform's position.

Falling objects
This script creates a spawner that generates falling objects that disappear when they hit the ground.

python
Copy code
import random
from dcl import move_entity, remove_entity

def on_update(dt):
    if scene.time - last_spawn_time > spawn_interval:
        spawn_object()
        last_spawn_time = scene.time

def spawn_object():
    x = random.uniform(-5, 5)
    y = 10
    z = random.uniform(-5, 5)
    entity_id = scene.create_entity(
        entity_type=""sphere"",
        position=(x, y, z),
        scale=(0.2, 0.2, 0.2),
        color=(1, 0, 0),
    )
    objects.append(entity_id)

def on_collision(evt):
    if evt[""type""] == ""entity"" and evt[""entityId""] in objects:
        remove_entity(evt[""entityId""])
        objects.remove(evt[""entityId""])

objects = []
spawn_interval = 1000
last_spawn_time = scene.time

scene.register_update_callback(on_update)
scene.register_component_callback(""collision"", on_collision)
This script creates a spawner that generates red spheres that fall from the sky. The `on_update


"
/* script that generates falling objects that disappear when they hit the ground */,"import random
from dcl import move_entity, remove_entity

def on_update(dt):
    if scene.time - last_spawn_time > spawn_interval:
        spawn_object()
        last_spawn_time = scene.time

def spawn_object():
    x = random.uniform(-5, 5)
    y = 10
    z = random.uniform(-5, 5)
    entity_id = scene.create_entity(
        entity_type=""sphere"",
        position=(x, y, z),
        scale=(0.2, 0.2, 0.2),
        color=(1, 0, 0),
    )
    objects.append(entity_id)

def on_collision(evt):
    if evt[""type""] == ""entity"" and evt[""entityId""] in objects:
        remove_entity(evt[""entityId""])
        objects.remove(evt[""entityId""])

objects = []
spawn_interval = 1000
last_spawn_time = scene.time

scene.register_update_callback(on_update)
scene.register_component_callback(""collision"", on_collision)"
/* script for a box and a sphere with click events to each entity which modifies their position or scale when clicked */,"import { Entity, engine, Transform, Vector3, OnClick } from 'decentraland-ecs/src'

// Create a box entity
const box = new Entity()
box.addComponent(new Transform({ position: new Vector3(5, 1, 5) }))
box.addComponent(new BoxShape())
engine.addEntity(box)

// Create a sphere entity
const sphere = new Entity()
sphere.addComponent(new Transform({ position: new Vector3(5, 2, 5) }))
sphere.addComponent(new SphereShape())
engine.addEntity(sphere)

// Add click event to the box entity
box.addComponent(
  new OnClick(() => {
    box.getComponent(Transform).scale.y += 0.1
  })
)

// Add click event to the sphere entity
sphere.addComponent(
  new OnClick(() => {
    sphere.getComponent(Transform).position.y += 0.1
  })
)"
/* script to display a timer */,"import { Entity, engine, Transform, TextShape } from 'decentraland-ecs/src'

// Create a timer entity
const timer = new Entity()
timer.addComponent(new Transform({ position: new Vector3(5, 1, 5) }))
const textShape = new TextShape('0')
timer.addComponent(textShape)
engine.addEntity(timer)

// Set initial time and update timer every second
let time = 0
setInterval(() => {
  time += 1
  textShape.value = time.toString()
}, 1000)"
"/* script for a box shape that acts like a button, when clicked it logs a message to the console */","import { Entity, engine, Transform, BoxShape, OnClick } from 'decentraland-ecs/src'

// Create a button entity
const button = new Entity()
button.addComponent(new Transform({ position: new Vector3(5, 1, 5) }))
button.addComponent(new BoxShape())
engine.addEntity(button)

// Add click event to the button entity
button.addComponent(
  new OnClick(() => {
    log('Button clicked')
  })
)"
/* script for custom particle system */ ,"import {
  Entity,
  engine,
  Transform,
  SphereShape,
  Material,
  Color3,
  ParticleSystem,
  Texture
} from 'decentraland-ecs/src'

// Create a particle system entity
const particleEntity = new Entity()
particleEntity.addComponent(new Transform({ position: new Vector3(5, 1, 5) }))
particleEntity.addComponent(new SphereShape())

// Create a custom particle system
const particleSystem = new ParticleSystem()
particleSystem.birthRate = 5
particleSystem.maxParticles = 100
particleSystem.color1 = Color3.Yellow()
particleSystem.color2 = Color3.Red()
particleSystem.sizeRange = 0.1
particleSystem.velocityRange = new Vector3(1, 1, 1)
particleSystem.acceleration = new Vector3(0, -1, 0)
particleSystem.texture = new Texture('https://i.imgur.com/ErAdYKg.png')
particleSystem.playing = true
particleEntity.addComponent(particleSystem)

engine.addEntity(particleEntity)"
/* script for creating a dynamic skybox */,"import {
  Entity,
  engine,
  Transform,
  SphereShape,
  Material,
  Color3
} from 'decentraland-ecs/src'

const skybox = new Entity()
skybox.addComponent(new Transform({
  position: new Vector3(0, 0, 0),
  scale: new Vector3(1000, 1000, 1000)
}))

const skyMaterial = new Material()
skyMaterial.albedoColor = Color3.FromHexString('#5B9BD5')
skybox.addComponent(skyMaterial)

engine.addEntity(skybox)

engine.onBeforeRenderObservable.add(() => {
  const time = (Date.now() % 86400000) / 86400000 // Get the current time as a percentage of a day
  const skyColor = Color3.Lerp(
    Color3.FromHexString('#5B9BD5'),
    Color3.FromHexString('#F2C76F'),
    time
  )
  skyMaterial.albedoColor = skyColor
})"
/* script to create an animated ocean */,"import {
  Entity,
  engine,
  Transform,
  PlaneShape,
  Material,
  Color3,
  Vector2,
  Vector3
} from 'decentraland-ecs/src'

const ocean = new Entity()
ocean.addComponent(new Transform({
  position: new Vector3(0, 0, 0),
  scale: new Vector3(100, 1, 100)
}))

const oceanShape = new PlaneShape()
oceanShape.uvs = [  new Vector2(0, 0),  new Vector2(10, 0),  new Vector2(0, 10),  new Vector2(10, 10)]

const oceanMaterial = new Material()
oceanMaterial.albedoTexture = new Texture('textures/ocean.png', {
  hasAlpha: false,
  isReadable: true
})
oceanMaterial.albedoColor = Color3.FromHexString('#2A2D34')
ocean.addComponent(oceanShape)
ocean.addComponent(oceanMaterial)

engine.addEntity(ocean)

engine.onBeforeRenderObservable.add(() => {
  const time = Date.now() / 2000
  oceanShape.uvs[0].x = time
  oceanShape.uvs[1].x = time + 10
  oceanShape.uvs[2].y = time
  oceanShape.uvs[3].y = time + 10
})"
/* script to create a building */,"// Create an entity for a 3D model of a building
const building = new Entity()
building.addComponent(new GLTFShape('models/building.glb'))
building.addComponent(new Transform({
  position: new Vector3(0, 0, 3)
}))
engine.addEntity(building)"
/* script to create a car */ ,"// Create an entity for a 3D model of a car
const car = new Entity()
car.addComponent(new GLTFShape('models/car.glb'))
car.addComponent(new Transform({
  position: new Vector3(3, 0, 0)
}))
engine.addEntity(car)"
/* script for day and night cycle */,"import {
  Scene,
  Sky,
  engine,
  Vector3
} from 'decentraland-ecs/src'

// Create a new scene
const myScene = new Scene()
engine.addScene(myScene)

// Create a sky entity
const sky = new Sky()
myScene.setSkybox(sky)

// Define the colors for the day and night sky
const dayColor = new Vector3(0.5, 0.5, 1)
const nightColor = new Vector3(0.1, 0.1, 0.5)

// Set the initial time of day to noon
let timeOfDay = 0.5

// Define a function to update the sky color based on the time of day
function updateSkyColor() {
  const t = Math.sin(timeOfDay * Math.PI)
  sky.setGradientColor(dayColor.lerp(nightColor, t), nightColor.lerp(dayColor, t))
}

// Define a function to update the time of day
function updateTimeOfDay(dt: number) {
  timeOfDay = (timeOfDay + dt / 600) % 1
}

// Register an update function to run every frame
engine.addSystem(new class {
  update(dt: number) {
    updateTimeOfDay(dt)
    updateSkyColor()
  }
})"
/* script to create random 3D terrain generation with perlin noise */ ,"import { Vector3, log } from 'decentraland-ecs/src'

// Define the terrain dimensions and vertex count
const terrainSize = 10
const vertexCount = 100

// Define the frequency and amplitude of the Perlin noise
const noiseFrequency = 0.1
const noiseAmplitude = 3

// Define the minimum and maximum height of the terrain
const minHeight = 0
const maxHeight = 10

// Define the terrain vertices array
const terrainVertices = new Array<Vector3>()

// Generate the terrain vertices
for (let x = 0; x <= vertexCount; x++) {
  for (let y = 0; y <= vertexCount; y++) {
    // Calculate the noise value based on the current vertex position
    const noiseValue = noise.perlin3(x * noiseFrequency, y * noiseFrequency, 0)
    
    // Calculate the vertex height based on the noise value and amplitude
    const vertexHeight = noiseValue * noiseAmplitude
    
    // Add the vertex to the terrain vertices array
    terrainVertices.push(new Vector3(
      x / vertexCount * terrainSize,
      y / vertexCount * terrainSize,
      vertexHeight
    ))
  }
}

// Define the terrain indices array
const terrainIndices = new Array<number>()

// Generate the terrain indices
for (let x = 0; x < vertexCount; x++) {
  for (let y = 0; y < vertexCount; y++) {
    const topLeft = x * (vertexCount + 1) + y
    const topRight = topLeft + 1
    const bottomLeft = (x + 1) * (vertexCount + 1) + y
    const bottomRight = bottomLeft + 1
    
    terrainIndices.push(topLeft, bottomLeft, topRight)
    terrainIndices.push(topRight, bottomLeft, bottomRight)
  }
}

// Create the terrain entity and add the mesh component
const terrain = new Entity()
terrain.addComponent(new Transform())
terrain.addComponent(new Mesh())
terrain.getComponent(Mesh).vertices = terrainVertices
terrain.getComponent(Mesh).indices = terrainIndices
terrain.getComponent(Mesh).normals = Mesh.calculateNormals(terrainVertices, terrainIndices)
terrain.getComponent(Mesh).material = new Material()
terrain.getComponent(Mesh).material.albedoColor = Color3.Green()

// Add the terrain entity to the engine
engine.addEntity(terrain)"
/* script for interactive NPC dialogue */,"// Define the NPC's initial dialogue state
let npcState = {
  dialogueIndex: 0,
  options: [
    {
      text: 'Hello! How can I help you?',
      nextIndex: 1
    },
    {
      text: 'Sorry, I am busy right now.',
      nextIndex: -1
    }
  ]
}

// Define the function to update the NPC's dialogue state based on user input
function handleUserInput(optionIndex) {
  let currentOption = npcState.options[npcState.dialogueIndex]
  if (optionIndex === -1) {
    // Player chose to end the dialogue
    npcState.dialogueIndex = -1
    return
  } else if (optionIndex >= 0 && optionIndex < currentOption.nextIndex.length) {
    // Player chose a valid option
    npcState.dialogueIndex = currentOption.nextIndex[optionIndex]
  } else {
    // Player chose an invalid option
    console.error('Invalid option chosen!')
  }
}

// Define the function to display the NPC's dialogue options
function displayDialogueOptions() {
  let currentOption = npcState.options[npcState.dialogueIndex]
  if (currentOption.nextIndex === -1) {
    // End dialogue
    console.log('Goodbye!')
    return
  }
  console.log(currentOption.text)
  for (let i = 0; i < currentOption.options.length; i++) {
    console.log(`${i+1}. ${currentOption.options[i].text}`)
  }
}

// Example usage:
displayDialogueOptions() // Outputs: ""Hello! How can I help you?""
handleUserInput(0) // Player chooses first option
displayDialogueOptions() // Outputs: ""What can I help you with today?""
handleUserInput(1) // Player chooses second option
displayDialogueOptions() // Outputs: ""Goodbye!""
handleUserInput(-1) // End dialogue"
/* script for multiplayer game */,"import * as dcl from 'decentraland-ecs'

// Create a basic scene with a ground plane and a cube
const scene = new dcl.Scene()

const ground = new dcl.Entity()
ground.addComponent(new dcl.BoxShape())
ground.addComponent(new dcl.Transform({ scale: new dcl.Vector3(10, 0.1, 10) }))
scene.addEntity(ground)

const cube = new dcl.Entity()
cube.addComponent(new dcl.BoxShape())
cube.addComponent(new dcl.Transform({ position: new dcl.Vector3(0, 1, 0) }))
scene.addEntity(cube)

// Create a multiplayer controller
class MultiplayerController {
  players: { [id: string]: dcl.Entity } = {}

  addPlayer(id: string, position: dcl.Vector3) {
    const player = new dcl.Entity()
    player.addComponent(new dcl.BoxShape())
    player.addComponent(new dcl.Transform({ position }))
    this.players[id] = player
    scene.addEntity(player)
  }

  removePlayer(id: string) {
    scene.removeEntity(this.players[id])
    delete this.players[id]
  }

  updatePlayerPosition(id: string, position: dcl.Vector3) {
    const player = this.players[id]
    if (player) {
      player.getComponent(dcl.Transform).position = position
    }
  }
}

// Initialize the multiplayer controller
const multiplayer = new MultiplayerController()

// Listen for connections from new players
dcl.onPeerConnect(peer => {
  multiplayer.addPlayer(peer.id, new dcl.Vector3(0, 1, 0))
})

// Listen for disconnections from players
dcl.onPeerDisconnect(peer => {
  multiplayer.removePlayer(peer.id)
})

// Listen for updates to player positions
dcl.onUpdate((delta: number) => {
  for (const id in multiplayer.players) {
    multiplayer.updatePlayerPosition(id, new dcl.Vector3(Math.random(), 1, Math.random()))
  }
})"
/* script for animated character */,"const character = new Entity()
const gltfShape = new GLTFShape('character.glb')
const animationState = new AnimationState('idle')
const animationStateComponent = new AnimationStateComponent()
animationStateComponent.addState(animationState)
character.addComponent(gltfShape)
character.addComponent(animationStateComponent)
engine.addEntity(character)

animationState.play()"
/* script for dynamic text */,"const dynamicText = new TextShape('Dynamic Text')
dynamicText.fontSize = 3
dynamicText.color = Color3.Red()
dynamicText.position.set(2, 1, 2)
engine.addEntity(dynamicText)

let count = 0
setInterval(() => {
  dynamicText.value = `Dynamic Text: ${count++}`
}, 1000)"
/* script for interactive painting */,"const painting = new Plane()
painting.width = 2
painting.height = 1.5
painting.uvs = [0, 1, 1, 1, 0, 0, 1, 0]
painting.position.set(4, 1, 4)
painting.material = new BasicMaterial()
painting.material.texture = new Texture('painting1.png')
painting.onClick = (e) => {
  if (painting.material.texture.url.includes('painting1.png')) {
    painting.material.texture = new Texture('painting2.png')
  } else {
    painting.material.texture = new Texture('painting1.png')
  }
}
engine.addEntity(painting)"
/* script for interactive object : change color when clicked */ ,"const button = new Entity()
button.addComponent(new BoxShape())
button.addComponent(new Transform({
  position: new Vector3(5, 0, 5)
}))
const material = new Material()
material.albedoColor = Color3.FromHexString('#FF0000')
button.addComponent(material)
button.addComponent(
  new OnClick(() => {
    material.albedoColor = Color3.FromHexString('#00FF00')
  })
)
engine.addEntity(button)"
/* script of walking character */,"import { Animation } from 'decentraland-ecs/src/decentraland/Animation'

const myEntity = new Entity()
myEntity.addComponent(new GLTFShape('models/MyModel.gltf'))

const animation = new Animation('walk')
animation.addClip(new AnimationClip('walk', {
  loop: true,
  speed: 1.0,
  tracks: [
    new VectorKeyframeTrack('.position', [0, 1, 2], [
      new Vector3(0, 0, 0),
      new Vector3(1, 0, 0),
      new Vector3(2, 0, 0),
    ]),
    new QuaternionKeyframeTrack('.quaternion', [0, 1, 2], [
      new Quaternion(),
      Quaternion.Euler(0, 90, 0),
      Quaternion.Euler(0, 180, 0),
    ]),
  ]
}))
myEntity.addComponent(animation)
engine.addEntity(myEntity)"
/* script for simple terrain mesh */,"const numVertices = 100
const numFaces = numVertices - 2
const vertexPositions = new Array<Vector3>(numVertices)

for (let i = 0; i < numVertices; i++) {
  const x = i / (numVertices - 1)
  const y = Math.random()
  const z = noise.perlin3(x, y, 0)
  vertexPositions[i] = new Vector3(x, y, z)
}

const indices = new Array<number>(numFaces * 3)
for (let i = 0; i < numFaces; i++) {
  indices[i * 3 + 0] = 0
  indices[i * 3 + 1] = i + 1
  indices[i * 3 + 2] = i + 2
}

const mesh = new Mesh()
mesh.positions = vertexPositions
mesh.indices = indices
mesh.normals = MeshHelper.ComputeNormals(mesh)
const material = new Material()
material.albedoColor = Color3.FromHexString('#808080')
material.metallic = 0.0
material.roughness = 0.8
const entity = new Entity()
entity.addComponent(new MeshShape(mesh))
entity.addComponent(material)
engine.addEntity(entity)"
/* script for randomly generated trees */,"const TREES_AMOUNT = 20;
const TREE_MIN_SIZE = 1;
const TREE_MAX_SIZE = 5;

for (let i = 0; i < TREES_AMOUNT; i++) {
  const posX = Math.random() * (20 - -20) + -20;
  const posZ = Math.random() * (20 - -20) + -20;
  const size = Math.floor(Math.random() * (TREE_MAX_SIZE - TREE_MIN_SIZE + 1) + TREE_MIN_SIZE);

  for (let j = 0; j < size; j++) {
    const trunk = new BoxShape();
    const crown = new ConeShape();

    const trunkEntity = new Entity();
    const crownEntity = new Entity();

    const crownScale = new Vector3(1, (size - j) * 2, 1);
    const trunkScale = new Vector3(0.5, 2, 0.5);

    trunkEntity.addComponent(trunk);
    crownEntity.addComponent(crown);

    trunkEntity.addComponent(new Transform({
      position: new Vector3(posX, j * 2, posZ),
      scale: trunkScale,
    }));

    crownEntity.addComponent(new Transform({
      position: new Vector3(posX, j * 2 + 2, posZ),
      scale: crownScale,
    }));

    engine.addEntity(trunkEntity);
    engine.addEntity(crownEntity);
  }
}"
/* script for bullet shooting logic */,"import { engine, Entity, Transform, Vector3 } from 'decentraland-ecs'

// Player
const player = new Entity()
player.addComponent(new Transform({
  position: new Vector3(5, 1, 5)
}))
engine.addEntity(player)

// Camera
const camera = new Entity()
camera.setParent(player)
camera.addComponent(new Transform({
  position: new Vector3(0, 1.6, 0)
}))
engine.addEntity(camera)

// Bullet
const bullet = new Entity()
bullet.addComponent(new Transform({
  position: new Vector3(0, 0, 0),
  scale: new Vector3(0.2, 0.2, 0.2)
}))
bullet.addComponent(new SphereShape())
bullet.addComponent(new Material())
bullet.getComponent(Material).albedoColor = Color3.Yellow()
engine.addEntity(bullet)

// Shoot bullets
const bulletSpeed = 5

function shoot() {
  const forward = camera.forward
  const position = camera.position.clone().add(forward.scale(2))
  bullet.getComponent(Transform).position = position
  bullet.getComponent(Transform).rotation = camera.rotation.clone()
  const velocity = forward.scale(bulletSpeed)
  bullet.addComponent(new utils.ProjectileComponent(velocity, 1, (e) => {
    engine.removeEntity(bullet)
  }))
  engine.addEntity(bullet)
}

// Handle mouse clicks
const input = Input.instance
input.subscribe('BUTTON_DOWN', ActionButton.PRIMARY, false, (e) => {
  shoot()
})"
/* script for simple first-person shooter game */ ,"import { scene } from 'decentraland-ecs/src'
import { GLTFShape, Transform, Vector3 } from 'decentraland-ecs/src/decentraland'

// create player camera
const camera = new Entity()
camera.addComponent(new Camera())
camera.addComponent(new Transform({
  position: new Vector3(5, 0, 5),
  rotation: Quaternion.Euler(0, 45, 0)
}))

// create gun
const gun = new Entity()
gun.addComponent(new Transform({
  position: new Vector3(0.5, -0.2, 1),
  rotation: Quaternion.Euler(0, 90, 0),
  scale: new Vector3(0.3, 0.3, 0.3)
}))
gun.addComponent(new GLTFShape('models/gun.glb'))
camera.addChild(gun)

// create bullets
const bulletShape = new GLTFShape('models/bullet.glb')
const bullets: Entity[] = []

// fire bullet when user clicks
Input.instance.subscribe('BUTTON_DOWN', ActionButton.PRIMARY, false, (e) => {
  const bullet = new Entity()
  bullet.addComponent(bulletShape.clone())
  bullet.addComponent(new Transform({
    position: gun.position.clone(),
    rotation: gun.rotation.clone()
  }))
  bullets.push(bullet)
  scene.addEntity(bullet)
})

// move bullets forward
const bulletSpeed = 0.2
function update(dt: number) {
  bullets.forEach(bullet => {
    const direction = bullet.getComponent(Transform).rotation.multiply(Vector3.Forward())
    bullet.getComponent(Transform).translate(direction.scale(bulletSpeed * dt))
  })
}

engine.addSystem(new utils.UpdateSystem(update))"
/* script for countdown timer */,"const countdownTimer = new Entity()
const countdownText = new TextShape('10', FontFamily.SanFrancisco, 10)
countdownTimer.addComponent(countdownText)

let timeRemaining = 10
const interval = setInterval(() => {
  timeRemaining--
  countdownText.value = timeRemaining.toString()

  if (timeRemaining === 0) {
    clearInterval(interval)
    countdownText.value = 'Time\'s up!'
  }
}, 1000)"
/* script for audio player */,"const audioPlayer = new Entity()
const audioClip = new AudioClip('path/to/sound.mp3')
const audioSource = new AudioSource(audioClip)

audioPlayer.addComponent(audioSource)

audioPlayer.addComponent(new OnPointerDown(() => {
  audioSource.playOnce()
}))"
/* script for 360-degree panorama viewer */,"const panoramaViewer = new Entity()

const texture = new Texture('path/to/panorama.jpg')
const material = new Material()
material.albedoTexture = texture

const sphereShape = new SphereShape()
sphereShape.withCollisions = false

const panoramaMesh = new Mesh()
panoramaMesh.withCollisions = false
panoramaMesh.vertices = sphereShape.vertices
panoramaMesh.triangles = sphereShape.triangles
panoramaMesh.uvs = sphereShape.uvs

const panoramaComponent = new MeshComponent(panoramaMesh, material)
panoramaViewer.addComponent(panoramaComponent)

panoramaViewer.addComponent(new utils.SphericalPointer())"
/* script for simple car physics */,"const scene = new Scene()

// Create a car with a box for the body and spheres for the wheels
const car = new Entity()
car.addComponent(new BoxShape())
car.addComponent(new Transform({ position: new Vector3(0, 1, 0), scale: new Vector3(2, 1, 4) }))

const wheel1 = new Entity()
wheel1.addComponent(new SphereShape())
wheel1.addComponent(new Transform({ position: new Vector3(-0.9, 0.5, -1.8), scale: new Vector3(0.5, 0.5, 0.5) }))
car.addChild(wheel1)

const wheel2 = new Entity()
wheel2.addComponent(new SphereShape())
wheel2.addComponent(new Transform({ position: new Vector3(0.9, 0.5, -1.8), scale: new Vector3"
/* script for animated door */,"const door = new Entity();
door.addComponent(new GLTFShape(""models/Door.glb""));
door.addComponent(new Transform({ position: new Vector3(5, 0, 5) }));

const animator = new Animator();
const clip = new AnimationClip(""DoorAnimation"", 0, 1);

const doorOpen = new AnimationState(""DoorOpen"", { looping: false });
const doorClose = new AnimationState(""DoorClose"", { looping: false });

animator.addClip(clip);
door.addComponent(animator);

door.addComponent(
  new OnPointerDown(() => {
    if (doorOpen.isPlaying || doorClose.isPlaying) return;
    doorOpen.play();
    doorClose.stop();
  })
);

door.addComponent(
  new OnPointerUp(() => {
    if (doorClose.isPlaying || doorOpen.isPlaying) return;
    doorClose.play();
    doorOpen.stop();
  })
);

clip.addCubicSampler(""rotation"", 0, Quaternion.Euler(0, 0, 0));
clip.addCubicSampler(""rotation"", 0.5, Quaternion.Euler(0, 90, 0));
clip.addCubicSampler(""rotation"", 1, Quaternion.Euler(0, 180, 0));

doorOpen.addClip(clip);
doorClose.addClip(clip);

doorOpen.clip = clip;
doorClose.clip = clip;

doorOpen.stop();
doorClose.stop();

engine.addEntity(door);"
/* script for flickering lights */,"const lights = [];

for (let i = 0; i < 10; i++) {
  const light = new Entity();
  light.addComponent(new Transform({ position: new Vector3(i, 2, 5) }));
  light.addComponent(new PointLight());
  light.getComponent(PointLight).intensity = 0.5;
  lights.push(light);
  engine.addEntity(light);
}

setInterval(() => {
  for (let i = 0; i < lights.length; i++) {
    const light = lights[i];
    const intensity = Math.random();
    light.getComponent(PointLight).intensity = intensity;
  }
}, 500);"
/* script for random maze generation using prim's algorithm */,"const grid = new utils.Grid(20, 20, 1);
const walls = [];
const visited = new Set();

const startCell = { row: 0, col: 0 };
visited.add(startCell);

function addWalls(cell) {
  const { row, col } = cell;

  if (row > 0) walls.push({ a: [row, col, 0], b: [row - 1, col, 0] });
  if (col > 0) walls.push({ a: [row, col, 0], b: [row, col - 1, 0] });
  if (row < grid.rowCount - 1) walls.push({ a: [row, col, 0], b: [row + 1, col, 0] });
  if (col < grid.columnCount - 1) walls.push({ a: [row, col, 0], b: [row, col + 1, 0] });
}

function getNeighbors(cell) {
  const { row, col } = cell;
  const neighbors = [];

  if (row > 0) neighbors.push({ row: row - 1, col: col });
  if (col > 0) neighbors.push({ row: row, col: col - 1 });
  if (row < grid.rowCount - 1) neighbors.push({ row: row + 1, col: col });
  if (col < grid.columnCount - 1) neighbors.push({ row: row, col: col + 1 });

  return neighbors;
}

addWalls(startCell);

while (visited.size < grid.rowCount * grid.columnCount) {
  let minDistance = Number.MAX_SAFE_INTEGER;
  let wallToRemove = null;

  for (const wall of walls) {
    const [rowA, colA, _] = wall.a;
    const [rowB, colB, _] = wall.b;
    const cellA = { row: rowA, col: colA };
    const cellB = { row: rowB, col: colB };

    if (visited.has(cellA) && !visited.has(cellB)) {
      const distance = Math.random();
      if (distance < minDistance) {
        minDistance = distance;
        wallToRemove = wall;
      }
    }
    if (!visited.has(cellA) && visited.has(cellB)) {
      const distance = Math.random();
      if (distance < minDistance) {
        minDistance = distance;
        wallToRemove = wall;
      }
    }
  }

  const { a, b } = wallToRemove;
  walls.splice(walls.indexOf(wallToRemove), 1);
  addWalls(visited.has(a) ? b : a);
  visited.add(visited.has(a) ? b : a);
}

const maze = new Entity();
maze.addComponent(new Transform({ position: new Vector3(5, 0, 5) }));
engine.addEntity(maze);

for (const wall of walls) {
  const entity = new Entity();
  entity.addComponent(new Transform({ position: new Vector3(...wall.a) }));
  entity.addComponent(new BoxShape());
  maze.addChild(entity);
}"
/* script for gravity simulator */,"// A simple gravity simulator script

const objects = [];

for (let i = 0; i < 10; i++) {
  const mass = Math.random() * 10;
  const position = new Vector3(
    Math.random() * 20 - 10,
    Math.random() * 20 - 10,
    Math.random() * 20 - 10
  );
  const velocity = new Vector3(
    Math.random() * 2 - 1,
    Math.random() * 2 - 1,
    Math.random() * 2 - 1
  );
  const force = new Vector3(0, 0, 0);
  const acceleration = new Vector3(0, 0, 0);
  const object = { mass, position, velocity, force, acceleration };
  objects.push(object);

  const entity = new Entity();
  const sphereShape = new SphereShape();
  entity.addComponentOrReplace(sphereShape);
  entity.addComponentOrReplace(new Transform({ position }));
  engine.addEntity(entity);
}

const G = 6.67408e-11;
const dt = 0.01;

function updateObjects() {
  for (let i = 0; i < objects.length; i++) {
    const object1 = objects[i];
    object1.force.setAll(0);
    object1.acceleration.setAll(0);
    for (let j = 0; j < objects.length; j++) {
      if (i !== j) {
        const object2 = objects[j];
        const distance = object2.position.subtract(object1.position);
        const direction = distance.normalize();
        const magnitude = G * object1.mass * object2.mass / distance.lengthSquared();
        const force = direction.scale(magnitude);
        object1.force = object1.force.add(force);
      }
    }
    object1.acceleration = object1.force.scale(1 / object1.mass);
    object1.velocity = object1.velocity.add(object1.acceleration.scale(dt));
    object1.position = object1.position.add(object1.velocity.scale(dt));
    const entity = engine.entities[i];
    entity.getComponent(Transform).position = object1.position;
  }
}

engine.addSystem(new UpdateSystem(updateObjects));"
/* script for weather simulator */,"import { Entity, engine, Vector3, Transform } from 'decentraland-ecs/src'

const weatherEntities: Entity[] = []
const totalParticles = 1000
const areaSize = 20
const particleSize = 0.1
const particleSpeed = 0.2
const particleColor = Color3.FromHexString(""#FFFFFF"")

for (let i = 0; i < totalParticles; i++) {
  // Create an entity for each particle
  const particle = new Entity()
  weatherEntities.push(particle)
  
  // Create a random starting position for the particle within the specified area
  const position = new Vector3(
    Math.random() * areaSize - areaSize / 2,
    Math.random() * areaSize - areaSize / 2,
    Math.random() * areaSize - areaSize / 2
  )

  // Create a Transform component with the particle's starting position and size
  const transform = new Transform({
    position: position,
    scale: new Vector3(particleSize, particleSize, particleSize)
  })

  // Add the Transform component to the particle entity
  particle.addComponent(transform)

  // Add a custom component to store the particle's velocity
  particle.addComponent(new class {
    velocity = new Vector3(Math.random(), Math.random(), Math.random()).normalize().scale(particleSpeed)
  })

  // Add a GLTFShape component to give the particle a visual representation
  particle.addComponent(new GLTFShape(""models/sphere.glb""))

  // Add a Material component to give the particle its color
  particle.addComponent(new Material())
  particle.getComponent(Material).albedoColor = particleColor

  // Add the particle entity to the engine
  engine.addEntity(particle)
}

// Create an update system to animate the particles
class ParticleSystem implements ISystem {
  update(dt: number) {
    for (const particle of weatherEntities) {
      // Get the particle's current position and velocity
      const transform = particle.getComponent(Transform)
      const velocity = particle.getComponent<any>(undefined).velocity

      // Calculate the particle's new position based on its velocity
      transform.position = transform.position.add(velocity.scale(dt))

      // Wrap the particle around the edges of the area if it goes out of bounds
      if (transform.position.x < -areaSize / 2) {
        transform.position.x = areaSize / 2
      } else if (transform.position.x > areaSize / 2) {
        transform.position.x = -areaSize / 2
      }

      if (transform.position.y < -areaSize / 2) {
        transform.position.y = areaSize / 2
      } else if (transform.position.y > areaSize / 2) {
        transform.position.y = -areaSize / 2
      }

      if (transform.position.z < -areaSize / 2) {
        transform.position.z = areaSize / 2
      } else if (transform.position.z > areaSize / 2) {
        transform.position.z = -areaSize / 2
      }
    }
  }
}

// Add the particle system to the engine
engine.addSystem(new ParticleSystem())"
/* script for procedural terrain */,"const terrain = new Entity();
terrain.addComponent(new HeightMap(64, 64, (x, y) => {
  const height = (Math.sin(x * 0.1) + Math.sin(y * 0.1)) * 5;

  return height;
}));
terrain.addComponent(new Transform({ position: new Vector3(0, 0, 0) }));

engine.addEntity(terrain);"
/* script for music machine that plays different note each time you click a button */,"const musicMachine = new Entity()

// Add button
const button = new Entity()
button.addComponent(new BoxShape())
button.addComponent(new Transform({
  position: new Vector3(5, 0, 5)
}))
engine.addEntity(button)

// Add audio sources
const audioSources = []
for (let i = 0; i < 4; i++) {
  const audioSource = new AudioSource(new AudioClip(`./sounds/note${i + 1}.mp3`))
  audioSources.push(audioSource)
}

// Add button behavior
let counter = 0
button.addComponent(new OnClick(() => {
  audioSources[counter].playOnce()
  counter = (counter + 1) % audioSources.length
}))

musicMachine.addComponent(new Transform())
engine.addEntity(musicMachine)"
/* script for animated fish swimming back and forth in loop */,"const fish = new Entity()

// Add fish model
const fishShape = new GLTFShape('./models/fish.glb')
fish.addComponent(fishShape)

// Add fish movement behavior
const duration = 3 // seconds
const distance = 1 // meters
const startPos = new Vector3(10, 0, 10)
const endPos = new Vector3(15, 0, 10)
const fishTransform = new Transform({
  position: startPos
})
fish.addComponent(fishTransform)

const initialTime = +new Date()
const swim = () => {
  const timeDiff = (+new Date() - initialTime) / 1000
  const progress = timeDiff % duration / duration
  fishTransform.position = Vector3.Lerp(startPos, endPos, progress)
  fishTransform.rotation.eulerAngles = new Vector3(0, Math.sin(timeDiff * 2 * Math.PI / duration) * 30, 0)
  requestAnimationFrame(swim)
}
swim()

engine.addEntity(fish)"
/* script for simple trading game */,"const GAME_DURATION = 60 // seconds
const ITEM_COSTS = [10, 20, 30, 40, 50] // costs of each item
const MAX_INVENTORY = 5 // maximum number of items that can be held at once
const MIN_INVENTORY = 0 // minimum number of items that can be held at once

const items = [] // list of items the player is holding
let money = 0 // player's money
let timeRemaining = GAME_DURATION // seconds left in the game

// create items with random starting costs
for (let i = 0; i < ITEM_COSTS.length; i++) {
  items.push({
    cost: ITEM_COSTS[i] + Math.floor(Math.random() * 10)
  })
}

// create UI elements
const uiCanvas = new UICanvas()
const timeText = new UIText(uiCanvas)
timeText.fontSize = 32
timeText.color = Color3.Yellow()
timeText.hAlign = 'right'
timeText.vAlign = 'top'
timeText.positionX = 200
timeText.positionY = 100

const moneyText = new UIText(uiCanvas)
moneyText.fontSize = 32
moneyText.color = Color3.Green()
moneyText.hAlign = 'right'
moneyText.vAlign = 'top'
moneyText.positionX = 200
moneyText.positionY = 50

const itemButtons = []
for (let i = 0; i < ITEM_COSTS.length; i++) {
  const button = new UIButton(uiCanvas, new UIImage('images/button.png'))
  button.width = 150
  button.height = 50
  button.positionX = -100
  button.positionY = 50 - i * 75
  button.onClick = new OnClick(() => {
    if (items.length < MAX_INVENTORY && money >= ITEM_COSTS[i]) {
      money -= ITEM_COSTS[i]
      items.push({
        cost: ITEM_COSTS[i] + Math.floor(Math.random() * 10)
      })
    }
  })

  const text = new UIText(button)
  text.value = `Buy for ${ITEM_COSTS[i]}`
  text.fontSize = 16
  text.color = Color3.Black()
  text.hAlign = 'center'
  text.vAlign = 'center'

  itemButtons.push(button)
}

// create update system to run game logic
const update = (dt: number) => {
  // update time remaining
  timeRemaining -= dt
  timeText.value = `Time: ${Math.ceil(timeRemaining)}s`

  // update money
  money += items.reduce((total, item) => total + item.cost, 0)
  moneyText.value = `Money: ${money}$`

  // update button states
  for (let i = 0; i < ITEM_COSTS.length; i++) {
    itemButtons[i].isPointerBlocker = items.length >= MAX_INVENTORY || money < ITEM_COSTS[i]
  }

  // remove items if inventory is too full
  while (items.length > MAX_INVENTORY) {
    items.shift()
  }

  // end game if time is up
  if (timeRemaining <= 0) {
    engine.removeSystem(update)
    timeText.value = 'Game Over'
    for (const button of itemButtons) {
      button.isPointerBlocker = true
    }
  }
}

engine.addSystem(new utils.UpdateSystem(update))"
/* script of moving forward character */,"const myCharacter = new Entity()
myCharacter.addComponent(new GLTFShape('models/myCharacter.glb'))
myCharacter.addComponent(new Transform({ position: new Vector3(0, 0, 0) }))
engine.addEntity(myCharacter)

// Add a script to move the character forward
class MoveForward {
  update(dt: number) {
    const transform = myCharacter.getComponent(Transform)
    transform.translate(Vector3.Forward().scale(10 * dt))
  }
}
myCharacter.addComponent(new MoveForward())"
/* script for dynamic music player that changes based on player's location */,"const music = new Entity()
music.addComponent(new AudioSource(new AudioClip('sounds/music.mp3')))
music.addComponent(new Transform({ position: new Vector3(0, 0, 0) }))
engine.addEntity(music)

// Add a script to change the music based on player location
class MusicPlayer {
  update(dt: number) {
    const playerTransform = Camera.instance.position
    const distanceToMusic = playerTransform.distance(music.getComponent(Transform).position)
    if (distanceToMusic < 10) {
      music.getComponent(AudioSource).volume = 1 - (distanceToMusic / 10)
    } else {
      music.getComponent(AudioSource).volume = 0
    }
  }
}
music.addComponent(new MusicPlayer())"
/* script for dynamic weather system that changes based on time of day */,"const sun = new Entity()
sun.addComponent(new GLTFShape('models/sun.glb'))
sun.addComponent(new Transform({ position: new Vector3(0, 100, 0) }))
engine.addEntity(sun)

// Add a script to change the sun's position based on time of day
class SunController {
  update(dt: number) {
    const timeOfDay = Time.getTimestamp() % (24 * 60 * 60)
    const sunTransform = sun.getComponent(Transform)
    sunTransform.rotation.eulerAngles = new Vector3((timeOfDay / (24 * 60 * 60)) * 360, 0, 0)
  }
}
sun.addComponent(new SunController())

// Add a script to change the weather based on time of day
class WeatherController {
  update(dt: number) {
    const timeOfDay = Time.getTimestamp() % (24 * 60 * 60)
    const weather = Math.sin((timeOfDay / (24 * 60 * 60)) * (Math.PI * 2))
    if (weather > 0.5) {
      // Rainy weather
      // ...
    } else {
      // Sunny weather
      // ...
    }
  }
}"
/* script for pong game */,"import { engine, Entity, Transform, BoxShape, Material, Color3, Vector3 } from 'decentraland-ecs'

// Create the paddles
const paddleSize = new Vector3(0.5, 0.1, 0.1)
const paddleMaterial = new Material()
paddleMaterial.albedoColor = Color3.Yellow()
const leftPaddle = new Entity()
leftPaddle.addComponent(new Transform({ position: new Vector3(-5, 1, 0), scale: paddleSize }))
leftPaddle.addComponent(new BoxShape())
leftPaddle.addComponent(paddleMaterial)
engine.addEntity(leftPaddle)

const rightPaddle = new Entity()
rightPaddle.addComponent(new Transform({ position: new Vector3(5, 1, 0), scale: paddleSize }))
rightPaddle.addComponent(new BoxShape())
rightPaddle.addComponent(paddleMaterial)
engine.addEntity(rightPaddle)

// Create the ball
const ballMaterial = new Material()
ballMaterial.albedoColor = Color3.Red()
const ball = new Entity()
ball.addComponent(new Transform({ position: Vector3.Zero(), scale: new Vector3(0.1, 0.1, 0.1) }))
ball.addComponent(new BoxShape())
ball.addComponent(ballMaterial)
engine.addEntity(ball)

// Set up the game state
let leftScore = 0
let rightScore = 0
const scoreText = new Entity()
scoreText.addComponent(new Transform({ position: new Vector3(0, 3, 0) }))
scoreText.addComponent(new TextShape('0 - 0'))
engine.addEntity(scoreText)

// Add the game logic
ball.addComponent(new utils.Interval(100, () => {
  // Move the ball
  const newPosition = ball.getComponent(Transform).position.add(new Vector3(0.2, 0, 0))
  ball.getComponent(Transform).position = newPosition

  // Check for collisions with the paddles
  if (leftPaddle.getComponent(BoxShape).raycast(newPosition, new Vector3(-1, 0, 0), 0.2)) {
    ball.getComponent(Transform).position = newPosition.add(new Vector3(0.5, 0, 0))
  } else if (rightPaddle.getComponent(BoxShape).raycast(newPosition, new Vector3(1, 0, 0), 0.2)) {
    ball.getComponent(Transform).position = newPosition.add(new Vector3(-0.5, 0, 0))
  }

  // Check for collisions with the walls
  if (newPosition.x < -10 || newPosition.x > 10) {
    if (newPosition.x < -10) {
      rightScore++
    } else {
      leftScore++
    }
    scoreText.getComponent(TextShape).value = `${leftScore} - ${rightScore}`
    ball.getComponent(Transform).position = Vector3.Zero()
  }

  // Check for a winner
  if (leftScore >= 10 || rightScore >= 10) {
    scoreText.getComponent(TextShape).value = `${leftScore} - ${rightScore}\nGame Over`
    ball.removeComponent(utils.Interval)
  }
}))"
/* script for controlling left paddle with keyboard */,"class PongGame {
  private leftPaddle: Entity
  private rightPaddle: Entity
  private ball: Entity

  constructor() {
    this.createPaddles()
    this.createBall()

    engine.addSystem(new utils.IntervalSystem(100, () => this.moveBall()))
    engine.addSystem(new utils.IntervalSystem(100, () => this.checkBallCollision()))
    engine.addSystem(new utils.IntervalSystem(100, () => this.checkScore()))
    engine.addSystem(new PaddleControlSystem(this.leftPaddle))
  }

  private createPaddles(): void {
    // Create the left paddle
    this.leftPaddle = new Entity()
    this.leftPaddle.addComponent(new Transform({
      position: new Vector3(-5, 0, 0),
      scale: new Vector3(0.2, 1, 0.8)
    }))
    this.leftPaddle.addComponent(new BoxShape())
    engine.addEntity(this.leftPaddle)

    // Create the right paddle
    this.rightPaddle = new Entity()
    this.rightPaddle.addComponent(new Transform({
      position: new Vector3(5, 0, 0),
      scale: new Vector3(0.2, 1, 0.8)
    }))
    this.rightPaddle.addComponent(new BoxShape())
    engine.addEntity(this.rightPaddle)
  }

  private createBall(): void {
    this.ball = new Entity()
    this.ball.addComponent(new Transform({
      position: new Vector3(0, 0, 0),
      scale: new Vector3(0.5, 0.5, 0.5)
    }))
    this.ball.addComponent(new SphereShape())
    engine.addEntity(this.ball)
  }

  private moveBall(): void {
    // Code to move the ball
  }

  private checkBallCollision(): void {
    // Code to check for ball collisions
  }

  private checkScore(): void {
    // Code to check for score
  }
}

class PaddleControlSystem implements ISystem {
  private paddle: Entity

  constructor(paddle: Entity) {
    this.paddle = paddle
  }

  update(): void {
    if (Input.isKeyDown(KeyCode.W)) {
      this.paddle.getComponent(Transform).translate(new Vector3(0, 0, -0.2))
    }

    if (Input.isKeyDown(KeyCode.S)) {
      this.paddle.getComponent(Transform).translate(new Vector3(0, 0, 0.2))
    }
  }
}

new PongGame()"
/* script to control a paddle in the pong game */,"const rightPaddle = new Entity()
rightPaddle.addComponent(new BoxShape())
rightPaddle.addComponent(new Transform({
  position: new Vector3(1, 1, 0),
  scale: new Vector3(0.2, 1, 0.2)
}))
engine.addEntity(rightPaddle)

// Move the right paddle up when the ""up arrow"" key is pressed
keyboard.onKeyDown(""ArrowUp"", () => {
  const currentPosition = rightPaddle.getComponent(Transform).position
  rightPaddle.getComponent(Transform).position = new Vector3(currentPosition.x, currentPosition.y + 0.1, currentPosition.z)
})

// Move the right paddle down when the ""down arrow"" key is pressed
keyboard.onKeyDown(""ArrowDown"", () => {
  const currentPosition = rightPaddle.getComponent(Transform).position
  rightPaddle.getComponent(Transform).position = new Vector3(currentPosition.x, currentPosition.y - 0.1, currentPosition.z)
})"
/* script for platformer game that can move and jump */,"import { engine } from ""@dcl/sdk"";
import utils from ""../node_modules/decentraland-ecs-utils/index"";

// Create the player entity with necessary components
const player = new Entity();
player.addComponent(new GLTFShape(""models/character.glb""));
player.addComponent(new Transform({ position: new Vector3(8, 0, 8) }));

// Set up movement variables
const MOVE_FORCE = 100;
const JUMP_FORCE = 200;
let grounded = true;

// Add movement logic
player.addComponent(
  new utils.MoveTransformComponent(
    new Vector3(0, 0, 1),
    MOVE_FORCE,
    (transform) => {
      if (grounded) {
        if (transform.position.y < 0.5) {
          transform.position.y = 0.5;
        }
      } else {
        if (transform.position.y < 0.1) {
          transform.position.y = 0.1;
        }
      }
    },
    null,
    (transform) => {
      if (grounded && transform.position.y > 0.6) {
        grounded = false;
      }
    }
  )
);

// Add jumping logic
player.addComponent(
  new utils.JumpComponent(
    JUMP_FORCE,
    () => grounded,
    (jumping) => {
      grounded = !jumping;
    }
  )
);

// Create the ground entity
const ground = new Entity();
ground.addComponent(new BoxShape());
ground.addComponent(new Transform({ position: new Vector3(8, 0, 8), scale: new Vector3(16, 0.1, 16) }));
ground.addComponent(new Material());
ground.getComponent(Material).albedoColor = Color3.Gray();

// Add collider to ground for player to collide with
ground.addComponent(new utils.TriggerComponent(
  new utils.TriggerBoxShape(
    new Vector3(16, 0.1, 16),
    new Vector3(0, 0.05, 0)
  ),
  {
    onCameraEnter: () => {
      grounded = true;
    }
  }
));

// Add entities to engine
engine.addEntity(player);
engine.addEntity(ground);"
/* script to create a text input that allows the user to enter a value */,"const inputEntity = new Entity()
const inputShape = new TextInputShape()
inputShape.width = ""100px""
inputShape.height = ""30px""
inputShape.placeholder = ""Enter your name""
inputShape.isPointerBlocker = true
inputEntity.addComponent(inputShape)
inputEntity.addComponent(new Transform({ position: new Vector3(5, 2, 5) }))
inputEntity.addComponent(new OnClick(() => {
  inputShape.isFocused = true
}))

inputShape.onTextSubmit = new OnTextSubmit((value: string) => {
  log(value)
})

engine.addEntity(inputEntity)"
/* script for a simple on/off switch that toggles the visibility of an object */,"const switchEntity = new Entity()
switchEntity.addComponent(new BoxShape())
switchEntity.addComponent(new Transform({ position: new Vector3(5, 1, 5) }))
switchEntity.addComponent(new OnClick(() => {
  if (object.isVisible) {
    object.isVisible = false
  } else {
    object.isVisible = true
  }
}))

const object = new Entity()
object.addComponent(new BoxShape())
object.addComponent(new Transform({ position: new Vector3(5, 1, 5) }))
object.isVisible = true
engine.addEntity(switchEntity)
engine.addEntity(object)"
/* script for a timer that updates a counter every second */ ,"const timerEntity = new Entity()
timerEntity.addComponent(new utils.Interval(1000, () => {
  if (counter.value > 0) {
    counter.value -= 1
  } else {
    // end the game or trigger some other event
  }
}))

const counter = new Entity()
counter.addComponent(new TextShape(""60""))
counter.addComponent(new Transform({ position: new Vector3(5, 1, 5) }))
engine.addEntity(counter)"
/* script to randomly place objects with a defined area */ ,"const startPosition = new Vector3(5, 0, 5)
const areaWidth = 10
const areaDepth = 10

for(let i = 0; i < 10; i++){
  const randomX = startPosition.x + Math.floor(Math.random() * areaWidth)
  const randomZ = startPosition.z + Math.floor(Math.random() * areaDepth)
  const object = new Entity()
  object.addComponent(new BoxShape())
  object.addComponent(new Transform({ position: new Vector3(randomX, 1, randomZ) }))
  engine.addEntity(object)
}"
/* script for multiplayer game to try to catch falling objects */,"import { Vector3, engine } from 'decentraland-ecs'

// Set up the game
const objects = ['apple', 'banana', 'orange']
let score = 0

// Create a timer to spawn falling objects
const spawnTimer = new utils.Interval(() => {
  // Choose a random object
  const object = objects[Math.floor(Math.random() * objects.length)]
  
  // Create the entity
  const entity = new Entity()
  entity.addComponent(new GLTFShape(`models/${object}.glb`))
  entity.addComponent(new Transform({ position: new Vector3(Math.random() * 10 - 5, 20, 0) }))
  engine.addEntity(entity)
  
  // Add a script to make it fall
  entity.addComponent(new utils.Fall({ duration: 2 }))
  
  // Add a script to detect when it's caught
  entity.addComponent(new utils.Collider({
    shape: utils.ColliderShape.Box,
    layer: 2,
    with: [3],
    onTriggerEnter: () => {
      engine.removeEntity(entity)
      score++
    }
  }))
}, 1000)

// Create the player entity
const player = new Entity()
player.addComponent(new GLTFShape('models/player.glb'))
player.addComponent(new Transform({ position: new Vector3(0, 0, -10) }))
engine.addEntity(player)

// Control the player with the keyboard
const speed = 0.1
const moveLeft = () => player.getComponent(Transform).translateX(-speed)
const moveRight = () => player.getComponent(Transform).translateX(speed)
input.subscribe('BUTTON_DOWN', ActionButton.LEFT, moveLeft)
input.subscribe('BUTTON_DOWN', ActionButton.RIGHT, moveRight)

// Display the score
const scoreText = new UIText()
scoreText.value = 'Score: 0'
scoreText.fontSize = 30
scoreText.color = Color3.Yellow()
scoreText.hAlign = 'center'
scoreText.vAlign = 'top'
scoreText.positionY = 90
ui.addText(scoreText)

// Update the score text every frame
const update = () => scoreText.value = `Score: ${score}`
engine.addSystem(new utils.UpdateSystem(update))"
/* script for cone */,"const cone = new Entity()
cone.addComponent(new CylinderShape())
cone.addComponent(
  new Transform({
    position: new Vector3(
      getRandomFloat(-5, 5),
      0.5,
      -getRandomFloat(10, 100)
    )
  })
)
cone.addComponent(new Material())
cone.getComponent(Material).albedoColor = new Color3(1, 0.8, 0)
engine.addEntity(cone)"
/* script to generate random float and put a coin on it */,"const coin = new Entity()
coin.addComponent(new SphereShape())
coin.addComponent(
  new Transform({
    position: new Vector3(
      getRandomFloat(-5, 5),
      0.5,
      -getRandomFloat(10, 100)
    )
  })
)
coin.addComponent(new Material())
coin.getComponent(Material).albedoColor = new Color3(1, 0.95, 0)
engine.addEntity(coin)"
/* script to check collision to check if the car's bouding box collides with the bouding box of any cones or coins on the track */,"function checkCollision() {
  for (let i = 0; i < obstacles.length; i++) {
    const obstacle = obstacles[i]
    if (car.isCollidingWith(obstacle)) {
      if (obstacle.name === 'coin') {
        score += 10
      }
      engine.removeEntity(obstacle)
      obstacles.splice(i, 1)
      i--
    }
  }
}

scene.ondisabled = () => {
  for (let i = 0; i < obstacles.length; i++) {
    engine.removeEntity(obstacles[i])
  }
}"
/* script to load external 3D models */,"const model = new Entity()
const gltfShape = new GLTFShape('models/myModel.glb')
model.addComponentOrReplace(gltfShape)
engine.addEntity(model)"
/* script for a game to match the color */,"import { engine, Entity, Transform, TextShape } from 'decentraland-ecs'

// Define the list of colors to match
const colors = [
  { name: 'red', hex: '#FF0000' },
  { name: 'blue', hex: '#0000FF' },
  { name: 'green', hex: '#00FF00' },
  { name: 'yellow', hex: '#FFFF00' },
  { name: 'purple', hex: '#800080' },
  { name: 'orange', hex: '#FFA500' },
]

// Define the game state
let currentColor = 0
let score = 0

// Create the text entity for the color name
const colorName = new Entity()
colorName.addComponent(new Transform({ position: new Vector3(5, 2, 5) }))
colorName.addComponent(new TextShape('Match the color!'))
engine.addEntity(colorName)

// Create the text entity for the score
const scoreText = new Entity()
scoreText.addComponent(new Transform({ position: new Vector3(5, 1, 5) }))
scoreText.addComponent(new TextShape(`Score: ${score}`))
engine.addEntity(scoreText)

// Create the color swatches
for (let i = 0; i < colors.length; i++) {
  const color = colors[i]
  const swatch = new Entity()
  swatch.addComponent(new Transform({ position: new Vector3(i - 2, 0, -5) }))
  swatch.addComponent(new TextShape(color.name))
  swatch.addComponent(
    new OnClick(() => {
      if (i === currentColor) {
        score += 1
        scoreText.getComponent(TextShape).value = `Score: ${score}`
        currentColor += 1
        if (currentColor === colors.length) {
          currentColor = 0
        }
        colorName.getComponent(TextShape).value = colors[currentColor].name
      } else {
        score -= 1
        scoreText.getComponent(TextShape).value = `Score: ${score}`
      }
    })
  )
  engine.addEntity(swatch)
}"
/* script for a scoreboard */,"  // Create the scoreboard
  let scoreboard = new Entity()
  scoreboard.addComponent(new Transform({ position: new Vector3(-3.5, 1, -3.5) }))

  let text = new Entity()
  text.addComponent(new Transform({ position: new Vector3(0, 0, 0) }))
  text.addComponent(new TextShape(""Score: 0""))
  scoreboard.addChild(text)

  engine.addEntity(scoreboard)"
/* script to move the camera up when up arrow key is pressed and down when down arrow key is pressed */,"let upKeyPressed = false
let downKeyPressed = false

function moveCamera() {
  const camera = Camera.instance
  const speed = 0.1

  if (upKeyPressed) {
    camera.position.y += speed
  }
  if (downKeyPressed) {
    camera.position.y -= speed
  }
}

// Listen for key down events
Input.instance.subscribe('KEY_DOWN', (e) => {
  if (e.key === 'ArrowUp') {
    upKeyPressed = true
  }
  if (e.key === 'ArrowDown') {
    downKeyPressed = true
  }
})

// Listen for key up events
Input.instance.subscribe('KEY_UP', (e) => {
  if (e.key === 'ArrowUp') {
    upKeyPressed = false
  }
  if (e.key === 'ArrowDown') {
    downKeyPressed = false
  }
})

executeOnEveryFrame(moveCamera)"
/* script for simple inventory system */,"import { Entity, engine, Transform, Vector3 } from 'decentraland-ecs/src'

// Define the item entity
const item = new Entity()
item.addComponent(new Transform({ position: new Vector3(5, 1, 5) }))

// Define the inventory entity
const inventory = new Entity()
inventory.addComponent(new Transform({ position: new Vector3(0, 1, 0) }))

// Add mouse click event listener to item
item.addComponent(
  new OnPointerDown(() => {
    // Add item to inventory
    inventory.addChild(item)

    // Set item position to inventory position
    item.getComponent(Transform).position = new Vector3(0, 0, 0)
  })
)

// Add mouse click event listener to inventory
inventory.addComponent(
  new OnPointerDown((e) => {
    // Check if inventory has child item
    if (inventory.hasChildren()) {
      // Remove child item from inventory
      const child = inventory.getChildren()[0]
      inventory.removeChild(child)

      // Set item position to mouse position
      child.getComponent(Transform).position = new Vector3(e.hitPoint.x, e.hitPoint.y, e.hitPoint.z)
      engine.addEntity(child)
    }
  })
)

// Add entities to engine
engine.addEntity(item)
engine.addEntity(inventory)"
/* script for trigger zone */,"const trigger = new Entity()
trigger.addComponent(new Transform({ position: new Vector3(0, 1, 0) }))
trigger.addComponent(new BoxShape())
trigger.addComponent(
  new utils.TriggerComponent(
    new utils.TriggerBoxShape(new Vector3(1, 1, 1)), // size of trigger box
    null, // callback function when an entity enters the trigger
    null, // callback function when an entity exits the trigger
    null, // callback function when an entity is inside the trigger
    null // callback function when an entity is outside the trigger
  )
)
engine.addEntity(trigger)"
/* script for physics simulation */,"const ball = new Entity()
ball.addComponent(new SphereShape())
ball.addComponent(new RigidBody())
ball.getComponent(RigidBody).mass = 1
ball.getComponent(RigidBody).useGravity = true
ball.addComponent(new Transform({ position: new Vector3(0, 10, 0) }))
engine.addEntity(ball)

const box = new Entity()
box.addComponent(new BoxShape())
box.addComponent(new RigidBody())
box.getComponent(RigidBody).mass = 5
box.getComponent(RigidBody).useGravity = true
box.addComponent(new Transform({ position: new Vector3(0, 5, 0) }))
engine.addEntity(box)

// add physics system to the engine
engine.addSystem(new PhysicsSystem())"
/* script for jumping game */,"const jumpForce = 7
const gravity = 0.25

const player = new Entity()
player.addComponent(new GLTFShape('models/character.glb'))
player.addComponent(new Transform({ position: new Vector3(5, 1, 5) }))
player.addComponent(new Rigidbody())

player.getComponent(Rigidbody).mass = 1

const ground = new Entity()
ground.addComponent(new BoxShape())
ground.addComponent(new Transform({ scale: new Vector3(20, 1, 20), position: new Vector3(10, -0.5, 10) }))

engine.addEntity(player)
engine.addEntity(ground)

player.addComponent(new JumpComponent(jumpForce))

class JumpComponent {
  private jumpForce: number

  constructor(jumpForce: number) {
    this.jumpForce = jumpForce
  }

  jump() {
    if (this.isGrounded()) {
      player.getComponent(Rigidbody).applyImpulse(new Vector3(0, this.jumpForce, 0))
    }
  }

  isGrounded(): boolean {
    const ray = new Ray(player.getComponent(Transform).position, new Vector3(0, -1, 0))
    const hitResult = engine.castRay(ray)

    return hitResult.hit && hitResult.distance < 0.6
  }
}

function update(dt: number) {
  if (Input.instance.isKeyDown('SPACE')) {
    player.getComponent(JumpComponent).jump()
  }

  const velocity = player.getComponent(Rigidbody).linearVelocity
  velocity.y -= gravity
  player.getComponent(Rigidbody).linearVelocity = velocity
}

engine.addSystem(new utils.UpdateSystem(update))"
/* script for flying game */,"const speed = 5
const rotationSpeed = 0.1

const camera = Camera.instance
camera.position.set(0, 10, 0)
camera.rotation.set(0, 0, 0)

const plane = new Entity()
plane.addComponent(new GLTFShape('models/plane.glb'))
plane.addComponent(new Transform({ position: new Vector3(0, 5, -20) }))

const target = new Vector3(0, 5, 0)

engine.addEntity(plane)

function update(dt: number) {
  const forward = camera.forward
  const right = camera.right

  if (Input.instance.isKeyDown('W')) {
    plane.getComponent(Transform).position.add(forward.scale(speed * dt))
  }
  if (Input.instance.isKeyDown('S')) {
    plane.getComponent(Transform).position.add(forward.scale(-speed * dt))
  }
  if (Input.instance.isKeyDown('A')) {
    plane.getComponent(Transform).position.add(right.scale(-speed * dt))
  }
  if (Input.instance.isKeyDown('D')) {
    plane.getComponent(Transform).position.add(right.scale(speed * dt))
  }

  const direction = target.subtract(plane.getComponent(Transform).position).normalize()
  const cross = forward.cross(direction)

  const angle = Math.acos(forward.dot(direction))
  const rotation = Quaternion.axisAngle(cross, angle * rotationSpeed)

  plane.getComponent(Transform).rotation = Quaternion.Slerp(
    plane.getComponent(Transform).rotation,
    rotation,
    dt
  )
}

engine.addSystem(new utils.UpdateSystem(update))"
/* script to display a video on a screen in-world */,"const video = new VideoTexture(""https://www.example.com/video.mp4"", 1280, 720)
const screen = new Entity()
screen.addComponent(new BoxShape())
screen.addComponent(video)
engine.addEntity(screen)"
/* script for interactive furniture */,"import { Entity, engine, Vector3 } from 'decentraland-ecs';

// create table
const table = new Entity();
table.addComponent(new GLTFShape('models/table.glb'));
table.addComponent(new Transform({ position: new Vector3(8, 0, 8) }));
engine.addEntity(table);

// create drawer
const drawer = new Entity();
drawer.addComponent(new BoxShape());
drawer.addComponent(new Transform({ position: new Vector3(0, 0.2, 0.5), scale: new Vector3(0.5, 0.1, 0.5) }));
drawer.addComponent(new OnClick(() => {
  // toggle drawer open/closed
  drawer.getComponent(Transform).position.y += 0.1;
}));
table.addChild(drawer);"
/* script for dynamic text label */,"import { Entity, engine } from 'decentraland-ecs';

// create text label
const text = new Entity();
text.addComponent(new TextShape(''));
text.addComponent(new Transform({ position: new Vector3(8, 2, 8) }));
engine.addEntity(text);

// update label text every second
setInterval(() => {
  const date = new Date();
  const timeString = date.toLocaleTimeString();
  text.getComponent(TextShape).value = timeString;
}, 1000);"
/* script for 3D animator character */,"import utils from 'utils'
import { Animator } from 'decentraland-ecs'

// Create a 3D character
const character = new Entity()
character.addComponent(new GLTFShape('models/character.glb'))
character.addComponent(new Transform({ position: new Vector3(0, 0, 0) }))
engine.addEntity(character)

// Create an animator component for the character
const animator = new Animator()
character.addComponent(animator)

// Define the animations to use for the character
const clip1 = new AnimationClip('clip1', { tracks: [] })
clip1.addTrack(new VectorKeyframeTrack('transform.scale', [0, 1], [1, 1, 1], [1.5, 1.5, 1.5]))
clip1.setLoop(true)

const clip2 = new AnimationClip('clip2', { tracks: [] })
clip2.addTrack(new VectorKeyframeTrack('transform.rotation', [0, 1], [0, 0, 0, 1], [0, 0.5, 0, 1]))
clip2.setLoop(true)

// Add the animations to the animator component
animator.addClip(clip1)
animator.addClip(clip2)

// Play one of the animations on the character
animator.playAnimation('clip1')"
/* script to emit particles when the player clicks the screen */,"const emitter = new Entity()
emitter.addComponent(new Transform({
  position: new Vector3(5, 0, 5)
}))
const particleSystem = new ParticleSystem()
particleSystem.playing = true
emitter.addComponent(particleSystem)
emitter.addComponent(
  new OnPointerDown(() => {
    particleSystem.playing = true
  })
)
engine.addEntity(emitter)"
/* script to change color of light when clicking */,"const light = new Entity()
light.addComponent(new Transform({
  position: new Vector3(5, 0, 5)
}))
const pointLight = new PointLight()
pointLight.intensity = 10
pointLight.range = 10
light.addComponent(pointLight)
light.addComponent(
  new OnPointerDown(() => {
    pointLight.color = new Color4(Math.random(), Math.random(), Math.random(), 1)
  })
)
engine.addEntity(light)"
/* script to open.a door when the player clicks on screen */,"const door = new Entity()
door.addComponent(new Transform({
  position: new Vector3(5, 0, 5),
  scale: new Vector3(1, 2, 1)
}))
door.addComponent(new BoxShape())
door.addComponent(
  new OnPointerDown(() => {
    door.getComponent(Transform).position.y = 2
  })
)
engine.addEntity(door)"
/* script to create a simple sound effect */,"const sound = new Entity()
sound.addComponent(new AudioSource(new AudioClip('sounds/explosion.mp3')))
sound.addComponent(new Transform({
  position: new Vector3(5, 0, 5)
}))
engine.addEntity(sound)
sound.getComponent(AudioSource).playOnce()"
/* script to create a simple pickup */,"const pickup = new Entity()
pickup.addComponent(new GLTFShape('models/pickup.glb'))
pickup.addComponent(new Transform({
  position: new Vector3(5, 0, 5)
}))
pickup.addComponent(new OnPointerDown(() => {
  // Code to run when pickup is clicked
}))
engine.addEntity(pickup)"
/* script of a music game where music changes when player collides cube */,"import { engine } from '@decentraland/ecs'
import { Sound } from '@decentraland/sound'

// Load sounds
const sound1 = new Sound('sounds/sound1.mp3', true)
const sound2 = new Sound('sounds/sound2.mp3', true)

// Create entities
const player = new Entity()
player.addComponent(new Transform({ position: new Vector3(5, 0, 5) }))
engine.addEntity(player)

const cube = new Entity()
cube.addComponent(new Transform({ position: new Vector3(5, 1, 5) }))
cube.addComponent(new BoxShape())
cube.addComponent(new Material())
engine.addEntity(cube)

// Play sound 1 when cube is clicked
cube.addComponent(new OnClick(() => {
  sound1.playOnce()
}))

// Move player forward when W key is pressed
const input = Input.instance
input.subscribe('BUTTON_DOWN', ActionButton.PRIMARY, false, e => {
  if (e.hit.length > 0) {
    player.getComponent(Transform).translate(Vector3.FORWARD, 1)
  }
})

// Play sound 2 when player collides with cube
const collision = new utils.TriggerComponent(
  new utils.TriggerBoxShape(
    new Vector3(1, 1, 1),
    new Vector3(5, 1, 5)
  ),
  {
    onCameraEnter: () => {
      sound2.playOnce()
    }
  }
)
player.addComponent(collision)

// Update loop
engine.addSystem(new utils.IntervalSystem(500, () => {
  cube.getComponent(Material).albedoColor = Color3.Random()
}))"
/* script for customized text input */,"import { TextInput } from 'decentraland-ui'

const input = new TextInput()
input.width = '200px'
input.height = '30px'
input.placeholder = 'Enter your name...'
input.onTextChange = (text) => {
  log(text)
}
input.element.style.border = '1px solid gray'
input.element.style.borderRadius = '5px'
input.element.style.padding = '5px'
engine.addEntity(input)"
/* script for function move paddle */,"function movePaddle(paddle: Entity, direction: Vector3) {
  let transform = paddle.getComponent(Transform)
  let newPosition = transform.position.add(direction.scale(PADDLE_SPEED * dt))

  if (newPosition.x > 8.5 || newPosition.x < -8.5) {
    newPosition.x = transform.position.x
  }

  transform.position = newPosition
}"
/* script for simple collectible game */,"import { executeTask } from 'decentraland-ecs/src'
import { engine } from 'decentraland-ecs/src'
import { Random } from 'decentraland-ecs/src'
import { Component, System } from 'decentraland-ecs/src'
import { GLTFShape, Transform, Vector3 } from 'decentraland-ecs/src'
import utils from '../node_modules/decentraland-ecs-utils/index'

// A simple collectible coin with a value attached
@Component('coin')
export class Coin {
  value: number = 1
}

// A system that collects coins when the player touches them
export class CollectCoinSystem extends System {
  static queries = {
    coins: { components: [Coin, Transform] },
    player: { components: [Transform] },
  }

  update() {
    const { coins, player } = this.queries

    for (const entity of coins.entities) {
      const coinTransform = entity.getComponent(Transform)
      const playerTransform = player.first().getComponent(Transform)

      if (playerTransform.position.distanceTo(coinTransform.position) < 1) {
        // Add the coin value to the player's score
        const coin = entity.getComponent(Coin)
        log(`Picked up a coin worth ${coin.value}!`)
        executeTask(async () => {
          await utils.delay(100) // Wait a moment before destroying the coin
          engine.removeEntity(entity)
        })
      }
    }
  }
}

// Spawns a random coin every 2 seconds
export class CoinSpawnerSystem extends System {
  static coins: { gltf: GLTFShape; value: number }[] = [
    { gltf: new GLTFShape('models/coin.gltf'), value: 1 },
    { gltf: new GLTFShape('models/coin2.gltf'), value: 2 },
    { gltf: new GLTFShape('models/coin3.gltf'), value: 3 },
  ]

  timer: number = 0

  update(dt: number) {
    this.timer += dt

    if (this.timer > 2) {
      this.timer = 0

      const coin = CoinSpawnerSystem.coins[Random.int(0, CoinSpawnerSystem.coins.length - 1)]

      const coinEntity = new Entity()
      coinEntity.addComponentOrReplace(coin.gltf)
      coinEntity.addComponentOrReplace(new Coin())
      coinEntity.addComponentOrReplace(new Transform({ position: new Vector3(Random.float(-5, 5), 1, Random.float(-5, 5)) }))

      engine.addEntity(coinEntity)
    }
  }
}

// Add the systems to the engine
engine.addSystem(new CollectCoinSystem())
engine.addSystem(new CoinSpawnerSystem())"
/* script for randomized sky color */,"const sky = new Entity()
sky.addComponent(new Sky())

sky.addComponent(
  new utils.Delay(2000, () => {
    const randomColor = Color3.Random()
    sky.getComponent(Sky).color = randomColor
  })
)

engine.addEntity(sky)"
/* script for animated coin */,"const coin = new Entity()
coin.addComponent(new GLTFShape(""models/coin.glb""))
coin.addComponent(new Transform({
  position: new Vector3(5, 1, 5),
  scale: new Vector3(0.5, 0.5, 0.5)
}))
engine.addEntity(coin)

coin.addComponent(
  new utils.Delay(1000, () => {
    coin.addComponentOrReplace(new Animator())
    coin.getComponent(Animator).addClip(new AnimationState(""CoinAction""))
    coin.getComponent(Animator).getClip(""CoinAction"").play()
  })
)"
/* script for custom shader material */,"import { Entity, BoxShape, Material } from 'decentraland-ecs'

const customMaterial = new Material()
customMaterial.customShader = {
  vertex: `
    attribute vec3 position;
    attribute vec3 normal;
    attribute vec2 uv;
    uniform mat4 modelViewProjectionMatrix;
    uniform mat4 modelMatrix;
    uniform mat4 viewMatrix;
    varying vec2 vUV;
    void main() {
      vUV = uv;
      gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);
    }
  `,
  fragment: `
    precision mediump float;
    uniform float time;
    uniform vec2 resolution;
    varying vec2 vUV;
    void main() {
      vec3 color = vec3(1.0, 0.0, 0.0);
      gl_FragColor = vec4(color, 1.0);
    }
  `
}

const entity = new Entity()
entity.addComponent(new BoxShape())
entity.addComponent(customMaterial)
engine.addEntity(entity)"
/* script of funtion to display an image on a plane */,"import { Entity, Plane, Material, Texture } from 'decentraland-ecs'

const plane = new Entity()
const material = new Material()
material.albedoTexture = new Texture('path/to/image.png')
plane.addComponent(new Plane())
plane.addComponent(material)
engine.addEntity(plane)"
/* script of a box with moving up and down functions */,"import { engine, Entity, Transform, BoxShape } from 'decentraland-ecs'

// Create a box entity
const box = new Entity()
box.addComponent(new Transform({ position: new Vector3(5, 1, 5) }))
box.addComponent(new BoxShape())

// Add the entity to the engine
engine.addEntity(box)

// Move the box up and down
let direction = 1
const speed = 0.1

engine.addSystem(new class {
  update(dt: number) {
    const transform = box.getComponent(Transform)

    transform.position.y += speed * direction

    if (transform.position.y > 2) {
      direction = -1
    } else if (transform.position.y < 1) {
      direction = 1
    }
  }
})"
/* script of simple 2D game */,"import { engine } from '@dcl/ecs-scene-utils'

const background = new Entity()
background.addComponent(new PlaneShape())
background.addComponent(new Transform({ scale: new Vector3(100, 100, 1), rotation: Quaternion.Euler(90, 0, 0) }))
background.addComponent(new Material())
background.getComponent(Material).albedoColor = Color3.FromHexString('#9DBEBB')
engine.addEntity(background)

const player = new Entity()
player.addComponent(new PlaneShape())
player.addComponent(new Transform({ position: new Vector3(0, 1, 0) }))
player.addComponent(new Material())
player.getComponent(Material).albedoColor = Color3.Red()
engine.addEntity(player)

const moveSpeed = 2

class PlayerSystem {
  update(dt: number) {
    if (game.isActionPressed(""moveForward"")) {
      player.getComponent(Transform).translate(Vector3.Forward().scale(moveSpeed * dt))
    }
    if (game.isActionPressed(""moveBackward"")) {
      player.getComponent(Transform).translate(Vector3.Backward().scale(moveSpeed * dt))
    }
    if (game.isActionPressed(""moveLeft"")) {
      player.getComponent(Transform).translate(Vector3.Left().scale(moveSpeed * dt))
    }
    if (game.isActionPressed(""moveRight"")) {
      player.getComponent(Transform).translate(Vector3.Right().scale(moveSpeed * dt))
    }
  }
}

engine.addSystem(new PlayerSystem())"
/* script to create random color generator for entities */,"import { Vector3, Color4, Entity } from 'decentraland-ecs'

// function to generate a random color
function generateRandomColor(): Color4 {
  const r = Math.random()
  const g = Math.random()
  const b = Math.random()
  return new Color4(r, g, b, 1)
}

// create a new entity with a random color
const randomEntity = new Entity()
randomEntity.addComponentOrReplace(new BoxShape())
randomEntity.addComponentOrReplace(new Transform({ position: new Vector3(5, 0, 5) }))
randomEntity.addComponentOrReplace(new Material())
randomEntity.getComponent(Material).albedoColor = generateRandomColor()
engine.addEntity(randomEntity)"
/* script for UI button that changes color when hovered over */,"import { UIContainerRect, UIButton, UICanvas, Color4 } from 'decentraland-ecs'

// create the canvas
const canvas = new UICanvas()
canvas.width = 256
canvas.height = 256

// create the button
const button = new UIButton(canvas)
button.width = '100%'
button.height = '100%'
button.onClick = new OnClick(() => {
  log('Button clicked!')
})

// create the button background
const buttonBackground = new UIContainerRect(canvas)
buttonBackground.adaptHeight = true
buttonBackground.adaptWidth = true
buttonBackground.isPointerBlocker = true
buttonBackground.color = new Color4(1, 1, 1, 1)
buttonBackground.opacity = 0.6

// change button background color when hovered over
buttonBackground.onHoverEnter = () => {
  buttonBackground.color = new Color4(0.5, 0.5, 0.5, 1)
}
buttonBackground.onHoverExit = () => {
  buttonBackground.color = new Color4(1, 1, 1, 1)
}"
/* script to run a coroutine like task */,"// Define a task that runs for a certain number of frames
function* waitFrames(count: number) {
  for (let i = 0; i < count; i++) {
    yield
  }
}

// Define a function that uses the task to animate an entity
function animateEntity(entity: Entity) {
  executeTask(async function() {
    const position = entity.getComponent(Position)
    for (let i = 0; i < 10; i++) {
      position.x += 1
      await waitFrames(10)
    }
  })
}

// Create and animate an entity
const entity = new Entity()
const position = new Position()
position.x = 0
position.y = 0
position.z = 0
entity.addComponent(position)
engine.addEntity(entity)
animateEntity(entity)"
/* script to create an entity with multiple components */,"// Define the components
@Component('position')
export class Position {
  x: number = 0
  y: number = 0
  z: number = 0
}

@Component('color')
export class Color {
  r: number = 1
  g: number = 1
  b: number = 1
}

// Create an entity with multiple components
const entity = new Entity()
const position = new Position()
position.x = 1
position.y = 2
position.z = 3
const color = new Color()
color.r = 0
color.g = 1
color.b = 0
entity.addComponent(position)
entity.addComponent(color)
engine.addEntity(entity)"
/* script to hendle user input */,"// Define a function that moves an entity based on keyboard input
function moveEntity(entity: Entity) {
  const speed = 0.1
  const transform = entity.getComponent(Transform)
  const input = Input.instance
  const left = input.getKeyDown(Key.A)
  const right = input.getKeyDown(Key.D)
  const up = input.getKeyDown(Key.W)
  const down = input.getKeyDown(Key.S)
  if (left) {
    transform.translate(Vector3.left().scale(speed))
  }
  if (right) {
    transform.translate(Vector3.right().scale(speed))
  }
  if (up) {
    transform.translate(Vector3.up().scale(speed))
  }
  if (down) {
    transform.translate(Vector3.down().scale(speed))
  }
}

// Create an entity and move it based on user input
const entity = new Entity()
const shape = new SphereShape()
const material = new Material()
material.albedoColor = Color3.Blue()
const transform = new Transform()
transform.scale.setAll(0.5)
entity.addComponent(shape)
entity.addComponent(material)
entity.addComponent(transform)
engine.addEntity(entity)
engine.addSystem(new UpdateSystem(() => {
  moveEntity(entity)
}))"
"/* script wherewe create an entity to represent the player with a cube for the head and a sphere for the body. We also add a point light to follow the player and a sound to play when the player moves. We then define a function to move the player and play a sound when the player presses the W, A, S, or D keys on the keyboard. Finally, we add a system to listen for keyboard events and move the player accordingly","import { engine } from '@decentraland/ecs'
import { Sound } from '@decentraland/sound'
import utils from '../node_modules/decentraland-ecs-utils/index'

// Create an entity to represent the player
const player = new Entity()

// Create a cube to represent the player's head
const head = new Entity()
head.addComponent(new BoxShape())
head.addComponent(new Transform({
  position: new Vector3(0, 1.5, 0)
}))
player.addChild(head)

// Create a sphere to represent the player's body
const body = new Entity()
body.addComponent(new SphereShape())
body.addComponent(new Transform({
  position: new Vector3(0, 0.5, 0)
}))
player.addChild(body)

// Create a light to follow the player
const light = new Entity()
light.addComponent(new PointLight())
light.setParent(player)

// Create a sound to play when the player moves
const sound = new Sound('sounds/footsteps.mp3')

// Move the player and play a sound when a key is pressed
const movePlayer = (e: any) => {
  if (e.key === 'w') {
    player.getComponent(Transform).translate(Vector3.Forward().scale(0.1))
    sound.playOnce()
  } else if (e.key === 's') {
    player.getComponent(Transform).translate(Vector3.Backward().scale(0.1))
    sound.playOnce()
  } else if (e.key === 'a') {
    player.getComponent(Transform).translate(Vector3.Left().scale(0.1))
    sound.playOnce()
  } else if (e.key === 'd') {
    player.getComponent(Transform).translate(Vector3.Right().scale(0.1))
    sound.playOnce()
  }
}

// Listen for keyboard events to move the player
engine.addSystem(new utils.IntervalSystem(16, () => {
  if (Keyboard.isKeyDown('w') || Keyboard.isKeyDown('s') || Keyboard.isKeyDown('a') || Keyboard.isKeyDown('d')) {
    movePlayer({ key: Keyboard.lastKeyDown })
  }
}))"
/* script for a spinning system with 5 cubes of different speed */,"// Define a custom component for a spinning cube
@Component('spinningCube')
export class SpinningCube {
  speed: number // Speed at which the cube will spin

  constructor(speed: number) {
    this.speed = speed
  }
}

// Define a custom system to spin the cubes
export class SpinningSystem {
  update(dt: number) {
    // Get all the entities with the 'spinningCube' component
    const entities = engine.getComponentGroup(SpinningCube)

    // Spin each cube according to its speed
    for (const entity of entities.entities) {
      const cube = entity.getComponent(Transform)
      const spinning = entity.getComponent(SpinningCube)
      cube.rotate(Vector3.Up(), spinning.speed * dt)
    }
  }
}

// Create 5 spinning cubes with random speeds
for (let i = 0; i < 5; i++) {
  const cube = new Entity()
  cube.addComponent(new BoxShape())
  cube.addComponent(new Transform({
    position: new Vector3(-2.5 + i, 0, 5),
    scale: new Vector3(0.5, 0.5, 0.5)
  }))
  cube.addComponent(new SpinningCube(Math.random() * 10))
  engine.addEntity(cube)
}

// Add the spinning system to the engine
engine.addSystem(new SpinningSystem())"
"/* script for multiplayer game with peer manager. This example sets up a simple multiplayer game where the player can move their avatar using the WASD keys. It uses the PeerManager and PeerAvatar classes from the decentraland-ecs-utils library to manage the multiplayer network and create avatars for each player. The player entity and avatar are defined first, and then the other player entity and avatar are defined with a null peer ID until a peer connects. The movePlayer function handles the player's movement, and the update function is called every frame to update both avatars. Finally, the PeerManager is used to connect to the network and listen for peer connections. Once a peer connects, the other player avatar's peer ID is set and it becomes fully functional in the game.*/","import { executeTask } from 'decentraland-ecs/src'
import { PeerManager } from 'decentraland-ecs-utils/peerManager'
import { PeerAvatar } from 'decentraland-ecs-utils/peerAvatar'

// Setup the multiplayer network
const peerManager = new PeerManager()

// Define the player entity
const player = new Entity()
player.addComponent(new Transform({
  position: new Vector3(5, 1, 5)
}))
engine.addEntity(player)

// Define the player avatar
const playerAvatar = new PeerAvatar({
  peerId: peerManager.peerId,
  displayName: 'Player 1',
  position: player.getComponent(Transform).position
})
executeTask(async () => {
  await playerAvatar.waitForAvatar()
  engine.addEntity(playerAvatar.entity)
})

// Define the other player entity
const otherPlayer = new Entity()
otherPlayer.addComponent(new Transform({
  position: new Vector3(10, 1, 10)
}))
engine.addEntity(otherPlayer)

// Define the other player avatar
const otherPlayerAvatar = new PeerAvatar({
  peerId: null,
  displayName: 'Player 2',
  position: otherPlayer.getComponent(Transform).position
})
executeTask(async () => {
  await otherPlayerAvatar.waitForAvatar()
  engine.addEntity(otherPlayerAvatar.entity)
})

// Move the player avatar
const speed = 2
const movePlayer = () => {
  if (Input.isKeyPressed('w')) {
    playerAvatar.entity.getComponent(Transform).translate(Vector3.Forward().scale(speed * dt))
  } else if (Input.isKeyPressed('s')) {
    playerAvatar.entity.getComponent(Transform).translate(Vector3.Backward().scale(speed * dt))
  }
  if (Input.isKeyPressed('a')) {
    playerAvatar.entity.getComponent(Transform).translate(Vector3.Left().scale(speed * dt))
  } else if (Input.isKeyPressed('d')) {
    playerAvatar.entity.getComponent(Transform).translate(Vector3.Right().scale(speed * dt))
  }
}

// Update the player and other player avatars
const update = (dt: number) => {
  movePlayer()
  playerAvatar.update()
  otherPlayerAvatar.update()
}
engine.addSystem(new utils.UpdateSystem(update))

// Connect to the network and listen for peers
peerManager.connect('wss://my-server.com')
peerManager.on('peer', peer => {
  console.log(`New peer connected with ID ${peer.id}`)
  // Set the other player avatar's peer ID once connected
  otherPlayerAvatar.setPeerId(peer.id)
})"
/* script for gameboard entity 3x3 with clickable tiles */,"import { engine, Entity, Transform, BoxShape } from 'decentraland-ecs/src'

// Create a game board entity with 3 rows and 3 columns
const gameBoard = new Entity()
gameBoard.addComponent(new Transform({ position: new Vector3(5, 0, 5) }))
const boardSize = 3
for (let x = 0; x < boardSize; x++) {
  for (let z = 0; z < boardSize; z++) {
    const tile = new Entity()
    tile.addComponent(new Transform({ position: new Vector3(x - 1, 0, z - 1) }))
    tile.addComponent(new BoxShape())
    tile.addComponent(
      new OnClick(() => {
        // Check if the clicked tile is next to an empty space
        const emptySpace = gameBoard.children.find((child) => child.name === 'empty-space')
        if (
          (emptySpace.getComponent(Transform).position.x === tile.getComponent(Transform).position.x &&
            Math.abs(emptySpace.getComponent(Transform).position.z - tile.getComponent(Transform).position.z) === 1) ||
          (emptySpace.getComponent(Transform).position.z === tile.getComponent(Transform).position.z &&
            Math.abs(emptySpace.getComponent(Transform).position.x - tile.getComponent(Transform).position.x) === 1)
        ) {
          // Move the clicked tile to the empty space
          tile.getComponent(Transform).position = emptySpace.getComponent(Transform).position
          // Move the empty space to the previous position of the clicked tile
          emptySpace.getComponent(Transform).position = new Vector3(x - 1, 0, z - 1)
        }
      })
    )
    gameBoard.addChild(tile)
  }
}

// Create an empty space entity to use as a reference for movement
const emptySpace = new Entity()
emptySpace.name = 'empty-space'
emptySpace.addComponent(new Transform({ position: new Vector3(1, 0, 1) }))
gameBoard.addChild(emptySpace)

// Add the game board to the engine
engine.addEntity(gameBoard)"
/* script for virtual art gallery */,"import { 
  Scene, 
  Entity, 
  Plane, 
  Material, 
  Texture, 
  Vector3 
} from 'decentraland-ecs'

const WALL_COLOR = Color3.FromHexString('#ffffff')
const WALL_HEIGHT = 2
const WALL_WIDTH = 8
const WALL_DEPTH = 0.1
const FLOOR_SIZE = 20
const ARTWORK_SPACING = 1.5

const artworkTextures = [  new Texture('artwork1.png'),  new Texture('artwork2.png'),  new Texture('artwork3.png')]

function createWall(position: Vector3, rotation: Vector3) {
  const wall = new Entity()
  wall.addComponent(new Transform({
    position: position,
    rotation: Quaternion.Euler(rotation.x, rotation.y, rotation.z),
    scale: new Vector3(WALL_WIDTH, WALL_HEIGHT, WALL_DEPTH)
  }))
  wall.addComponent(new Plane())
  const material = new Material()
  material.albedoColor = WALL_COLOR
  wall.addComponent(material)
  engine.addEntity(wall)
}

function createArtwork(position: Vector3, index: number) {
  const artwork = new Entity()
  artwork.addComponent(new Transform({
    position: position,
    scale: new Vector3(1.5, 1.5, 1.5)
  }))
  const material = new Material()
  material.albedoTexture = artworkTextures[index]
  artwork.addComponent(material)
  engine.addEntity(artwork)
}

function createGallery() {
  createWall(new Vector3(0, WALL_HEIGHT / 2, -WALL_WIDTH / 2), new Vector3(0, 0, 0))
  createWall(new Vector3(0, WALL_HEIGHT / 2, WALL_WIDTH / 2), new Vector3(0, 180, 0))
  createWall(new Vector3(WALL_WIDTH / 2, WALL_HEIGHT / 2, 0), new Vector3(0, -90, 0))
  createWall(new Vector3(-WALL_WIDTH / 2, WALL_HEIGHT / 2, 0), new Vector3(0, 90, 0))
  for (let i = 0; i < artworkTextures.length; i++) {
    const artworkPosition = new Vector3(
      -FLOOR_SIZE / 2 + ARTWORK_SPACING + i * ARTWORK_SPACING, 
      WALL_HEIGHT / 2, 
      -WALL_WIDTH / 2 + ARTWORK_SPACING
    )
    createArtwork(artworkPosition, i)
  }
}

const galleryScene = new Scene()

createGallery()

galleryScene.registerBeforeRender(() => {
  // Rotate artwork
  const artworkEntities = galleryScene.entities.filter(entity => entity.name === 'Artwork')
  artworkEntities.forEach(entity => {
    entity.getComponent(Transform).rotate(Vector3.Up(), 0.1)
  })
})

// Set the background color of the scene
galleryScene.setClearColor(Color4.FromHexString('#6fbfff'))

// Set the camera position
const camera = new Entity()
camera.addComponent(new Camera())
camera.addComponent(new Transform({
  position: new Vector3(0, 2, -6),
  rotation: Quaternion.Euler(10, 0, 0)
}))
galleryScene.addEntity(camera)

// Activate the scene
engine.addScene(galleryScene)"
/* script for weather forecasting app */,"import { UIContainerRect, UIText, UIInputText } from 'dcl/ui-kit';
import { Scene } from 'dcl/scenes';
import { WeatherAPI } from './weatherAPI';

const weatherAPI = new WeatherAPI();

const container = new UIContainerRect(0, 0, '100%', '100%');
container.visible = false;

const title = new UIText(container, { value: 'Weather Forecast', fontSize: 24, fontWeight: 'bold', color: '#000000' });
title.positionY = 20;

const inputContainer = new UIContainerRect(0, 60, '100%', 60);
inputContainer.color = '#f5f5f5';

const inputLabel = new UIText(inputContainer, { value: 'Enter a location:', fontSize: 18, fontWeight: 'bold', color: '#000000' });
inputLabel.positionX = 20;

const input = new UIInputText(inputContainer, { fontSize: 18, placeholder: 'e.g. New York, NY' });
input.positionX = 180;

const submitButton = new UIButton(inputContainer, { label: 'Get Weather' });
submitButton.positionX = 380;
submitButton.onClick = async () => {
  const location = input.value;
  const data = await weatherAPI.fetchWeatherData(location);
  // Display weather data on the screen
};

// Add the container to the scene
Scene.current.addUI(container);"
/* script for weather API with fetch function */,"export class WeatherAPI {
  private apiKey: string = 'YOUR_API_KEY_HERE';

  async fetchWeatherData(location: string): Promise<any> {
    const url = `https://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${this.apiKey}`;
    const response = await fetch(url);
    const data = await response.json();
    return data;
  }
}"
/* script for text to speech translation */ ,"import { SpeechSynthesis } from 'decentraland-ecs/systems/SpeechSynthesis'

// Define a list of available languages
const languages = [
  { code: 'en', name: 'English' },
  { code: 'es', name: 'Spanish' },
  { code: 'fr', name: 'French' },
  { code: 'de', name: 'German' }
]

// Create a dropdown menu to select the target language
const languageSelect = new UI.Select()
languages.forEach((language) => {
  languageSelect.addOption(language.name, language.code)
})
languageSelect.value = 'en' // Set the default language to English
languageSelect.positionY = 0.2
UI.instance.addControl(languageSelect)

// Create a text input for the source text
const sourceText = new UI.InputText()
sourceText.width = '60%'
sourceText.placeholder = 'Enter text to translate'
sourceText.positionY = 0.4
UI.instance.addControl(sourceText)

// Create a button to trigger the translation
const translateButton = new UI.Button('Translate')
translateButton.width = '30%'
translateButton.height = '10%'
translateButton.positionY = 0.6
UI.instance.addControl(translateButton)

// Create a function to handle the translation
function translateText() {
  const targetLanguage = languageSelect.value
  const textToTranslate = sourceText.text

  // Use the Web Speech API to synthesize speech from the translated text
  SpeechSynthesis.speak(textToTranslate, targetLanguage)
}

// Add the translateText function to the button click event
translateButton.onClick = new OnClick(translateText)"
/* script for loading NLP model from spacy */,"npm install spacy
import * as spacy from 'spacy';

// Load the pre-trained NLP model from spaCy
const nlp = await spacy.load('en_core_web_sm');

// Example responses for the chatbot
const responses = {
  'greeting': 'Hello! How can I help you today?',
  'goodbye': 'Goodbye! Have a great day.',
  'unknown': 'I'm sorry, I didn't understand what you said. Can you please rephrase?'
};
"
/* script to handle incoming user messages */,"// Function to handle incoming user messages
async function handleMessage(message: string) {
  // Use the NLP model to analyze the user's message
  const doc = await nlp(message);

  // Check if the message is a greeting
  if (doc.hasGreeting) {
    return responses['greeting'];
  }

  // Check if the message is a goodbye
  if (doc.hasGoodbye) {
    return responses['goodbye'];
  }

  // If we didn't recognize the message, respond with an unknown message
  return responses['unknown'];
}"
/* script for chat interface */,"// Set up the chat interface
const chat = document.getElementById('chat');
const input = document.getElementById('input');
const button = document.getElementById('button');

// Function to handle sending a message to the chatbot
async function sendMessage() {
  // Get the user's message from the input field
  const message = input.value;

  // Clear the input field
  input.value = '';

  // Add the user's message to the chat
  const userMessage = document.createElement('div');
  userMessage.className = 'message';
  userMessage.innerText = 'You: ' + message;
  chat.appendChild(userMessage);

  // Get the chatbot's response to the user's message
  const chatbotMessage = document.createElement('div');
  chatbotMessage.className = 'message';
  chatbotMessage.innerText = 'Chatbot: ' + await handleMessage(message);
  chat.appendChild(chatbotMessage);
}

// Add an event listener to the send button
button.addEventListener('click', sendMessage);"
/* script for randomized maze generator using recursive backtracking algorithm */,"const CELL_SIZE = 4;
const MAZE_SIZE = 25;
const CELL_COLOR = Color3.White();
const WALL_COLOR = Color3.Black();

let maze: Array<Array<boolean>> = [];

function generateMaze() {
  // Create the initial maze with all walls
  maze = Array.from(Array(MAZE_SIZE), () => new Array(MAZE_SIZE).fill(true));

  // Starting point
  let x = Math.floor(Math.random() * MAZE_SIZE);
  let y = Math.floor(Math.random() * MAZE_SIZE);
  carvePath(x, y);

  // Display the maze
  for (let i = 0; i < MAZE_SIZE; i++) {
    for (let j = 0; j < MAZE_SIZE; j++) {
      if (maze[i][j]) {
        const wall = new Entity();
        wall.addComponent(new BoxShape());
        wall.addComponent(new Transform({
          position: new Vector3(i * CELL_SIZE, 0, j * CELL_SIZE),
          scale: new Vector3(CELL_SIZE, CELL_SIZE, CELL_SIZE)
        }));
        wall.addComponent(new Material());
        wall.getComponent(Material).albedoColor = WALL_COLOR;
        engine.addEntity(wall);
      } else {
        const cell = new Entity();
        cell.addComponent(new BoxShape());
        cell.addComponent(new Transform({
          position: new Vector3(i * CELL_SIZE, 0, j * CELL_SIZE),
          scale: new Vector3(CELL_SIZE, CELL_SIZE, CELL_SIZE)
        }));
        cell.addComponent(new Material());
        cell.getComponent(Material).albedoColor = CELL_COLOR;
        engine.addEntity(cell);
      }
    }
  }
}

function carvePath(x: number, y: number) {
  // Mark the current cell as visited
  maze[x][y] = false;

  // Create a list of the neighbors
  let neighbors = [];
  if (x > 0 && maze[x-1][y]) neighbors.push({x: x-1, y: y});
  if (y > 0 && maze[x][y-1]) neighbors.push({x: x, y: y-1});
  if (x < MAZE_SIZE - 1 && maze[x+1][y]) neighbors.push({x: x+1, y: y});
  if (y < MAZE_SIZE - 1 && maze[x][y+1]) neighbors.push({x: x, y: y+1});

  // Shuffle the list of neighbors randomly
  neighbors.sort(() => Math.random() - 0.5);

  // Recursively carve paths to unvisited neighbors
  for (let neighbor of neighbors) {
    if (maze[neighbor.x][neighbor.y]) {
      if (neighbor.x < x) { maze[x][y-1] = false; }
      if (neighbor.x > x) { maze[x][y+1] = false; }
      if (neighbor.y < y) { maze[x-1][y] = false; }
      if (neighbor.y > y) { maze[x+1][y] = false; }
      carvePath(neighbor.x, neighbor.y);
    }
  }
}

// Generate the maze when the scene loads
generateMaze();"
/* script for interactive quiz */,"import { Scene, Vector3, Quaternion } from 'decentraland-api';

// Define the questions and answers
const questions = [
  {
    question: 'What is the capital of France?',
    answers: [
      { text: 'Paris', correct: true },
      { text: 'Rome', correct: false },
      { text: 'Madrid', correct: false },
      { text: 'London', correct: false },
    ],
  },
  {
    question: 'What is the tallest mountain in the world?',
    answers: [
      { text: 'K2', correct: false },
      { text: 'Mount Everest', correct: true },
      { text: 'Makalu', correct: false },
      { text: 'Cho Oyu', correct: false },
    ],
  },
  {
    question: 'What is the largest country in the world?',
    answers: [
      { text: 'Canada', correct: false },
      { text: 'China', correct: false },
      { text: 'United States', correct: false },
      { text: 'Russia', correct: true },
    ],
  },
];

// Define the scene
export default class QuizScene {
  scene: Scene;
  questionIndex: number = 0;
  score: number = 0;

  constructor() {
    this.scene = new Scene();
    this.scene.onActivate(() => this.startQuiz());
  }

  async startQuiz() {
    // Create the question text and answer buttons
    const question = questions[this.questionIndex].question;
    const answers = questions[this.questionIndex].answers;
    const questionText = new UIText(question);
    questionText.width = '100%';
    questionText.height = '50%';
    questionText.vAlign = 'center';
    questionText.hAlign = 'center';
    this.scene.addUI(questionText);

    const buttonSize = new Vector3(1, 0.2, 0.1);
    const buttonOffset = new Vector3(0, -0.5, 0);
    for (let i = 0; i < answers.length; i++) {
      const answer = answers[i];
      const answerButton = new UIButton(answer.text);
      answerButton.width = buttonSize.x;
      answerButton.height = buttonSize.y;
      answerButton.position = new Vector3(0, -i - 1, 0).add(buttonOffset);
      answerButton.onClick = new OnClick(() => {
        if (answer.correct) {
          this.score++;
        }
        this.questionIndex++;
        if (this.questionIndex < questions.length) {
          this.startQuiz();
        } else {
          this.endQuiz();
        }
      });
      this.scene.addUI(answerButton);
    }
  }

  async endQuiz() {
    // Display the final score
    const scoreText = new UIText(`You scored ${this.score} out of ${questions.length}!`);
    scoreText.width = '100%';
    scoreText.height = '50%';
    scoreText.vAlign = 'center';
    scoreText.hAlign = 'center';
    this.scene.addUI(scoreText);
  }
}"
/* script for RPG game */,"@Component('Player')
export class Player {
  hp: number = 100;
  attackPower: number = 10;
  isPlayerTurn: boolean = true;
}

@Component('Enemy')
export class Enemy {
  hp: number = 50;
  attackPower: number = 5;
}

export class RPGSystem {
  update(dt: number) {
    // Get player and enemy entities
    const player = engine.getComponentGroup(Player)[0];
    const enemy = engine.getComponentGroup(Enemy)[0];
    
    if (player.isPlayerTurn) {
      // Player attacks
      const attackDamage = Math.floor(Math.random() * player.attackPower);
      enemy.hp -= attackDamage;
      log(`Player deals ${attackDamage} damage to enemy!`);
    } else {
      // Enemy attacks
      const attackDamage = Math.floor(Math.random() * enemy.attackPower);
      player.hp -= attackDamage;
      log(`Enemy deals ${attackDamage} damage to player!`);
    }
    
    // Check for win/loss condition
    if (player.hp <= 0) {
      log('Player has been defeated!');
    } else if (enemy.hp <= 0) {
      log('Enemy has been defeated!');
    } else {
      // Switch turns
      player.isPlayerTurn = !player.isPlayerTurn;
    }
  }
}

// Create player and enemy entities
const playerEntity = new Entity();
playerEntity.addComponent(new Player());
engine.addEntity(playerEntity);

const enemyEntity = new Entity();
enemyEntity.addComponent(new Enemy());
engine.addEntity(enemyEntity);

// Add RPGSystem to engine
engine.addSystem(new RPGSystem());"
/* script for video player */,"import { VideoTexture } from 'decentraland-ecs';

const videoUrl = 'https://example.com/video.mp4';

// Create a plane entity to display the video
const plane = new Entity();
const planeShape = new PlaneShape();
plane.addComponent(planeShape);
engine.addEntity(plane);

// Create the video texture
const videoTexture = new VideoTexture(videoUrl);
videoTexture.play();
videoTexture.loop = true;

// Assign the video texture to the plane's material
const material = new Material();
material.texture = videoTexture;
planeShape.material = material;

// Create the video controls
const playButton = new Entity();
playButton.addComponent(new BoxShape());
playButton.addComponent(new Transform({ position: new Vector3(-0.5, -0.5, 0) }));
playButton.addComponent(new OnClick(() => {
  videoTexture.play();
}));
engine.addEntity(playButton);

const pauseButton = new Entity();
pauseButton.addComponent(new BoxShape());
pauseButton.addComponent(new Transform({ position: new Vector3(0, -0.5, 0) }));
pauseButton.addComponent(new OnClick(() => {
  videoTexture.pause();
}));
engine.addEntity(pauseButton);

const volumeSlider = new Entity();
volumeSlider.addComponent(new CylinderShape());
volumeSlider.addComponent(new Transform({ position: new Vector3(0.5, -0.5, 0) }));
volumeSlider.addComponent(new OnClick(e => {
  const distance = e.hit.distance;
  const maxDistance = 1; // TODO: Adjust this based on the size of the slider
  const volume = distance / maxDistance;
  videoTexture.volume = volume;
}));
engine.addEntity(volumeSlider);"
/* script for a game where player must unlock a door by finding a hidden key in the scene */,"import { Scene } from 'decentraland-api'

const doorPosition = new Vector3(5, 0, 5)
const keyPosition = new Vector3(10, 0, 10)
const doorRotation = Quaternion.Euler(0, 45, 0)

const scene = new Scene()

// Create the door and key entities
const door = new Entity()
door.addComponent(new GLTFShape('models/door.glb'))
door.addComponent(new Transform({ position: doorPosition, rotation: doorRotation }))
scene.addEntity(door)

const key = new Entity()
key.addComponent(new GLTFShape('models/key.glb'))
key.addComponent(new Transform({ position: keyPosition }))
scene.addEntity(key)

let keyPickedUp = false

// Create a trigger box around the key
const keyTrigger = new Entity()
keyTrigger.addComponent(new BoxShape())
keyTrigger.addComponent(new Transform({ position: keyPosition, scale: new Vector3(2, 2, 2) }))
keyTrigger.addComponent(
  new utils.TriggerComponent(new utils.TriggerBoxShape(new Vector3(2, 2, 2)), {
    onCameraEnter: () => {
      if (!keyPickedUp) {
        keyPickedUp = true
        key.getComponent(GLTFShape).visible = false
      }
    }
  })
)
scene.addEntity(keyTrigger)

// Create a trigger box around the door
const doorTrigger = new Entity()
doorTrigger.addComponent(new BoxShape())
doorTrigger.addComponent(new Transform({ position: doorPosition, scale: new Vector3(2, 2, 2) }))
doorTrigger.addComponent(
  new utils.TriggerComponent(new utils.TriggerBoxShape(new Vector3(2, 2, 2)), {
    onCameraEnter: () => {
      if (keyPickedUp) {
        door.getComponent(GLTFShape).visible = false
      }
    }
  })
)
scene.addEntity(doorTrigger)"
"/* script for maze game with timeout, need to find end of maze before end of time */","import { delay } from 'decentraland-ecs/src/utils/time'

const MAZE_SIZE = 20 // size of the maze
const TIMEOUT_DURATION = 60 // seconds
const MOVE_INTERVAL = 250 // milliseconds

@Component('mazePlayer')
export class MazePlayer {
  direction: Vector3 = Vector3.Forward()

  constructor(public maze: Maze, public speed: number) {}
}

export class MazeSystem {
  maze: Maze
  player: Entity
  startPosition: Vector3
  goalPosition: Vector3
  timer: number = TIMEOUT_DURATION

  constructor(maze: Maze) {
    this.maze = maze
  }

  spawnPlayer(): void {
    const player = new Entity()
    player.addComponent(new Transform({ position: this.startPosition }))
    player.addComponent(new BoxShape())
    player.addComponent(new MazePlayer(this.maze, 3))
    engine.addEntity(player)
    this.player = player
  }

  spawnGoal(): void {
    const goal = new Entity()
    goal.addComponent(new Transform({ position: this.goalPosition }))
    goal.addComponent(new BoxShape())
    engine.addEntity(goal)
  }

  updateTimer(): void {
    if (this.timer === 0) {
      // End game due to timeout
      this.gameOver(false)
    } else {
      this.timer -= 1
      log(`Time left: ${this.timer}`)
    }
  }

  movePlayer(player: MazePlayer): void {
    if (player.direction) {
      const newPos = player.maze.tryMove(player.direction, player.speed, player)
      if (newPos) {
        player.entity.getComponent(Transform).position = newPos
        if (newPos.equals(this.goalPosition)) {
          // End game with win condition
          this.gameOver(true)
        }
      }
    }
  }

  startGame(): void {
    this.spawnPlayer()
    this.spawnGoal()
    this.startPosition = this.maze.getStartPosition()
    this.goalPosition = this.maze.getGoalPosition()
    this.timer = TIMEOUT_DURATION
    const intervalId = setInterval(() => this.updateTimer(), 1000)
    const moveId = setInterval(() => this.movePlayer(this.player.getComponent(MazePlayer)), MOVE_INTERVAL)
    log(`Starting game with timeout of ${TIMEOUT_DURATION} seconds.`)
    delay(TIMEOUT_DURATION * 1000).then(() => {
      clearInterval(intervalId)
      clearInterval(moveId)
    })
  }

  gameOver(win: boolean): void {
    log(win ? ""You've won!"" : ""Timeout, you've lost!"")
    engine.removeEntity(this.player)
    this.player = null
  }
}

// Usage
const maze = new Maze(MAZE_SIZE, MAZE_SIZE)
const mazeSystem = new MazeSystem(maze)
mazeSystem.startGame()"
/* script for pool object */,"const pool = new ObjectPool(() => new Entity())

// Spawning an object from the pool
const obj = pool.get()
obj.addComponent(new Transform({ position: new Vector3(0, 0, 0) }))
engine.addEntity(obj)

// Returning an object to the pool
pool.recycle(obj)"
/* script for custom cursor */,"const cursor = new Entity()
cursor.addComponent(new GLTFShape('models/cursor.gltf'))
cursor.addComponent(new Transform())
engine.addEntity(cursor)

const input = Input.instance
input.cursorHidden = true

class CustomCursorSystem implements ISystem {
  update(dt: number) {
    const pos = input.mousePosition
    cursor.getComponent(Transform).position.set(pos.x, pos.y, 0)
  }
}

engine.addSystem(new CustomCursorSystem())"
/* script for moving parent entity with child entities */,"const parent = new Entity()
parent.addComponent(new Transform({ position: new Vector3(5, 0, 5) }))
engine.addEntity(parent)

const child1 = new Entity()
child1.addComponent(new BoxShape())
child1.setParent(parent)
child1.addComponent(
  new Transform({
    position: new Vector3(0, 1, 0),
    scale: new Vector3(2, 2, 2)
  })
)
engine.addEntity(child1)

const child2 = new Entity()
child2.addComponent(new SphereShape())
child2.setParent(parent)
child2.addComponent(
  new Transform({
    position: new Vector3(0, -1, 0),
    scale: new Vector3(1, 1, 1)
  })
)
engine.addEntity(child2)

const input = Input.instance
const speed = 5

class ParentMovementSystem implements ISystem {
  update(dt: number) {
    const parentTransform = parent.getComponent(Transform)
    const x = input.axisValue(""horizontal"") * dt * speed
    const y = input.axisValue(""vertical"") * dt * speed
    parentTransform.translate(new Vector3(x, 0, y))
  }
}

engine.addSystem(new ParentMovementSystem())"
/* script to create an NFT collection */,"// Create a new NFT collection
let collection = new NFTCollection(
  ""My Collection"",
  ""This is a collection of my unique NFTs"",
  ""https://example.com/mycollection/"",
  ""https://example.com/mycollection/thumbnail.jpg"",
  100,
  10,
  1
);

// Add some NFTs to the collection
collection.addNFT(
  new NFT(
    ""My First NFT"",
    ""This is my very first NFT"",
    ""https://example.com/mycollection/1"",
    ""https://example.com/mycollection/1.jpg"",
    ""https://example.com/mycollection/1.json""
  )
);

collection.addNFT(
  new NFT(
    ""My Second NFT"",
    ""This is my second NFT"",
    ""https://example.com/mycollection/2"",
    ""https://example.com/mycollection/2.jpg"",
    ""https://example.com/mycollection/2.json""
  )
);

// Mint the NFTs
let nfts = collection.mint();"
/* script to use NFTCollection contract */,"// Instantiate the NFTCollection contract
let nftCollection = new SmartContract(
  ""nftCollection"",
  ""https://example.com/contracts/nftCollection""
);

// Get the NFT collection ID
let collectionId = await nftCollection.call(""getCollectionId"");

// Mint a new NFT
await nftCollection.call(""mintNFT"", [collectionId, ""My NFT"", ""https://example.com/nfts/1""]);

// Get the total number of NFTs in the collection
let nftCount = await nftCollection.call(""getNFTCount"", [collectionId]);

// Get the metadata for a specific NFT
let nftMetadata = await nftCollection.call(""getNFTMetadata"", [collectionId, 1]);"
/* script for creating wearable item */,"// Create a new wearable item
let wearable = new WearableItem(
  ""My Wearable"",
  ""This is my awesome wearable item"",
  ""https://example.com/wearables/mywearable"",
  ""https://example.com/wearables/mywearable.png"",
  WearableItemRarity.Common,
  WearableItemBodyPart.LowerBody,
  WearableItemSlot.Pants
);

// Mint the wearable item
let wearableId = await wearable.mint();"
/* script for animated 3D robot */,"// Create a new entity with a 3D model
const entity = new Entity()
const gltfShape = new GLTFShape('models/Robot.glb')
entity.addComponentOrReplace(gltfShape)
engine.addEntity(entity)

// Set up animation variables
let t = 0
const dt = 0.1

// Animate the entity every frame
engine.addSystem(new class {
  update(dt: number) {
    // Update animation variables
    t += dt

    // Calculate new position and rotation
    const x = Math.sin(t) * 2
    const y = Math.cos(t) * 2
    const z = 0
    const rotation = Quaternion.Euler(0, t * 100, 0)

    // Set the entity's new position and rotation
    entity.setTranslation(new Vector3(x, y, z))
    entity.setRotation(rotation)
  }
})"
/* script to create a custom avatar */,"// Creating a custom avatar
const myAvatar = new Avatar()
myAvatar.displayName = ""My Avatar""
myAvatar.height = 1.8
myAvatar.color = Color3.Red()
myAvatar.addShape(ShapeId.Box, {position: new Vector3(0, 0.9, 0)})
myAvatar.addShape(ShapeId.Sphere, {position: new Vector3(0, 1.5, 0)})
myAvatar.addShape(ShapeId.Cylinder, {position: new Vector3(0, 2.3, 0)})
myAvatar.addShape(ShapeId.Cone, {position: new Vector3(0, 3, 0)})
engine.addEntity(myAvatar)"
/* script to create a random maze with powerups */,"const wall = new Entity()
wall.addComponent(new BoxShape())
wall.addComponent(new Material())
wall.getComponent(Material).albedoColor = Color3.Red()
wall.addComponent(new Transform({scale: new Vector3(1, 2, 1)}))

const ground = new Entity()
ground.addComponent(new PlaneShape())
ground.addComponent(new Material())
ground.getComponent(Material).albedoColor = Color3.Gray()
ground.addComponent(new Transform({scale: new Vector3(10, 1, 10)}))

const powerup = new Entity()
powerup.addComponent(new SphereShape())
powerup.addComponent(new Material())
powerup.getComponent(Material).albedoColor = Color3.Yellow()
powerup.addComponent(new Transform({scale: new Vector3(0.5, 0.5, 0.5)}))

const maze = new Entity()
maze.addComponent(new Transform({position: new Vector3(0, 0.5, 0)}))
maze.addComponent(new AudioSource(new AudioClip('sounds/powerup.ogg')))
maze.addComponent(new GLTFShape('models/maze.glb'))

const NUM_ROWS = 10
const NUM_COLS = 10
const MAZE_SIZE = 0.5
const WALL_HEIGHT = 2
const POWERUP_PROBABILITY = 0.1

for (let row = 0; row < NUM_ROWS; row++) {
  for (let col = 0; col < NUM_COLS; col++) {
    if (Math.random() < POWERUP_PROBABILITY) {
      const newPowerup = powerup.clone()
      newPowerup.addComponent(new Transform({
        position: new Vector3(
          (col - NUM_COLS / 2 + 0.5) * MAZE_SIZE,
          0.75,
          (row - NUM_ROWS / 2 + 0.5) * MAZE_SIZE
        )
      }))
      maze.addChild(newPowerup)
    }

    if (row === 0 || col === 0 || row === NUM_ROWS - 1 || col === NUM_COLS - 1) {
      const newWall = wall.clone()
      newWall.getComponent(Transform).position.set(
        (col - NUM_COLS / 2) * MAZE_SIZE,
        WALL_HEIGHT / 2,
        (row - NUM_ROWS / 2) * MAZE_SIZE
      )
      maze.addChild(newWall)
    }
  }
}

engine.addEntity(ground)
engine.addEntity(maze)"
/* script to add multiple textures to an entity */,"const textures: Texture[] = [
  new Texture(""https://example.com/texture1.png""),
  new Texture(""https://example.com/texture2.png""),
  new Texture(""https://example.com/texture3.png"")
];

const myEntity = new Entity();
myEntity.addComponent(new GLTFShape(""https://example.com/myModel.glb""));

// Add the textures to the entity
textures.forEach(texture => {
  const material = new Material();
  material.albedoTexture = texture;
  myEntity.addComponent(material);
});

engine.addEntity(myEntity);"
/* script to detect clicks on entities */,"const myEntity = new Entity();
myEntity.addComponent(new GLTFShape(""https://example.com/myModel.glb""));

myEntity.addComponent(
  new OnClick(() => {
    log(""My entity was clicked!"");
  })
);

engine.addEntity(myEntity);"
/* script for spawning entities around a circle */,"import { engine } from '@decentraland/ecs'

const circleRadius = 5
const entityCount = 10

for (let i = 0; i < entityCount; i++) {
  const angle = (i / entityCount) * 2 * Math.PI
  const entityX = circleRadius * Math.cos(angle)
  const entityZ = circleRadius * Math.sin(angle)

  const newEntity = new Entity()

  newEntity.addComponentOrReplace(new GLTFShape('models/my-model.glb'))
  newEntity.addComponentOrReplace(new Transform({
    position: new Vector3(entityX, 0, entityZ),
    rotation: Quaternion.Euler(0, angle * 180 / Math.PI, 0),
    scale: new Vector3(1, 1, 1)
  }))

  engine.addEntity(newEntity)
}
Example 5: Changing the color of an entity on click

typescript
Copy code
import { engine } from '@decentraland/ecs'
import { OnClick } from '@decentraland/TriggerSystem'

const myEntity = new Entity()
const material = new Material()
material.albedoColor = Color3.Red()

myEntity.addComponentOrReplace(new Box


"
/* script for NFT trading platform */,"import { Context, trading } from '@decentraland/RestrictedTypes'
import { create } from '@decentraland/transactions'

const contractAddress = '0xADDRESS'
const tokenId = 'TOKEN_ID'
const priceInMANA = 10

export function sellNFT(): void {
  const tx = create({ 
    type: ""smart-contract"", 
    params: [contractAddress, ""sell"", [tokenId], priceInMANA.toString()]
  })
  trading.executeOrder(tx, Context.blockchain.blockNumber + 1, Context.blockNumber + 20000)
}"
/* script for random NFT generator */,"pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/utils/Counters.sol"";

contract RandomNFTGenerator is ERC721 {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    struct NFT {
        uint256 id;
        string imageURI;
        string metadataURI;
    }

    mapping(uint256 => NFT) private _NFTs;

    constructor() ERC721(""RandomNFTGenerator"", ""RNG"") {}

    function generateNFT() public {
        _tokenIds.increment();
        uint256 newTokenId = _tokenIds.current();

        NFT memory nft;
        nft.id = newTokenId;
        nft.imageURI = generateImageURI();
        nft.metadataURI = generateMetadataURI();

        _NFTs[newTokenId] = nft;
        _mint(msg.sender, newTokenId);
    }

    function generateImageURI() private view returns (string memory) {
        // Generate a unique image URI
        // ...
        return ""https://ipfs.io/ipfs/QmcLsuu27pjVjKod5Q5BNt2yLo5kbrYmgYJ9Fd9uVdPWZn"";
    }

    function generateMetadataURI() private view returns (string memory) {
        // Generate a unique metadata URI
        // ...
        return ""https://ipfs.io/ipfs/QmcLsuu27pjVjKod5Q5BNt2yLo5kbrYmgYJ9Fd9uVdPWZn"";
    }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");

        NFT memory nft = _NFTs[tokenId];
        string memory baseURI = super.tokenURI(tokenId);
        return bytes(baseURI).length > 0
            ? string(abi.encodePacked(baseURI, nft.metadataURI))
            : """";
    }
}"
/* script for decentralised voting system */,"pragma solidity ^0.8.0;

contract Voting {
    mapping(address => bool) public voters;
    mapping(string => uint) public votes;
    string[] public options;
    address public owner;
    uint public totalVotes;

    constructor(string[] memory _options) {
        owner = msg.sender;
        options = _options;
    }

    function vote(string memory option) public {
        require(voters[msg.sender] == false, ""You have already voted."");
        require(isValidOption(option), ""Invalid voting option."");
        voters[msg.sender] = true;
        votes[option] += 1;
        totalVotes += 1;
    }

    function isValidOption(string memory option) public view returns(bool) {
        for(uint i = 0; i < options.length; i++) {
            if(keccak256(bytes(options[i])) == keccak256(bytes(option))) {
                return true;
            }
        }
        return false;
    }

    function getVoteCount(string memory option) public view returns(uint) {
        require(isValidOption(option), ""Invalid voting option."");
        return votes[option];
    }

    function getOptions() public view returns(string[] memory) {
        return options;
    }

    function getWinner() public view returns(string memory) {
        require(totalVotes > 0, ""No votes have been casted yet."");
        string memory winner = options[0];
        uint winningVoteCount = votes[options[0]];
        for(uint i = 1; i < options.length; i++) {
            if(votes[options[i]] > winningVoteCount) {
                winner = options[i];
                winningVoteCount = votes[options[i]];
            }
        }
        return winner;
    }

    function endVoting() public {
        require(msg.sender == owner, ""Only the owner can end the voting."");
        selfdestruct(payable(owner));
    }
}"
/* script for decentralised marketplace */,"// Smart contract
export async function sellItem(name: string, price: number): Promise<string> {
  const nft = await createNFT(name);
  const tokenId = await mint(nft);
  await setApprovalForAll(MARKETPLACE_ADDRESS, tokenId);
  await marketplace.sell(nft, tokenId, price);
  return `Item ${name} listed for ${price} MANA`;
}

export async function buyItem(itemAddress: string, tokenId: string): Promise<string> {
  const price = await marketplace.getPrice(itemAddress, tokenId);
  const balance = await getBalance();

  if (balance < price) {
    throw new Error('Insufficient balance');
  }

  const item = await marketplace.getItem(itemAddress, tokenId);
  await item.buy(price);
  await transfer(MARKETPLACE_ADDRESS, price);
  await transfer(itemAddress, tokenId);
  return `Item purchased for ${price} MANA`;
}

// Frontend
const sellItem = async () => {
  const name = $('#item-name').val();
  const price = $('#item-price').val();
  const message = await sellItem(name, price);
  $('#message').text(message);
};

const buyItem = async (itemAddress, tokenId) => {
  const message = await buyItem(itemAddress, tokenId);
  $('#message').text(message);
};

// HTML
<form onsubmit=""sellItem(); return false;"">
  <input type=""text"" id=""item-name"" placeholder=""Item name"" required>
  <input type=""number"" id=""item-price"" placeholder=""Price in MANA"" required>
  <button type=""submit"">List item</button>
</form>

<div id=""items""></div>

// JavaScript
const items = await marketplace.getItems();

for (const item of items) {
  const { address, tokenId, price } = item;
  const nft = await getNFT(address, tokenId);
  const name = nft.metadata.name;
  const itemHtml = `<div>
    <h2>${name}</h2>
    <img src=""${nft.image}"" width=""300"">
    <p>${price} MANA</p>
    <button onclick=""buyItem('${address}', '${tokenId}')"">Buy</button>
  </div>`;
  $('#items').append(itemHtml);
}"
/* script for decentralised market auction */,"pragma solidity ^0.8.0;

contract Auction {
    address payable public seller;
    uint public auctionEndTime;

    address public highestBidder;
    uint public highestBid;

    mapping(address => uint) public bids;

    bool ended = false;

    event HighestBidIncreased(address bidder, uint amount);
    event AuctionEnded(address winner, uint amount);

    constructor(uint durationMinutes) {
        seller = payable(msg.sender);
        auctionEndTime = block.timestamp + (durationMinutes * 1 minutes);
    }

    function bid() public payable {
        require(
            block.timestamp <= auctionEndTime,
            ""Auction already ended.""
        );

        require(
            msg.value > highestBid,
            ""There is already a higher bid.""
        );

        if (highestBid != 0) {
            bids[highestBidder] += highestBid;
        }

        highestBidder = msg.sender;
        highestBid = msg.value;
        emit HighestBidIncreased(msg.sender, msg.value);
    }

    function endAuction() public {
        require(
            block.timestamp >= auctionEndTime,
            ""Auction not yet ended.""
        );

        require(!ended, ""Auction has already ended."");

        ended = true;
        emit AuctionEnded(highestBidder, highestBid);

        seller.transfer(highestBid);
    }
}"
/* script for decentralised file storage */,"pragma solidity ^0.8.0;

contract FileStorage {
    mapping(bytes32 => bytes) public files;

    function upload(bytes32 hash, bytes memory data) public {
        files[hash] = data;
    }

    function download(bytes32 hash) public view returns (bytes memory) {
        return files[hash];
    }
}"
/* script for decentralised music streaming platform */,"import * as dcl from 'decentraland-api'

// The list of available songs
const songs = [
  { title: 'Song 1', url: 'https://example.com/song1.mp3' },
  { title: 'Song 2', url: 'https://example.com/song2.mp3' },
  { title: 'Song 3', url: 'https://example.com/song3.mp3' }
]

// The index of the currently playing song
let currentSongIndex = 0

// The audio player
let audio = null

// Create a panel to display the song information
const panel = new UIContainerStack()
panel.width = '100%'
panel.height = '30px'
panel.vAlign = 'bottom'
panel.hAlign = 'center'
panel.isPointerBlocker = false
panel.positionY = 1.4

const songTitle = new UIText(panel)
songTitle.value = songs[currentSongIndex].title
songTitle.fontSize = 20
songTitle.color = Color4.White()
songTitle.outlineColor = Color4.Black()
songTitle.outlineWidth = 0.2

// Create buttons to play/pause, skip to next song, and go back to previous song
const playPauseButton = new UIImage(panel, new Texture('playButton.png'))
playPauseButton.width = '50px'
playPauseButton.height = '50px'
playPauseButton.positionX = -50
playPauseButton.onClick = () => {
  if (!audio) {
    // Start playing the current song
    audio = new Audio(songs[currentSongIndex].url)
    audio.play()
    playPauseButton.source = new Texture('pauseButton.png')
  } else if (audio.paused) {
    // Resume playback
    audio.play()
    playPauseButton.source = new Texture('pauseButton.png')
  } else {
    // Pause playback
    audio.pause()
    playPauseButton.source = new Texture('playButton.png')
  }
}

const nextButton = new UIImage(panel, new Texture('nextButton.png'))
nextButton.width = '50px'
nextButton.height = '50px'
nextButton.onClick = () => {
  // Stop the current song if it's playing
  if (audio) {
    audio.stop()
    audio = null
    playPauseButton.source = new Texture('playButton.png')
  }

  // Go to the next song in the list
  currentSongIndex = (currentSongIndex + 1) % songs.length
  songTitle.value = songs[currentSongIndex].title
}

const prevButton = new UIImage(panel, new Texture('prevButton.png'))
prevButton.width = '50px'
prevButton.height = '50px'
prevButton.positionX = 50
prevButton.onClick = () => {
  // Stop the current song if it's playing
  if (audio) {
    audio.stop()
    audio = null
    playPauseButton.source = new Texture('playButton.png')
  }

  // Go to the previous song in the list
  currentSongIndex = (currentSongIndex - 1 + songs.length) % songs.length
  songTitle.value = songs[currentSongIndex].title
}

// Add the panel and buttons to the scene
dcl.addUIPanel(panel)
dcl.addUIImage(playPauseButton)
dcl.addUIImage(nextButton)
dcl.addUIImage(prevButton)"
/* log user interactions */,"
// Function to log user interactions
function logInteraction(user: string, action: string) {
  const date = new Date().toISOString();
  console.log(`${date}: User ${user} performed action ${action}`);
}
"
/* generate random passwords */,"// Function to generate a random password
function generatePassword(length: number) {
  const charset = ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"";
  let password = """";
  for (let i = 0; i < length; i++) {
    password += charset.charAt(Math.floor(Math.random() * charset.length));
  }
  return password;
}"
/* send email */,"// Function to send an email
function sendEmail(to: string, subject: string, body: string) {
  const email = {
    to: to,
    subject: subject,
    body: body
  };
  // Code to send email
}"
/* query database */,"// Function to query a database
async function queryDatabase(query: string) {
  const result = await db.query(query);
  return result;
}"
/* format dates */,"// Function to format a date
function formatDate(date: Date) {
  const options = { year: 'numeric', month: 'long', day: 'numeric' };
  return date.toLocaleDateString('en-US', options);
}"
/* decode JWT token */,"// Function to decode a JWT token
function decodeToken(token: string) {
  const secret = ""mysecretkey"";
  const decoded = jwt.verify(token, secret);
  return decoded;
}"
/* fetch data from an api */,"// Function to fetch data from an API
async function fetchData(url: string) {
  const response = await fetch(url);
  const data = await response.json();
  return data;
}"
/* Script to move an object with the arrow keys */,"const box = new Entity();
box.addComponent(new Transform({ position: new Vector3(0, 0, 0) }));
engine.addEntity(box);

const speed = 0.1;
const input = Input.instance;
input.subscribe(""BUTTON_DOWN"", ActionButton.POINTER, false, (e) => {
  if (e === ActionButton.POINTER) {
    if (input.isPressed(""ArrowUp"")) {
      box.getComponent(Transform).translate(Vector3.Forward().scale(speed));
    }
    if (input.isPressed(""ArrowDown"")) {
      box.getComponent(Transform).translate(Vector3.Backward().scale(speed));
    }
    if (input.isPressed(""ArrowLeft"")) {
      box.getComponent(Transform).translate(Vector3.Left().scale(speed));
    }
    if (input.isPressed(""ArrowRight"")) {
      box.getComponent(Transform).translate(Vector3.Right().scale(speed));
    }
  }
});"
/* play sound on object interaction */,"const box = new Entity();
box.addComponent(new Transform({ position: new Vector3(0, 0, 0) }));
engine.addEntity(box);

const clip = new AudioClip(""path/to/sound.mp3"");
const source = new AudioSource(clip);
box.addComponent(source);

box.addComponent(
  new OnPointerDown(() => {
    source.playOnce();
  })
);"
/* rotate an object on click */,"const box = new Entity();
box.addComponent(new Transform({ position: new Vector3(0, 0, 0) }));
engine.addEntity(box);

const speed = 10;
box.addComponent(
  new OnPointerDown(() => {
    box.getComponent(Transform).rotate(Vector3.Up(), speed);
  })
);"
/* scale an object on click */,"const box = new Entity();
box.addComponent(new Transform({ position: new Vector3(0, 0, 0), scale: new Vector3(1, 1, 1) }));
engine.addEntity(box);

const scaleSpeed = 0.1;
box.addComponent(
  new OnPointerDown(() => {
    box.getComponent(Transform).scale.addInPlace(new Vector3(scaleSpeed, scaleSpeed, scaleSpeed));
  })
);"
/* spawn objects on click */,"const prefab = new Entity();
prefab.addComponent(new Transform({ position: new Vector3(0, 0, 0) }));
engine.addEntity(prefab);

const spawnDistance = 2;
const spawnSpeed = 1;
prefab.addComponent(
  new OnPointerDown(() => {
    const instance = new Entity();
    instance.addComponent(new Transform({ position: prefab.getComponent(Transform).position.clone().add(new Vector3(spawnDistance, 0, 0)) }));
    engine.addEntity(instance);
    instance.addComponent(
      new OnPointerDown(() => {
        engine.removeEntity(instance);
      })
    );
    instance.addComponent(
      new OnUpdate(() => {
        instance.getComponent(Transform).translate(Vector3.Left().scale(spawnSpeed));
      })
    );
  })
);
"
/* change object texture on click */,"const box = new Entity();
box.addComponent(new Transform({ position: new Vector3(0, 0, 0) }));
engine.addEntity(box);

const texture = new Texture(""insert path to texture here"");
box.addComponent(new Material());
box.getComponent(Material).albedoTexture = texture;

const altTexture = new Texture(""insert path to texture here"");
box.addComponent(
  new OnPointerDown(() => {
    box.getComponent(Material).albedoTexture = altTexture;
  })
);"
/* script to make object fade on click */,"const box = new Entity();
box.addComponent(new Transform({ position: new Vector3(0, 0, 0), scale: new Vector3(1, 1, 1) }));
engine.addEntity(box);

const fadeSpeed = 0.05;
box.addComponent(
new OnPointerDown(() => {
box.addComponentOrReplace(
new utils.FadeOut(fadeSpeed, () => {
engine.removeEntity(box);
})
);
})
);"
/* spwn particles on object interaction */,"const box = new Entity();
box.addComponent(new Transform({ position: new Vector3(0, 0, 0) }));
engine.addEntity(box);

const particleSystem = new ParticleSystem();
particleSystem.playing = false;
particleSystem.emitterShape = new BoxShape();
particleSystem.emitterShape.boxSize = new Vector3(1, 1, 1);
particleSystem.birthRate = 10;
particleSystem.color0 = new Color4(1, 1, 1, 1);
particleSystem.color1 = new Color4(1, 0, 0, 1);
box.addComponent(particleSystem);

box.addComponent(
new OnPointerDown(() => {
particleSystem.playing = true;
setTimeout(() => {
particleSystem.playing = false;
}, 1000);
})
);

css
Copy code

9. Script to toggle object visibility on click
const box = new Entity();
box.addComponent(new Transform({ position: new Vector3(0, 0, 0), scale: new Vector3(1, 1, 1) }));
engine.addEntity(box);

box.addComponent(
new OnPointerDown(() => {
if (box.getComponent(Transform).scale.x > 0) {
box.getComponent(Transform).scale.setAll(0);
} else {
box.getComponent(Transform).scale.setAll(1);
}
})
);

css
Copy code

10. Script to change camera position on click
const camera = Camera.instance;

const startPosition = new Vector3(0, 0, 0);
const endPosition = new Vector3(0, 5, 10);
const moveSpeed = 0.1;
let cameraMoving = false;

engine.addEntity(new Entity());

const button = new Entity();
button.addComponent(new Transform({ position: new Vector3(0, 1, 0) }));
engine.addEntity(button);

button.addComponent(new BoxShape());
button.getComponent(BoxShape).withCollisions = false;

button.addComponent(
new OnPointerDown(() => {
if (!cameraMoving) {
cameraMoving = true;
const start = camera.position.clone();
const end = endPosition.clone();
const distance = start.distanceTo(end);
const time = distance / moveSpeed;
let t = 0;
const interval = setInterval(() => {
t += engine.getDeltaTime() / 1000;
camera.position = Vector3.Lerp(start, end, t / time);
if (t >= time) {
clearInterval(interval);
cameraMoving = false;
}
}, 1);
}
})
);

Copy code


"
/* script to listen to mouse input and move an object accordingly */,"const box = new Entity();
box.addComponent(new Transform({ position: new Vector3(0, 0, 0), scale: new Vector3(1, 1, 1) }));
engine.addEntity(box);

let dragging = false;
let dragOffset = new Vector3(0, 0, 0);
let mousePos = new Vector3(0, 0, 0);

box.addComponent(
  new OnPointerDown((e) => {
    dragging = true;
    dragOffset.copyFrom(e.hitPoint.subtract(box.getComponent(Transform).position));
  })
);

box.addComponent(
  new OnPointerMove((e) => {
    if (dragging) {
      mousePos.copyFrom(e.hitPoint.subtract(dragOffset));
      box.getComponent(Transform).position.copyFrom(mousePos);
    }
  })
);

box.addComponent(
  new OnPointerUp(() => {
    dragging = false;
  })
);"
/* Script to listen to mouse input and rotate an object */,"const box = new Entity();
box.addComponent(new Transform({ position: new Vector3(0, 0, 0), scale: new Vector3(1, 1, 1) }));
engine.addEntity(box);

let dragging = false;
let dragStart = new Vector3(0, 0, 0);
let dragEnd = new Vector3(0, 0, 0);

box.addComponent(
  new OnPointerDown((e) => {
    dragging = true;
    dragStart.copyFrom(e.hitPoint);
  })
);

box.addComponent(
  new OnPointerMove((e) => {
    if (dragging) {
      dragEnd.copyFrom(e.hitPoint);
      const diff = dragEnd.subtract(dragStart);
      box.getComponent(Transform).rotation.eulerAngles.y -= diff.x / 10;
    }
  })
);

box.addComponent(
  new OnPointerUp(() => {
    dragging = false;
  })
);
"
/* Script to listen to keyboard input and move a character */,"const character = new Entity();
character.addComponent(new Transform({ position: new Vector3(0, 0, 0), scale: new Vector3(1, 1, 1) }));
engine.addEntity(character);

const moveSpeed = 0.1;

Input.instance.subscribe('KEY_DOWN', KeyCode.W, false, () => {
  character.getComponent(Transform).translate(Vector3.Forward().scale(moveSpeed));
});

Input.instance.subscribe('KEY_DOWN', KeyCode.S, false, () => {
  character.getComponent(Transform).translate(Vector3.Backward().scale(moveSpeed));
});

Input.instance.subscribe('KEY_DOWN', KeyCode.A, false, () => {
  character.getComponent(Transform).translate(Vector3.Left().scale(moveSpeed));
});

Input.instance.subscribe('KEY_DOWN', KeyCode.D, false, () => {
  character.getComponent(Transform).translate(Vector3.Right().scale(moveSpeed));
});
"
/* Script to listen to keyboard input and change camera position */,"const camera = Camera.instance;

const moveSpeed = 0.1;

Input.instance.subscribe('KEY_DOWN', KeyCode.W, false, () => {
  camera.position.z += moveSpeed;
});

Input.instance.subscribe('KEY_DOWN', KeyCode.S, false, () => {
  camera.position.z -= moveSpeed;
});

Input.instance.subscribe('KEY_DOWN', KeyCode.A, false, () => {
  camera.position.x -= moveSpeed;
});

Input.instance.subscribe('KEY_DOWN', KeyCode.D, false, () => {
  camera.position.x += moveSpeed;
});

Input.instance.subscribe('KEY_DOWN', KeyCode.Q, false, () => {
  camera.position.y += moveSpeed;
});

Input.instance.subscribe('KEY_DOWN', KeyCode.E, false,
"
/* shark animation */,"import { Animator, engine, GltfContainer, InputAction, pointerEventsSystem, Transform } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'

export * from '@dcl/sdk'

const seaBed = engine.addEntity()

Transform.create(seaBed, {
  position: Vector3.create(8, 0, 8),
  scale: Vector3.create(0.8, 0.8, 0.8)
})

GltfContainer.create(seaBed, {
  src: 'models/Underwater.gltf'
})

const shark = engine.addEntity()

Transform.create(shark, {
  position: Vector3.create(8, 3, 8)
})

GltfContainer.create(shark, {
  src: 'models/shark.glb'
})

Animator.create(shark, {
  states: [
    {
      clip: 'swim',
      name: 'swim',
      playing: true,
      loop: true
    },
    {
      clip: 'bite',
      name: 'bite',
      playing: false,
      loop: false,
      shouldReset: true
    }
  ]
})

pointerEventsSystem.onPointerDown(
  shark,
  () => {
    // TODO use Animator.getClip()
    const mutableAnimator = Animator.getMutable(shark)
    mutableAnimator.states[1].playing = true
  },
  {
    button: InputAction.IA_POINTER,
    hoverText: 'Bite'
  }
)"
/* script for smoke */,"import { engine, GltfContainer, Transform } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'

import { SmokeSource } from './definitions'
import smokeSystem from './modules/smoke'
import throwSmokeSystem from './modules/smokeSource'

function setup() {
  const fire = engine.addEntity()
  GltfContainer.create(fire, { src: 'models/Fireplace.glb' })
  Transform.create(fire, { position: Vector3.create(8, 0, 8) })

  // // Add a smoke source that creates a smoke puff every 0.2 seconds
  SmokeSource.create(fire, {
    particleCount: 50,
    smokeInterval: 0.2
  })

  const floor = engine.addEntity()
  GltfContainer.create(floor, { src: 'models/FloorBaseGrass.glb' })
  Transform.create(floor, { position: Vector3.create(8, 0, 8), scale: Vector3.create(1.6, 0.1, 1.6) })

  engine.addSystem(throwSmokeSystem)
  engine.addSystem(smokeSystem)
}

setup()"
/* wolf animation */,"import { Animator, engine, GltfContainer, InputAction, pointerEventsSystem, Transform } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'

const forest = engine.addEntity()

Transform.create(forest, {
  position: Vector3.create(8, 0, 8),
  scale: Vector3.create(1.5, 1.5, 1.5)
})

GltfContainer.create(forest, {
  src: 'models/Forest.gltf'
})

const wolf = engine.addEntity()

Transform.create(wolf, {
  position: Vector3.create(8, 3, 8)
})

GltfContainer.create(wolf, {
  src: 'models/wolf.glb'
})

Animator.create(wolf, {
  states: [
    {
      clip: 'run',
      name: 'run',
      playing: true,
      loop: true
    },
    {
      clip: 'attack',
      name: 'attack',
      playing: false,
      loop: false,
      shouldReset: true
    }
  ]
})

pointerEventsSystem.onPointerDown(
  wolf,
  () => {
    const mutableAnimator = Animator.getMutable(wolf)
    mutableAnimator.states[1].playing = true
  },
  {
    button: InputAction.IA_POINTER,
    hoverText: 'Attack'
  }
)
"
/* dancing jukebox */,"import { Quaternion, Vector3 } from '@dcl/sdk/math'
import { engine, GltfContainer, Transform } from '@dcl/sdk/ecs'

import { songs } from './definitions'
import moveAnimationSystem from './modules/moveAnimation'
import { createSongButton } from './modules/songButton'

export * from '@dcl/sdk'

function createJukebox(position: Vector3) {
  // Jukebox
  const jukebox = engine.addEntity()
  GltfContainer.create(jukebox, { src: 'models/Jukebox.gltf' })
  Transform.create(jukebox, {
    position,
    rotation: Quaternion.fromEulerDegrees(0, 180, 0),
    scale: Vector3.create(0.6, 0.6, 0.6)
  })

  for (let i = 0; i < songs.length; i++) {
    const posX = i % 2 === 0 ? -0.03 : 0.4
    const posY = Math.floor(i / 2) === 0 ? 1.9 : 1.77
    createSongButton(jukebox, posX, posY, songs[i])
  }
}

function setup() {
  // ground
  const floor = engine.addEntity()
  GltfContainer.create(floor, { src: 'models/FloorBaseGrass.glb' })
  Transform.create(floor, { position: Vector3.create(8, 0, 8), scale: Vector3.create(1.6, 0.1, 1.6) })

  // jukebox
  createJukebox(Vector3.create(5, 0, 9.5))

  engine.addSystem(moveAnimationSystem)
}

setup()"
/* create a sliding door */,"import { engine, InputAction, pointerEventsSystem, Schemas, Transform } from '@dcl/sdk/ecs'
import { Vector3 } from '@dcl/sdk/math'
import { createWall, setMaterial } from './factory'
import { transformComponent } from './systems'

// export all the functions required to make the scene work
export * from '@dcl/sdk'

// Define component to have the state of the door
const DoorComponent = engine.defineComponent(
  {
    open: Schemas.Boolean
  },
  888
)

// Create the walls
createWall(Vector3.create(9.75, 1, 8), Vector3.create(1.5, 2.01, 0.1))
createWall(Vector3.create(6.25, 1, 8), Vector3.create(1.5, 2.01, 0.1))

// Create the doors
const parentDoor = engine.addEntity()
Transform.create(parentDoor, {
  position: Vector3.create(8, 1, 8)
})

const leftDoor = createWall(Vector3.create(0.5, 0, 0), Vector3.create(1.1, 2, 0.05), parentDoor)
const rightDoor = createWall(Vector3.create(-0.5, 0, 0), Vector3.create(1.1, 2, 0.05), parentDoor)

// Set material to the doors
setMaterial(leftDoor)
setMaterial(rightDoor)

// Door initial state, open=false
DoorComponent.create(parentDoor, { open: false })

// Register event when you click on one of the doors
pointerEventsSystem.onPointerDown(leftDoor, onDoorClicked, { button: InputAction.IA_POINTER })
pointerEventsSystem.onPointerDown(rightDoor, onDoorClicked, { button: InputAction.IA_POINTER })

// Callback when click the doors
// Open both doors at the same time
function onDoorClicked() {
  const leftDoorClosed = Vector3.create(0.5, 0, 0)
  const leftDoorOpen = Vector3.create(1.25, 0, 0)
  const rightDoorClosed = Vector3.create(-0.5, 0, 0)
  const rightDoorOpen = Vector3.create(-1.25, 0, 0)

  const door = DoorComponent.getMutable(parentDoor)
  door.open = !door.open
  const leftDoorNextPosition = door.open ? leftDoorOpen : leftDoorClosed
  const rightDoorNextPosition = door.open ? rightDoorOpen : rightDoorClosed

  // Register systems to move the doors in 0.5 seconds
  transformComponent(leftDoor, { position: leftDoorNextPosition }, 0.5)
  transformComponent(rightDoor, { position: rightDoorNextPosition }, 0.5)
}"
/* add click behavior to entity */ ,"export function addClickBehavior(entity: Entity, fn: (entity: Entity) => void) {
  PointerEvents.create(entity, {
    pointerEvents: [
      {
        eventType: PointerEventType.PET_DOWN,
        eventInfo: {
          button: InputAction.IA_PRIMARY,
          hoverText: ""Click"",
          maxDistance: 100,
          showFeedback: true,
        },
      },
    ],
  })
  callbackMap.set(entity, fn)

  return entity
}"
/* add key press listener to entity */,"export function addKeyPressBehavior(entity: Entity, fn: (entity: Entity, keyCode: number) => void) {
  const listener = Input.instance.onKeyDown((event) => {
    fn(entity, event.keyCode)
  })

  callbackMap.set(entity, listener)

  return entity
}
"
/* add collisione event listener to entity */,"export function addCollisionBehavior(entity: Entity, fn: (entity: Entity, collidedWith: Entity) => void) {
  const listener = entity.addComponent(
    new OnCollide((collision) => {
      const otherEntity = collision.otherEntity
      fn(entity, otherEntity)
    })
  )

  callbackMap.set(entity, listener)

  return entity
}
"
/* add scroll behavior to entity */,"export function addScrollBehavior(entity: Entity, fn: (entity: Entity, scrollDelta: number) => void) {
  const listener = Input.instance.subscribe('SCROLL', { callback: (e) => fn(entity, e.delta) })

  callbackMap.set(entity, listener)

  return entity
}
"
/* add hover behavior to entity */,"export function addHoverBehavior(entity: Entity, fn: (entity: Entity, hovering: boolean) => void) {
  const listener = entity.addComponent(
    new utils.TriggerComponent(
      new OnPointerDown(
        () => {
          fn(entity, true)
        },
        {
          hoverText: 'Hovering!',
        }
      ),
      new OnPointerUp(() => {
        fn(entity, false)
      })
    )
  )

  callbackMap.set(entity, listener)

  return entity
}
"
/* add a click and drag event listener to an entity in a Decentraland scene */,"export function addClickAndDragBehavior(entity: Entity, fn: (entity: Entity, dragging: boolean) => void) {
  const listener = entity.addComponent(
    new utils.TriggerComponent(
      new OnPointerDown(
        () => {
          fn(entity, true)
        },
        {
          hoverText: 'Drag me!',
        }
      ),
      new OnPointerUp(() => {
        fn(entity, false)
      })
    )
  )

  callbackMap.set(entity, listener)

  return entity
}
"
"/* create a system to listen for when an entity is clicked with the 
primary input action */","import { Entity, engine, PointerEvents, InputAction, PointerEventType, inputSystem } from ""@dcl/sdk/ecs""

const callbackMap = new Map<Entity, (entity: Entity) => void>()

export function clickedSystem() {
  for (const [entity] of engine.getEntitiesWith(PointerEvents)) {
    if (inputSystem.isTriggered(InputAction.IA_PRIMARY, PointerEventType.PET_DOWN, entity)) {
      const fn = callbackMap.get(entity)
      if (fn) fn(entity)
    }
  }
}

engine.addSystem(clickedSystem)"
"/* script should create a new entity with a box shape, sets a rotation speed, 
adds the entity to the engine, and adds a system to rotate the entity on the
Y axis based on the elapsed time */","const entity = new Entity()
entity.addComponent(new Transform())
entity.addComponent(new BoxShape())

const rotateSpeed = 20

engine.addEntity(entity)

engine.addSystem(new class {
  update(dt: number) {
    const transform = entity.getComponent(Transform)
    transform.rotate(Vector3.Up(), dt * rotateSpeed)
  }
}())"
/* script should play a sound */,"const buttonEntity = new Entity()
buttonEntity.addComponent(new Transform({
  position: new Vector3(5, 0, 5)
}))
buttonEntity.addComponent(new BoxShape())

const sound = new AudioClip('path/to/sound.mp3')

engine.addEntity(buttonEntity)

buttonEntity.addComponent(new OnPointerDown(() => {
  const audioSource = new AudioSource(sound)
  audioSource.playing = true
  buttonEntity.addComponent(audioSource)
  engine.addEntity(buttonEntity)
}))

"
/* score board */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

interface Score {
  name: string
  score: number
}

export let highScores: Score[] = []

executeTask(async () => {
  const user = await getUserData({})
  const score: Score = {
    name: user.data?.displayName ?? ""Anonymous"",
    score: Math.floor(Math.random() * 100)
  }
  highScores.push(score)
})"
/* create inventory */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

interface Item {
  name: string
  quantity: number
}

export let inventory: Item[] = []

executeTask(async () => {
  const user = await getUserData({})
  const item: Item = {
    name: ""Item"" + Math.floor(Math.random() * 10),
    quantity: Math.floor(Math.random() * 5)
  }
  inventory.push(item)
})
"
/* create friend list */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

interface Friend {
  name: string
}

export let friends: Friend[] = []

executeTask(async () => {
  const user = await getUserData({})
  const friend: Friend = {
    name: user.data?.displayName ?? ""Unknown""
  }
  friends.push(friend)
})
"
/* Time Played */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

export let timePlayed: number = 0

let startTime: number = 0

executeTask(async () => {
  startTime = Date.now()
})

setInterval(() => {
  if (startTime > 0) {
    timePlayed = Math.floor((Date.now() - startTime) / 1000)
  }
}, 1000)
"
/* Level Progression */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

export let level: number = 1
export let experience: number = 0

executeTask(async () => {
  const user = await getUserData({})
  if (user.data?.experience) {
    experience = user.data.experience
    level = Math.floor(experience / 100) + 1
  }
})
"
/* Currency Balance */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

export let balance: number = 0

executeTask(async () => {
  const user = await getUserData({})
  if (user.data?.wallet) {
    balance = user.data.wallet.balance
  }
})
"
/* random achievements */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

export let balance: number = 0

executeTask(async () => {
  const user = await getUserData({})
  if (user.data?.wallet) {
    balance = user.data.wallet.balance
  }
})
"
/* leaderboard */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

interface Score {
  name: string
  score: number
}

export let leaderboard: Score[] = []

executeTask(async () => {
  const user = await getUserData({})
  const score: Score = {
    name: user.data?.displayName ?? ""Anonymous"",
    score: Math.floor(Math.random() * 100)
  }
  leaderboard.push(score)
  leaderboard.sort((a, b) => b.score - a.score)
})"
/* social media sharing */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

interface ShareData {
  title: string
  text: string
  url: string
}

executeTask(async () => {
  const user = await getUserData({})
  const shareData: ShareData = {
    title: ""Check out my game!"",
    text: ""I'm having so much fun playing this game. Join me!"",
    url: ""https://example.com/game""
  }
  const shareUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareData.text)}&url=${encodeURIComponent(shareData.url)}&hashtags=gaming`
  log(`Share this URL: ${shareUrl}`)
})"
/* notifications */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

interface Notification {
  message: string
  read: boolean
}

export let notifications: Notification[] = []

executeTask(async () => {
  const user = await getUserData({})
  const notification: Notification = {
    message: ""Welcome to the game!"",
    read: false
  }
  notifications.push(notification)
  if (user.data?.level > 5) {
    notification.message = ""Congratulations on reaching level 5!""
  }
})
"
/* script for a shopping cart */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

interface Item {
  name: string
  price: number
}

export let shoppingCart: Item[] = []

executeTask(async () => {
  const user = await getUserData({})
  const item: Item = {
    name: ""Sword"",
    price: 10
  }
  shoppingCart.push(item)
  if (user.data?.discountCode === ""SAVE10"") {
    item.price *= 0.9
  }
})"
/* user settings */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

interface Settings {
  darkMode: boolean
  language: string
}

export let userSettings: Settings = {
  darkMode: false,
  language: ""en""
}

executeTask(async () => {
  const user = await getUserData({})
  if (user.data?.settings) {
    userSettings = user.data.settings
  }
})
"
/* create favorites */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

interface Favorite {
  name: string
  url: string
}

export let favorites: Favorite[] = []

executeTask(async () => {
  const user = await getUserData({})
  const favorite: Favorite = {
    name: ""Google"",
    url: ""https://www.google.com""
  }
  favorites.push(favorite)
  if (user.data?.favorites?.length > 0) {
    favorites = user.data.favorites
  }
})
"
/* contact list */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

interface Contact {
  name: string
  email: string
  phone?: string
}

export let contacts: Contact[] = []

executeTask(async () => {
  const user = await getUserData({})
  const contact: Contact = {
    name: ""John Doe"",
    email: ""johndoe@example.com"",
    phone: ""+1 555-555-5555""
  }
  contacts.push(contact)
  if (user.data?.friends?.length > 0) {
    user.data.friends.forEach((friend: any) => {
      contacts.push({
        name: friend.name,
        email: friend.email
      })
    })
  }
})
"
/* recent activity */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

interface Activity {
  type: string
  timestamp: number
}

export let recentActivity: Activity[] = []

executeTask(async () => {
  const user = await getUserData({})
  const activity: Activity = {
    type: ""login"",
    timestamp: Date.now()
  }
  recentActivity.push(activity)
  if (user.data?.lastActivity) {
    recentActivity.push(user.data.lastActivity)
  }
})
"
/* mailing list */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

interface Subscriber {
  name: string
  email: string
}

export let subscribers: Subscriber[] = []

executeTask(async () => {
  const user = await getUserData({})
  const subscriber: Subscriber = {
    name: ""Alice"",
    email: ""alice@example.com""
  }
  subscribers.push(subscriber)
  if (user.data?.subscribed) {
    subscribers.push({
      name: user.data.name,
      email: user.data.email
    })
  }
})
"
/* inventory */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

interface Item {
  name: string
  quantity: number
}

export let inventory: Item[] = []

executeTask(async () => {
  const user = await getUserData({})
  const item: Item = {
    name: ""Apples"",
    quantity: 10
  }
  inventory.push(item)
  if (user.data?.purchasedItems?.length > 0) {
    user.data.purchasedItems.forEach((purchasedItem: any) => {
      inventory.push({
        name: purchasedItem.name,
        quantity: purchasedItem.quantity
      })
    })
  }
})
"
/* create a watch list */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

interface WatchlistItem {
  name: string
  description: string
  imageUrl: string
}

export let watchlist: WatchlistItem[] = []

executeTask(async () => {
  const user = await getUserData({})
  const watchlistItem: WatchlistItem = {
    name: ""The Matrix"",
    description: ""A sci-fi movie about a computer programmer who discovers a simulated reality"",
    imageUrl: ""https://example.com/matrix.jpg""
  }
  watchlist.push(watchlistItem)
  if (user.data?.watchlist?.length > 0) {
    watchlist = user.data.watchlist
  }
})
"
/* create a wish list */,"import { executeTask } from ""@dcl/sdk/ecs""
import { getUserData } from ""~system/UserIdentity""

interface WishlistItem {
  name: string
  price: number
  imageUrl: string
}

export let wishlist: WishlistItem[] = []

executeTask(async () => {
  const user = await getUserData({})
  const wishlistItem: WishlistItem = {
    name: ""Nintendo Switch"",
    price: 299,
    imageUrl: ""https://example.com/switch.jpg""
  }
  wishlist.push(wishlistItem)
  if (user.data?.wishlist?.length > 0) {
    wishlist = user.data.wishlist
  }
})"
/* create a chair from gltf */,"const chair = new Entity()
chair.addComponent(new GLTFShape('models/Chair.gltf'))
chair.addComponent(
  new Transform({
    position: new Vector3(4, 0, 8),
    rotation: Quaternion.Euler(0, 90, 0),
    scale: new Vector3(0.7, 0.7, 0.7),
  })
)
engine.addEntity(chair)"
/* create car from gltf */,"const car = new Entity()
car.addComponent(new GLTFShape('models/Car.gltf'))
car.addComponent(
  new Transform({
    position: new Vector3(10, 0, 5),
    rotation: Quaternion.Euler(0, 90, 0),
    scale: new Vector3(0.5, 0.5, 0.5),
  })
)
engine.addEntity(car)
"
/* create tree from gltf */,"const tree = new Entity()
tree.addComponent(new GLTFShape('models/Tree.gltf'))
tree.addComponent(
  new Transform({
    position: new Vector3(7, 0, 3),
    rotation: Quaternion.Euler(0, 180, 0),
    scale: new Vector3(0.8, 0.8, 0.8),
  })
)
engine.addEntity(tree)"
/* create a vase entity */,"const vase = new Entity()
vase.addComponent(new GLTFShape('models/Vase.gltf'))
vase.addComponent(
  new Transform({
    position: new Vector3(9, 0, 11),
    rotation: Quaternion.Euler(0, 180, 0),
    scale: new Vector3(0.5, 0.5, 0.5),
  })
)
engine.addEntity(vase)"
/* get balance of eth address */,"import { getBalance } from ""eth-connect""
import * as EthereumController from ""@decentraland/EthereumController""

let eth = EthereumController

function getAccountBalance(address: string) {
  executeTask(async () => {
    const balance = await getBalance(eth, address)
    log(`Account balance for ${address}: ${balance.toString()}`)
  })
}

getAccountBalance(""0x1234567890abcdef1234567890abcdef12345678"")
"
/* send eth from one address to another */,"import { sendTransaction } from ""eth-connect""
import * as EthereumController from ""@decentraland/EthereumController""

let eth = EthereumController

function sendEth(fromAddress: string, toAddress: string, amount: number) {
  executeTask(async () => {
    const tx = await sendTransaction(eth, {
      from: fromAddress,
      to: toAddress,
      value: amount,
    })
    log(`Transaction hash: ${tx.hash}`)
  })
}

sendEth(""0x1234567890abcdef1234567890abcdef12345678"", ""0xabcdef1234567890abcdef1234567890abcdef12"", 1)
"
/*get the transaction count of an Ethereum address */,"import { getTransactionCount } from ""eth-connect""
import * as EthereumController from ""@decentraland/EthereumController""

let eth = EthereumController

function getAccountNonce(address: string) {
  executeTask(async () => {
    const nonce = await getTransactionCount(eth, address)
    log(`Account nonce for ${address}: ${nonce.toString()}`)
  })
}

getAccountNonce(""0x1234567890abcdef1234567890abcdef12345678"")"
/* shooting range target entity */,"import * as utils from '@dcl/ecs-scene-utils'

export class ShootingTarget extends Entity {
  constructor(model: GLTFShape, position: Vector3, rotation: Quaternion, scale: Vector3) {
    super()
    engine.addEntity(this)
    this.addComponent(model)
    this.addComponent(new Transform({ position, rotation, scale }))
    this.addComponent(new utils.MoveTransformComponent())
  }
}"
/* create a bullet entity class */,"import * as utils from '@dcl/ecs-scene-utils'

export class Bullet extends Entity {
  constructor(position: Vector3, direction: Vector3) {
    super()
    engine.addEntity(this)
    this.addComponent(new GLTFShape('models/bullet.glb'))
    this.addComponent(new Transform({ position }))
    this.addComponent(new utils.MoveTransformComponent(direction, 10)) // Moves in given direction at 10 units per second
    this.addComponent(new utils.Delay(2000, () => this.destroy())) // Disappears after 2 seconds
  }
}"
/* create torus */,"const torus = new Entity()
torus.addComponentOrReplace(new Transform({
  position: new Vector3(5, 5, 5)
}))
torus.addComponentOrReplace(new TorusShape())
engine.addEntity(torus)"
/* dodecahedron */,"const dodecahedron = new Entity()
dodecahedron.addComponentOrReplace(new Transform({
  position: new Vector3(4, 5, 6)
}))
dodecahedron.addComponentOrReplace(new DodecahedronShape())
engine.addEntity(dodecahedron)"
/* icosahedron */,"const icosahedron = new Entity()
icosahedron.addComponentOrReplace(new Transform({
  position: new Vector3(5, 6, 7)
}))
icosahedron.addComponentOrReplace(new IcosahedronShape())
engine.addEntity(icosahedron)"
/* script that creates a sword entity and plays a sound effect when it is clicked */,"// import utils
import * as utils from '@dcl/ecs-scene-utils'

// create a sword entity
const sword = new Entity()
sword.addComponent(new GLTFShape('models/sword.glb'))
sword.addComponent(new Transform({
  position: new Vector3(8, 0, 8),
  rotation: Quaternion.Euler(0, 90, 0),
  scale: new Vector3(2, 2, 2),
}))

// add a click listener to the sword
sword.addComponent(new OnClick(() => {
  log('Sword clicked!')
  const sound = new Entity()
  sound.addComponent(new Transform({ position: sword.getComponent(Transform).position }))
  sound.addComponent(new AudioSource(new AudioClip('sounds/sword_hit.mp3')))
  engine.addEntity(sound)
}))

// add the sword to the scene
engine.addEntity(sword)
"
"/* Script that creates a fireball entity that moves in a direction for 5 seconds and then explodes, needs models/fireball.glb */","// import utils
import * as utils from '@dcl/ecs-scene-utils'

// create a fireball entity
const fireball = new Entity()
fireball.addComponent(new GLTFShape('models/fireball.glb'))
fireball.addComponent(new Transform({
  position: new Vector3(8, 0, 8)
}))

// add a movement component to the fireball
fireball.addComponent(new utils.MoveTransformComponent(Vector3.Forward(), 10))

// add a delay to the fireball
fireball.addComponent(new utils.Delay(5000, () => {
  const explosion = new Entity()
  explosion.addComponent(new GLTFShape('models/explosion.glb'))
  explosion.addComponent(new Transform({ position: fireball.getComponent(Transform).position }))
  engine.addEntity(explosion)
  engine.removeEntity(fireball)
}))

// add the fireball to the scene
engine.addEntity(fireball)"
"/* Script that creates a bouncing ball that changes color every second, needs models/ball.glb */","// import utils
import * as utils from '@dcl/ecs-scene-utils'

// create a ball entity that bounces and changes color every second
const ball = new Entity()
ball.addComponent(new GLTFShape('models/ball.glb'))
ball.addComponent(new Transform({
   position: new Vector3(5, 2, 5)
}))
ball.addComponent(new utils.Bounce(2, 1)) // bounce for 2 seconds at 1 unit of height
ball.addComponent(new utils.Delay(1000, () => {
   const randomColor = Color3.Random()
   ball.getComponent(GLTFShape).material.albedoColor = randomColor // change ball color every second
}))

// add the ball to the scene
engine.addEntity(ball)
"
/* set the position relative to another entity */,"let entity1 = new Entity()
let entity2 = new Entity()

// Add entities to scene

let transform2 = new Transform({ position: new Vector3(2, 0, 0) })
entity2.addComponent(transform2)

let transform1 = new Transform({ position: entity2.getComponent(Transform).position.add(new Vector3(1, 0, 0)) })
entity1.addComponent(transform1)
"
/* move an entity toward a target position */,"let myEntity = new Entity()
myEntity.addComponent(new BoxShape())

let targetPosition = new Vector3(5, 0, 5)
let distance = targetPosition.subtract(myEntity.getComponent(Transform).position)
let direction = distance.normalize()

myEntity.addComponent(new utils.MoveTransformComponent(direction, 5))
"
/* create line of entities */,"for (let i = 0; i < 10; i++) {
  let entity = new Entity()
  entity.addComponent(new BoxShape())

  let transform = new Transform({
    position: new Vector3(i * 2, 0, 0)
  })
  entity.addComponent(transform)

  engine.addEntity(entity)
}"
/* Randomly position entities within a range */,"for (let i = 0; i < 10; i++) {
  let entity = new Entity()
  entity.addComponent(new BoxShape())

  let transform = new Transform({
    position: new Vector3(Math.random() * 10, Math.random() * 10, Math.random() * 10)
  })
  entity.addComponent(transform)

  engine.addEntity(entity)
}
"
/* align an entity to face a target position */,"let myEntity = new Entity()
myEntity.addComponent(new BoxShape())

let targetPosition = new Vector3(5, 0, 5)
let direction = targetPosition.subtract(myEntity.getComponent(Transform).position).normalize()

let lookRotation = Quaternion.LookRotation(direction, Vector3.Up())
myEntity.addComponent(new Transform({ rotation: lookRotation }))
"
/* make an entity follow the player's camera position */,"let myEntity = new Entity()
myEntity.addComponent(new BoxShape())

let cameraEntity = Camera.instance.entity

engine.addSystem(new UpdateSystem(() => {
  let cameraPosition = cameraEntity.getComponent(Transform).position
  myEntity.getComponent(Transform).lookAt(cameraPosition)
  myEntity.getComponent(Transform).position.set(cameraPosition.x, 0, cameraPosition.z)
}))"
/* create new entity on particle system */,"let myParticles = new Entity()
myParticles.addComponent(new ParticleSystem())

myParticles.getComponent(ParticleSystem).shapeType = ParticleSystemShapeType.Sphere
myParticles.getComponent(ParticleSystem).radius = 2
myParticles.getComponent(ParticleSystem).maxParticles = 100
myParticles.getComponent(ParticleSystem).lifetime = 5

myParticles.addComponent(new Transform({ position: new Vector3(0, 1, 0) }))
"
/* create a new light entity */,"let myLight = new Entity()
myLight.addComponent(new Light())

myLight.getComponent(Light).type = LightType.Point
myLight.getComponent(Light).range = 10
myLight.getComponent(Light).intensity = 2

myLight.addComponent(new Transform({ position: new Vector3(0, 2, 0) }))"
/* create a new camera entity */,"let myCamera = new Entity()
myCamera.addComponent(new Camera())

myCamera.addComponent(new Transform({ position: new Vector3(0, 1, -5) }))"
/* create new audio source entity */,"let myAudio = new Entity()
myAudio.addComponent(new AudioSource())

myAudio.getComponent(AudioSource).clip = new AudioClip(""sounds/mysound.mp3"")
myAudio.getComponent(AudioSource).volume = 0.5
myAudio.getComponent(AudioSource).loop = true

myAudio.addComponent(new Transform({ position: new Vector3(0, 0, 0) }))
"
/* create new UI text element entity */,"let myText = new Entity()
myText.addComponent(new TextShape())

myText.getComponent(TextShape).value = ""Hello, World!""
myText.getComponent(TextShape).fontSize = 5
myText.getComponent(TextShape).color = Color3.Blue()

myText.addComponent(new Transform({ position: new Vector3(0, 1, 0) }))"
/* enemy entity spawner */,"let myEnemy = new Entity()
myEnemy.addComponent(new BoxShape())
myEnemy.addComponent(new Transform({ position: new Vector3(5, 0, 5) }))
myEnemy.addComponent(new Health(100))
myEnemy.addComponent(new EnemyAI())"
/* add texture to the wall */,"function createWall() {
  const wall = new Entity('wall')
  engine.addEntity(wall)
  return wall
}

const wall = createWall();

//Add a material component to the wall Entity
const wallMaterial = new Material()
wallMaterial.albedoTexture = new Texture(""path/to/texture.png"")
wall.addComponent(wallMaterial)"
/* add light to the scene */,"function createLight() {
  const light = new Entity('light')
  engine.addEntity(light)
  return light
}

const light = createLight();

//Add a light component to the light Entity
const lightComponent = new Light()
light.addComponent(lightComponent)"
/* add sound to the scene */,"function createSound() {
  const sound = new Entity('sound')
  engine.addEntity(sound)
  return sound
}

const sound = createSound();

//Add an AudioSource component to the sound Entity
const soundComponent = new AudioSource(new AudioClip(""path/to/sound.mp3""))
sound.addComponent(soundComponent)
"
/* add particle effect to an object */,"function createObject() {
  const object = new Entity('object')
  engine.addEntity(object)
  return object
}

const object = createObject();

//Add a ParticleSystem component to the object Entity
const particleSystem = new ParticleSystem()
object.addComponent(particleSystem)
"
/* add script to an object */,"function createObject() {
  const object = new Entity('object')
  engine.addEntity(object)
  return object
}

const object = createObject();

//Add a script component to the object Entity
const scriptComponent = new ScriptComponent()
scriptComponent.scripts.push(new MyScript())
object.addComponent(scriptComponent)
"
/* add camera to a scene */,"function createSkybox() {
  const skybox = new Entity('skybox')
  engine.addEntity(skybox)
  return skybox
}

const skybox = createSkybox();

//Add a SkyBox component to the skybox Entity
const skyboxComponent = new SkyBox()
skybox.addComponent(skyboxComponent)"
/* add a random number generator to scene */,"function createRandom() {
  const random = new Entity('random')
  engine.addEntity(random)
  return random
}

const random = createRandom();

//Add a Random component to the random Entity
const randomComponent = new Random()
random.addComponent(randomComponent)"
/* generate class */,"class MyBox extends Entity {
  constructor(position: Vector3) {
    super()
    this.addComponentOrReplace(
      new Transform({
        position,
        rotation: Quaternion.Euler(0, 0, 0),
        scale: new Vector3(1, 1, 1)
      })
    )

    this.addComponentOrReplace(new BoxShape())
  }
}

const myBox = new MyBox(new Vector3(5, 0, 5))

engine.addEntity(myBox)"
/* create object with pathfinding component */,"function createObject() {
  const object = new Entity('object')
  engine.addEntity(object)
  return object
}

const object = createObject();

//Add a Pathfinding component to the object Entity
const pathfindingComponent = new Pathfinding()
object.addComponent(pathfindingComponent)"
/* add textshape to textlabel */,"function createTextLabel() {
  const textLabel = new Entity('textLabel')
  engine.addEntity(textLabel)
  return textLabel
}

const textLabel = createTextLabel();

//Add a TextShape component to the textLabel Entity
const textShape = new TextShape(""Hello, world!"")
textLabel.addComponent(textShape)"
/* UIElement */,"function createUIElement() {
  const uiElement = new Entity('uiElement')
  engine.addEntity(uiElement)
  return uiElement
}

const uiElement = createUIElement();

//Add a UICanvas component to the uiElement Entity
const canvasComponent = new UICanvas()
uiElement.addComponent(canvasComponent)

//Add a UIImage component to the uiElement Entity
const imageComponent = new UIImage(canvasComponent)
uiElement.addComponent(imageComponent)
"
/* function in dcl */,"function greet(name: string): void {
  log(""Hello, "" + name + ""!"")
}

greet(""John"") // Output: ""Hello, John!"""
/* sum function in dcl */,"function sum(a: number, b: number): number {
  return a + b;
}

console.log(sum(2, 3)); // Output: 5
"
/* functional to capitalize word */,"function capitalize(word: string): string {
  return word.charAt(0).toUpperCase() + word.slice(1);
}

console.log(capitalize(""hello"")); // Output: ""Hello"""
/* add sprite to scene in decentraland */,"function createSprite() {
  const sprite = new Entity('sprite')
  engine.addEntity(sprite)
  return sprite
}

const sprite = createSprite();

//Add a Sprite component to the sprite Entity
const spriteComponent = new Sprite()
sprite.addComponent(spriteComponent)"
/* function to create a 'door' entity in decentraland */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}"
/* add a shape to the door in decentraland */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

//Add a shape component to the door Entity
const doorShape = new BoxShape()
door.addComponent(doorShape)"
/* add material to the door in decentraland */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

// Add a material component to the door Entity
const doorMaterial = new Material()
doorMaterial.albedoColor = Color3.FromHexString(""#8B5E3C"")
door.addComponent(doorMaterial)"
/* transform the door in dcl */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

//  Create a Transform component to position the door
const doorTransform = new Transform({
  position: new Vector3(8, 0, 8),
  scale: new Vector3(1, 2, 0.5)
})
door.addComponent(doorTransform)"
/* function to open and close the door in dcl */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

// Create a function to open and close the door
function toggleDoor() {
  if (doorTransform.rotation.y === 0) {
    doorTransform.rotation.y = 1.57
  } else {
    doorTransform.rotation.y = 0
  }
}"
/* function for interacting with the door in decentraland */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

// Create a function to open and close the door
function toggleDoor() {
  if (doorTransform.rotation.y === 0) {
    doorTransform.rotation.y = 1.57
  } else {
    doorTransform.rotation.y = 0
  }
}

// Create a clicking event to trigger the toggleDoor function
door.addComponent(
  new OnClick(() => {
    toggleDoor()
  })
)"
/* hover event for changing the door material on hover */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

// Create a hover event to change the door material when hovered over
door.addComponent(
  new OnPointerHoverEnter(() => {
    doorMaterial.albedoColor = Color3.FromHexString(""#A0522D"")
  })
)
door.addComponent(
  new OnPointerHoverExit(() => {
    doorMaterial.albedoColor = Color3.FromHexString(""#8B5E3C"")
  })
)"
/* function the add sound to the door in decentraland */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

// Add a sound component to play a sound when the door opens or closes
const doorSound = new AudioClip('sounds/door-open-close.mp3')
const doorAudioSource = new AudioSource(doorSound)
door.addComponent(doorAudioSource)"
/* function for sound when door opens and closes in dcl */,"function createDoor() {
  const door = new Entity('door')
  engine.addEntity(door)
  return door
}

const door = createDoor();

// Add a sound component to play a sound when the door opens or closes
const doorSound = new AudioClip('sounds/door-open-close.mp3')
const doorAudioSource = new AudioSource(doorSound)
door.addComponent(doorAudioSource)

// Modify the toggleDoor function to play a sound when the door opens or closes
function toggleDoorWithSound() {
  if (doorTransform.rotation.y === 0) {
    doorTransform.rotation.y = 1.57
    doorAudioSource.playOnce()
  } else {
    doorTransform.rotation.y = 0
    doorAudioSource.playOnce()
  }
}"